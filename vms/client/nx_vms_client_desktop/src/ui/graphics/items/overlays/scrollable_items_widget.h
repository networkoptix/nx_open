// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/

#pragma once

#include <QtWidgets/QGraphicsWidget>

#include <nx/utils/uuid.h>

class QnScrollableItemsWidgetPrivate;

/**
  *  Container class that displays graphics items on a scrollable area.
  */
class QnScrollableItemsWidget: public QGraphicsWidget
{
    Q_OBJECT
    using base_type = QGraphicsWidget;

public:
    QnScrollableItemsWidget(QGraphicsItem* parent = nullptr);
    virtual ~QnScrollableItemsWidget();

    /** Alignment of items inside scrollable area. */
    Qt::Alignment alignment() const;
    void setAlignment(Qt::Alignment alignment);

    /** Vertical spacing of items inside scrollable area. */
    qreal spacing() const;
    void setSpacing(qreal value);

    /** Add item to scrollable area at the end. Ownership of the item is taken.
      * If externalId is not null it's used as unique item id, otherwise it is autogenerated.
      * If item is successfully added, its unique id is returned.
      * If another item with specified externalId already exists,
      *    new item isn't added and null uuid is returned. */
    nx::Uuid addItem(QGraphicsWidget* item, const nx::Uuid& externalId = nx::Uuid());

    /** Insert item to scrollable area at specified position. Ownership of the item is taken.
      * If externalId is not null it's used as unique item id, otherwise it is autogenerated.
      * If item is successfully added, its unique id is returned.
      * If another item with specified externalId already exists,
      *    new item isn't inserted and null uuid is returned. */
    nx::Uuid insertItem(int index, QGraphicsWidget* item, const nx::Uuid& externalId = nx::Uuid());

    /** Remove item from scrollable area and return it. Item ownership is passed to the caller.
      * If no item with specified id exists, nullptr is returned. */
    QGraphicsWidget* takeItem(const nx::Uuid& id);

    /** Remove item from scrollable area and delete the item.
      * Returns true if an item is found and deleted, false otherwise. */
    bool deleteItem(const nx::Uuid& id);

    /** Remove all items from scrollable area and delete them. */
    void clear();

    /** Count of items in scrollable area. */
    int count() const;

    /** Return id of the item by index. */
    nx::Uuid itemId(int index) const;

    /** Item by index in scrollable area. Returns nullptr if index is out of range. */
    QGraphicsWidget* item(int index) const;

    /** Item by unique id. Returns nullptr if an item with specified id is not found. */
    QGraphicsWidget* item(const nx::Uuid& id) const;

    /** Scroll amount in pixels that is considered one line. */
    int lineHeight() const;
    void setLineHeight(int value);

    /** If enabled, sizeHint() always return 0 as minimum height (enabled by default). */
    void setIgnoreMinimumHeight(bool enabled);

signals:
    void contentHeightChanged();
    void contentWidthChanged();

protected:
    virtual QSizeF sizeHint(Qt::SizeHint which,
        const QSizeF& constraint = QSizeF()) const override;

private:
    Q_DECLARE_PRIVATE(QnScrollableItemsWidget);
    QScopedPointer<QnScrollableItemsWidgetPrivate> const d_ptr;
};
