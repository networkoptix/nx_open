// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/

#pragma once

#include <memory>
#include <optional>

#include <QtCore/QObject>

#include <nx/network/ssl/helpers.h>
#include <nx/utils/impl_ptr.h>
#include <nx/utils/uuid.h>
#include <nx/vms/common/network/abstract_certificate_verifier.h>

#include "server_certificate_validation_level.h"

namespace nx::vms::client::core {

class CertificateStorage;
class RemoteSession;

/**
 * Ensures certificate can be used to establish connection. User interaction requested if needed,
 * confirmed certificates are pinned.
 */
class NX_VMS_CLIENT_CORE_API CertificateVerifier: public common::AbstractCertificateVerifier
{
    Q_OBJECT
    using base_type = nx::vms::common::AbstractCertificateVerifier;

public:
    enum class CertificateType
    {
        autogenerated,
        connection,
    };

    enum class Status
    {
        ok,
        notFound,
        mismatch,
    };

    /**
     * Verifier will use given storages to check if the provided non-public certificate is
     * auto-generated by the server (if we already connected to the system) or is manually pinned by
     * the user. Accepted certificates are pinned to the connection certificates storage.
     * Ownership is not passed, caller must ensure correct destruction order.
     */
    CertificateVerifier(
        network::server_certificate::ValidationLevel certificateValidationLevel,
        CertificateStorage* connectionCertificatesStorage,
        CertificateStorage* autoGeneratedCertificatesStorage,
        QObject* parent = nullptr);

    virtual ~CertificateVerifier() override;

    /**
     * Create AdapterFunc that accepts only certificates with matching public key. This function
     * is intended to be used when establishing a connection.
     */
    nx::network::ssl::AdapterFunc makeRestrictedAdapterFunc(const std::string& expectedKey);

    /**
     * Create AdapterFunc that first attempts to perform a system certificate check and if it fails,
     * accepts only certificates with matching public key. This function is intended to be used when
     * establishing a connection.
     */
    nx::network::ssl::AdapterFunc makeGeneralAdapterFunc(
        const std::string& expectedKey, const std::string& expectedHost);

    /**
     * Create AdapterFunc that uses the active connection certificate cache.
     */
    virtual nx::network::ssl::AdapterFunc makeAdapterFunc(
        const nx::Uuid& serverId, const nx::utils::Url& url = {}) override;

    /**
     * Check certificate chain using certificate keys in persistent storage.
     */
    Status verifyCertificate(
        const nx::Uuid& serverId,
        const nx::network::ssl::CertificateChain& chain,
        bool acceptExpired = false) const;

    void setValidationLevel(network::server_certificate::ValidationLevel certificateValidationLevel);

    /**
     * Store given certificate's public key, replacing existing if present.
     */
    void pinCertificate(
        const nx::Uuid& serverId,
        const std::string& publicKey,
        CertificateType certType = CertificateType::connection);

    std::optional<std::string> pinnedCertificate(
        const nx::Uuid& serverId,
        CertificateType certType);

    /**
     * Updates cached certificate in memory. If the cached certificate matched a pinned certiifcate
     * of the server before the call, updates the pinned certificate too.
     */
    void updateCertificate(
        const nx::Uuid& serverId,
        const std::string& publicKey,
        CertificateType certType);

    void removeCertificatesFromCache(const nx::Uuid& serverId);

    void setSession(std::weak_ptr<RemoteSession> session);

private:
    struct Private;
    nx::utils::ImplPtr<Private> d;
};

/**
 * Per-session certificate cache.
 */
class CertificateCache: public nx::vms::common::AbstractCertificateVerifier
{
    Q_OBJECT
    using base_type = nx::vms::common::AbstractCertificateVerifier;

public:
    CertificateCache(QObject* parent = nullptr);
    virtual ~CertificateCache() override;

    void addCertificate(
        const nx::Uuid& serverId,
        const std::string& publicKey,
        CertificateVerifier::CertificateType certType);

    std::optional<std::string> certificate(
        const nx::Uuid& serverId,
        CertificateVerifier::CertificateType certType) const;

    void removeCertificates(const nx::Uuid& serverId);

    virtual nx::network::ssl::AdapterFunc makeAdapterFunc(
        const nx::Uuid& serverId, const nx::utils::Url& url = {}) override;

private:
    struct Private;
    std::shared_ptr<Private> d;
};

} // namespace nx::vms::client::core
