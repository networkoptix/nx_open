#include <audit/mserver_audit_manager.h>
#include <test_support/mediaserver_launcher.h>

#include <gtest/gtest.h>

#include <QtCore/QByteArray>
#include <QSqlDatabase>
#include <QSqlQuery>

#include <tuple>

namespace nx::vms::server::test {

class AuditManager: public ::testing::Test
{
public:
    virtual void SetUp() override
    {
        ASSERT_TRUE(m_server.start());
        m_authSession = createAuthSession();
        m_versionParam = std::make_tuple("version", "4.0.0.1");
    }

    void whenServerStopped()
    {
        m_server.stop();
    }

    void whenARSaved()
    {
        const auto auditManager = m_server.serverModule()->auditManager();
        auto authRecord = auditManager->prepareRecord(m_authSession, Qn::AR_UpdateInstall);
        authRecord.addParam(std::get<0>(m_versionParam), std::get<1>(m_versionParam));
        auditManager->addAuditRecord(authRecord);
    }

    void thenARShouldBePresentInDb()
    {
        const QString connectionName = "test";
        auto db = QSqlDatabase::addDatabase("QSQLITE", connectionName);

        db.setDatabaseName(closeDirPath(m_server.dataDir()) + "mserver.sqlite");
        ASSERT_TRUE(db.open());

        QSqlQuery query(db);
        ASSERT_TRUE(query.prepare("SELECT eventType FROM audit_log where eventType = ?"));
        query.addBindValue(static_cast<int>(Qn::AR_UpdateInstall));
        ASSERT_TRUE(query.exec());
        ASSERT_TRUE(query.next());

        db = QSqlDatabase();
        QSqlDatabase::removeDatabase(connectionName);
    }

private:
    MediaServerLauncher m_server;
    QnAuthSession m_authSession;
    std::tuple<QByteArray, QByteArray> m_versionParam;

    static QnAuthSession createAuthSession()
    {
        QnAuthSession authSession;
        authSession.id = QnUuid::createUuid();
        authSession.userHost = "host";
        authSession.userName = "name";
        authSession.userAgent = "agent";
        authSession.isAutoGenerated = false;

        return authSession;
    }
};

TEST_F(AuditManager, FlushRecordsOnStop)
{
    whenARSaved();
    whenServerStopped();
    thenARShouldBePresentInDb();
}

TEST(MServerAuditManager, MergeRecords)
{
    using Record = detail::CameraPlaybackInfo;
    QVector<Record> recordsToAggregate;

    Record record;
    record.session.id = QnUuid::createUuid();
    record.cameraId = QnUuid::createUuid();
    record.timeout.restart();

    recordsToAggregate.push_back(record);
    record.cameraId = QnUuid::createUuid();
    recordsToAggregate.push_back(record);

    record.session.id = QnUuid::createUuid();
    record.cameraId = QnUuid::createUuid();
    recordsToAggregate.push_back(record);

    detail::processDelayedRecords(recordsToAggregate, 1000 * 1000);
    ASSERT_EQ(3, recordsToAggregate.size());

    std::this_thread::sleep_for(std::chrono::milliseconds(3));
    auto result = detail::processDelayedRecords(recordsToAggregate, 0);
    ASSERT_EQ(0, recordsToAggregate.size());

    ASSERT_EQ(2, result.size());

    int resourceCount = 0;
    for (const auto& record: result)
        resourceCount += record.resources.size();

    ASSERT_EQ(3, resourceCount);
}

} // namespace nx::vms::server::test
