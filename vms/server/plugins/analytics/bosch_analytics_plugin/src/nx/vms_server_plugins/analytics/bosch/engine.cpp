// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/

#include "engine.h"

#include <map>

#include <QtCore/QString>
#include <QtCore/QUrlQuery>
#include <QtCore/QFile>
#include <QtCore/QFileInfo>

#include <nx/network/http/http_client.h>
#include <nx/vms/api/analytics/device_agent_manifest.h>
#include <nx/fusion/model_functions.h>
#include <nx/utils/scope_guard.h>
#include <nx/utils/log/log_main.h>
#include <nx/utils/std/algorithm.h>

#include <nx/sdk/helpers/string.h>
#include <nx/sdk/helpers/error.h>

#include "device_agent.h"

namespace nx::vms_server_plugins::analytics::bosch {

namespace {

static const QString kBoschVendor("bosch");

} // namespace

QManifestByteArray::QManifestByteArray()
{
    QFile file("plugins/bosch/manifest.json");
    if (file.open(QFile::ReadOnly))
    {
        NX_INFO(this,
            lm("Switch to external manifest file %1").arg(QFileInfo(file).absoluteFilePath()));
    }
    else
    {
        file.setFileName(":/bosch/manifest.json");
        bool manifestIsLoaded = file.open(QFile::ReadOnly);
        NX_ASSERT(manifestIsLoaded);
    }
    QByteArray::operator=(file.readAll());
}

Engine::Engine(nx::sdk::analytics::Plugin* plugin)
    :
    m_plugin(plugin),
    m_manifestByteArray(),
    m_manifest(QJson::deserialized<Bosch::EngineManifest>(m_manifestByteArray))
{
}

//-------------------------------------------------------------------------------------------------

/**
 * Called right after the Engine creation (before all other methods) or when some
 * Engine-related change occurs on the Server side (e.g. Engine name is changed).
 */
/*virtual*/ void Engine::setEngineInfo(const IEngineInfo* engineInfo) /*override*/
{
    m_engineInfo.loadFrom(engineInfo);
}

/**
 * Called after setEngineInfo() and before all other methods. Server provides the set of
 * settings stored in its database, combined with the values received from the plugin via
 * pluginSideSettings() (if any), for this Engine instance.
 */
/*virtual*/ void Engine::doSetSettings(
    Result<const ISettingsResponse*>* outResult, const IStringMap* settings) /*override*/
{
    // There are no Engine settings for this plugin.
}

/**
 * In addition to the settings stored in a Server database, an Engine can have some settings
 * which are stored somewhere "under the hood" of the Engine, e.g. on a device acting as an
 * Engine's backend. Such settings do not need to be explicitly marked in the Settings Model,
 * but every time the Server offers the user to edit the values, it calls this method and
 * merges the received values with the ones in its database.
 */
/*virtual*/ void Engine::getPluginSideSettings(
    Result<const ISettingsResponse*>* outResult) const /*override*/
{
    // The Engine of this plugin provides no settings.
}

/**
 * Provides a JSON manifest for this Engine instance. See the example of such manifest in
 * stub_analytics_plugin. Can either be static (constant), or can be dynamically generated by
 * this Engine based on its current state, including setting values received via setSettings().
 * After creation of this Engine instance, this method is called after setSettings(), but can
 * be called again at any other moment to obtain the most actual manifest.
 */
/*virtual*/ void Engine::getManifest(Result<const IString*>* outResult) const /*override*/
{
    *outResult = new nx::sdk::String(QJson::serialized(m_manifest));
}

/**
 * @return True if the Engine is able to create DeviceAgents for the provided device, false
 *     otherwise.
 */
/*virtual*/ bool Engine::isCompatible(const IDeviceInfo* deviceInfo) const /*override*/
{
    const QString vendor = QString(deviceInfo->vendor()).toLower();
    return vendor == kBoschVendor;
}

/**
 * Called when the Server opens a video-connection to the camera if the plugin is enabled for this
 * camera.
 */
/*virtual*/ void Engine::doObtainDeviceAgent(
    Result<IDeviceAgent*>* outResult, const IDeviceInfo* deviceInfo) /*override*/
{
    *outResult = new DeviceAgent(this, deviceInfo);
}

/**
 * Action handler. Called when some action defined by this Engine is triggered by Server.
 */
/*virtual*/ void Engine::doExecuteAction(
    Result<IAction::Result>* /*outResult*/, const IAction* /*action*/) /*override*/
{
    // This Engine does not execute actions.
}

/**
 * @param handler Generic Engine-related events (errors, warning, info messages)
 *     might be reported via this handler.
 */
/*virtual*/ void Engine::setHandler(IHandler* /*handler*/) /*override*/
{
    // This handler might be used in future.
}

//-------------------------------------------------------------------------------------------------

} // namespace nx::vms_server_plugins::analytics::bosch

namespace {

static const std::string kPluginManifest = /*suppress newline*/ 1 + (const char*)R"json(
{
    "id": "nx.bosch",
    "name": "Bosch analytics",
    "description": "Access control solution designed to make it easier than ever to manage and monitoring facility access.",
    "version": "1.0.0",
    "vendor": "Bosch"
}
)json";

} // namespace

extern "C" {

NX_PLUGIN_API nx::sdk::IPlugin* createNxPlugin()
{
    return new nx::sdk::analytics::Plugin(
        kPluginManifest,
        [](nx::sdk::analytics::IPlugin* plugin)
        {
            return new nx::vms_server_plugins::analytics::bosch::Engine(
                dynamic_cast<nx::sdk::analytics::Plugin*>(plugin));
        });
}

} // extern "C"
