/* soapStub.h
   Generated by gSOAP 2.8.55 for generated_with_wsdl2h/axis_soap_event_action

gSOAP XML Web services tools
Copyright (C) 2000-2017, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#include <vector>
#define SOAP_NAMESPACE_OF_ns1	"http://www.axis.com/vapix/ws/event1"
#define SOAP_NAMESPACE_OF_ns2	"http://docs.oasis-open.org/wsn/t-1"
#define SOAP_NAMESPACE_OF_ns3	"http://docs.oasis-open.org/wsn/b-2"
#define SOAP_NAMESPACE_OF_ns4	"http://docs.oasis-open.org/wsrf/bf-2"
#define SOAP_NAMESPACE_OF_ns5	"http://www.axis.com/vapix/ws/action1"
#define SOAP_NAMESPACE_OF_ns6	"http://www.w3.org/2005/08/addressing"

#ifndef soapStub_H
#define soapStub_H
#include "stdsoap2.h"
#if GSOAP_VERSION != 20855
# error "GSOAP VERSION 20855 MISMATCH IN GENERATED CODE VERSUS LIBRARY CODE: PLEASE REINSTALL PACKAGE"
#endif


/******************************************************************************\
 *                                                                            *
 * Enumeration Types                                                          *
 *                                                                            *
\******************************************************************************/


/* generated_with_wsdl2h/axis_soap_event_action:758 */
#ifndef SOAP_TYPE_ns1__ScheduledType
#define SOAP_TYPE_ns1__ScheduledType (177)
/* ns1:ScheduledType */
enum class ns1__ScheduledType {
	Interval = 0,
	Pulse = 1
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:859 */
#ifndef SOAP_TYPE_ns6__RelationshipType
#define SOAP_TYPE_ns6__RelationshipType (185)
/* ns6:RelationshipType */
enum class ns6__RelationshipType {
	http_x003a_x002f_x002fwww_x002ew3_x002eorg_x002f2005_x002f08_x002faddressing_x002freply = 0
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:873 */
#ifndef SOAP_TYPE_ns6__FaultCodesType
#define SOAP_TYPE_ns6__FaultCodesType (187)
/* ns6:FaultCodesType */
enum class ns6__FaultCodesType {
	ns6__InvalidAddressingHeader = 0,
	ns6__InvalidAddress = 1,
	ns6__InvalidEPR = 2,
	ns6__InvalidCardinality = 3,
	ns6__MissingAddressInEPR = 4,
	ns6__DuplicateMessageID = 5,
	ns6__ActionMismatch = 6,
	ns6__MessageAddressingHeaderRequired = 7,
	ns6__DestinationUnreachable = 8,
	ns6__ActionNotSupported = 9,
	ns6__EndpointUnavailable = 10
};
#endif

/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/* dom.h:62 */
#ifndef SOAP_TYPE_xsd__anyType
#define SOAP_TYPE_xsd__anyType (10)
typedef struct soap_dom_element xsd__anyType;
#endif

/* dom.h:65 */
#ifndef SOAP_TYPE_xsd__anyAttribute
#define SOAP_TYPE_xsd__anyAttribute (12)
typedef struct soap_dom_attribute xsd__anyAttribute;
#endif

/* generated_with_wsdl2h/axis_soap_event_action:172 */
#ifndef SOAP_TYPE_xsd__QName
#define SOAP_TYPE_xsd__QName (14)
typedef std::string xsd__QName;
#endif


/******************************************************************************\
 *                                                                            *
 * Classes, Structs and Unions                                                *
 *                                                                            *
\******************************************************************************/

class xsd__NCName_;	/* generated_with_wsdl2h/axis_soap_event_action:179 */
class xsd__QName_;	/* generated_with_wsdl2h/axis_soap_event_action:186 */
class xsd__anyURI_;	/* generated_with_wsdl2h/axis_soap_event_action:196 */
class xsd__boolean;	/* generated_with_wsdl2h/axis_soap_event_action:203 */
class xsd__dateTime;	/* generated_with_wsdl2h/axis_soap_event_action:210 */
class xsd__duration_;	/* generated_with_wsdl2h/axis_soap_event_action:220 */
class xsd__int;	/* generated_with_wsdl2h/axis_soap_event_action:227 */
class xsd__integer_;	/* generated_with_wsdl2h/axis_soap_event_action:237 */
class xsd__nonNegativeInteger_;	/* generated_with_wsdl2h/axis_soap_event_action:247 */
class xsd__string;	/* generated_with_wsdl2h/axis_soap_event_action:254 */
class xsd__token_;	/* generated_with_wsdl2h/axis_soap_event_action:264 */
class xsd__unsignedLong;	/* generated_with_wsdl2h/axis_soap_event_action:271 */
class ns1__ScheduledType__;	/* generated_with_wsdl2h/axis_soap_event_action:765 */
class ns2__FullTopicExpression__;	/* generated_with_wsdl2h/axis_soap_event_action:788 */
class ns2__ConcreteTopicExpression__;	/* generated_with_wsdl2h/axis_soap_event_action:804 */
class ns2__SimpleTopicExpression__;	/* generated_with_wsdl2h/axis_soap_event_action:819 */
class ns6__RelationshipType__;	/* generated_with_wsdl2h/axis_soap_event_action:865 */
class ns6__FaultCodesType__;	/* generated_with_wsdl2h/axis_soap_event_action:889 */
class ns1__NewScheduledEvent;	/* generated_with_wsdl2h/axis_soap_event_action:288 */
class ns1__ScheduledEvents;	/* generated_with_wsdl2h/axis_soap_event_action:291 */
class ns1__ScheduledEvent;	/* generated_with_wsdl2h/axis_soap_event_action:294 */
class ns1__Schedule;	/* generated_with_wsdl2h/axis_soap_event_action:297 */
class ns1__ScheduleFilter;	/* generated_with_wsdl2h/axis_soap_event_action:303 */
class _ns1__GetEventInstances;	/* generated_with_wsdl2h/axis_soap_event_action:306 */
class _ns1__GetEventInstancesResponse;	/* generated_with_wsdl2h/axis_soap_event_action:309 */
class _ns1__AddScheduledEvent;	/* generated_with_wsdl2h/axis_soap_event_action:312 */
class _ns1__AddScheduledEventResponse;	/* generated_with_wsdl2h/axis_soap_event_action:315 */
class _ns1__RemoveScheduledEvent;	/* generated_with_wsdl2h/axis_soap_event_action:318 */
class _ns1__RemoveScheduledEventResponse;	/* generated_with_wsdl2h/axis_soap_event_action:321 */
class _ns1__GetScheduledEvents;	/* generated_with_wsdl2h/axis_soap_event_action:324 */
class _ns1__GetScheduledEventsResponse;	/* generated_with_wsdl2h/axis_soap_event_action:327 */
class _ns1__ScheduledEventNotFoundFault;	/* generated_with_wsdl2h/axis_soap_event_action:330 */
class _ns1__InvalidScheduleFault;	/* generated_with_wsdl2h/axis_soap_event_action:333 */
class _ns1__InvalidScheduledEventIDFault;	/* generated_with_wsdl2h/axis_soap_event_action:336 */
class _ns1__ScheduledEventAlreadyExistsFault;	/* generated_with_wsdl2h/axis_soap_event_action:339 */
class _ns1__ChangeVirtualInputState;	/* generated_with_wsdl2h/axis_soap_event_action:342 */
class _ns1__ChangeVirtualInputStateResponse;	/* generated_with_wsdl2h/axis_soap_event_action:345 */
class ns2__Documentation;	/* generated_with_wsdl2h/axis_soap_event_action:348 */
class ns2__ExtensibleDocumented;	/* generated_with_wsdl2h/axis_soap_event_action:351 */
class ns2__QueryExpressionType;	/* generated_with_wsdl2h/axis_soap_event_action:354 */
class ns3__QueryExpressionType;	/* generated_with_wsdl2h/axis_soap_event_action:366 */
class ns3__TopicExpressionType;	/* generated_with_wsdl2h/axis_soap_event_action:369 */
class ns3__FilterType;	/* generated_with_wsdl2h/axis_soap_event_action:372 */
class ns3__SubscriptionPolicyType;	/* generated_with_wsdl2h/axis_soap_event_action:375 */
class _ns3__NotificationMessageHolderType_Message;	/* generated_with_wsdl2h/axis_soap_event_action:1563 */
class ns3__NotificationMessageHolderType;	/* generated_with_wsdl2h/axis_soap_event_action:378 */
class _ns3__NotificationProducerRP;	/* generated_with_wsdl2h/axis_soap_event_action:441 */
class _ns3__SubscriptionManagerRP;	/* generated_with_wsdl2h/axis_soap_event_action:444 */
class _ns3__Notify;	/* generated_with_wsdl2h/axis_soap_event_action:447 */
class _ns3__UseRaw;	/* generated_with_wsdl2h/axis_soap_event_action:450 */
class _ns3__Subscribe_SubscriptionPolicy;	/* generated_with_wsdl2h/axis_soap_event_action:1704 */
class _ns3__Subscribe;	/* generated_with_wsdl2h/axis_soap_event_action:453 */
class _ns3__SubscribeResponse;	/* generated_with_wsdl2h/axis_soap_event_action:456 */
class _ns3__GetCurrentMessage;	/* generated_with_wsdl2h/axis_soap_event_action:459 */
class _ns3__GetCurrentMessageResponse;	/* generated_with_wsdl2h/axis_soap_event_action:462 */
class _ns3__GetMessages;	/* generated_with_wsdl2h/axis_soap_event_action:465 */
class _ns3__GetMessagesResponse;	/* generated_with_wsdl2h/axis_soap_event_action:468 */
class _ns3__DestroyPullPoint;	/* generated_with_wsdl2h/axis_soap_event_action:471 */
class _ns3__DestroyPullPointResponse;	/* generated_with_wsdl2h/axis_soap_event_action:474 */
class _ns3__CreatePullPoint;	/* generated_with_wsdl2h/axis_soap_event_action:477 */
class _ns3__CreatePullPointResponse;	/* generated_with_wsdl2h/axis_soap_event_action:480 */
class _ns3__Renew;	/* generated_with_wsdl2h/axis_soap_event_action:483 */
class _ns3__RenewResponse;	/* generated_with_wsdl2h/axis_soap_event_action:486 */
class _ns3__Unsubscribe;	/* generated_with_wsdl2h/axis_soap_event_action:489 */
class _ns3__UnsubscribeResponse;	/* generated_with_wsdl2h/axis_soap_event_action:492 */
class _ns3__PauseSubscription;	/* generated_with_wsdl2h/axis_soap_event_action:495 */
class _ns3__PauseSubscriptionResponse;	/* generated_with_wsdl2h/axis_soap_event_action:498 */
class _ns3__ResumeSubscription;	/* generated_with_wsdl2h/axis_soap_event_action:501 */
class _ns3__ResumeSubscriptionResponse;	/* generated_with_wsdl2h/axis_soap_event_action:504 */
class _ns4__BaseFaultType_ErrorCode;	/* generated_with_wsdl2h/axis_soap_event_action:2268 */
class _ns4__BaseFaultType_Description;	/* generated_with_wsdl2h/axis_soap_event_action:2289 */
class _ns4__BaseFaultType_FaultCause;	/* generated_with_wsdl2h/axis_soap_event_action:2306 */
class ns4__BaseFaultType;	/* generated_with_wsdl2h/axis_soap_event_action:507 */
class ns5__NewActionRule;	/* generated_with_wsdl2h/axis_soap_event_action:510 */
class ns5__Conditions;	/* generated_with_wsdl2h/axis_soap_event_action:513 */
class ns5__ActionRules;	/* generated_with_wsdl2h/axis_soap_event_action:516 */
class ns5__ActionRule;	/* generated_with_wsdl2h/axis_soap_event_action:519 */
class ns5__NewRecipientConfiguration;	/* generated_with_wsdl2h/axis_soap_event_action:522 */
class ns5__RecipientConfiguration;	/* generated_with_wsdl2h/axis_soap_event_action:525 */
class ns5__RecipientConfigurations;	/* generated_with_wsdl2h/axis_soap_event_action:528 */
class ns5__RecipientTemplates;	/* generated_with_wsdl2h/axis_soap_event_action:531 */
class ns5__RecipientTemplate;	/* generated_with_wsdl2h/axis_soap_event_action:534 */
class ns5__ActionConfigurations;	/* generated_with_wsdl2h/axis_soap_event_action:537 */
class ns5__NewActionConfiguration;	/* generated_with_wsdl2h/axis_soap_event_action:540 */
class ns5__ActionConfiguration;	/* generated_with_wsdl2h/axis_soap_event_action:543 */
class ns5__ActionParameters;	/* generated_with_wsdl2h/axis_soap_event_action:546 */
class ns5__ActionTemplates;	/* generated_with_wsdl2h/axis_soap_event_action:549 */
class ns5__ActionParameter;	/* generated_with_wsdl2h/axis_soap_event_action:552 */
class ns5__ActionTemplate;	/* generated_with_wsdl2h/axis_soap_event_action:555 */
class ns5__ActionTemplateParameters;	/* generated_with_wsdl2h/axis_soap_event_action:558 */
class ns5__ActionTemplateParameter;	/* generated_with_wsdl2h/axis_soap_event_action:561 */
class ns5__UsedByActionConfigurations;	/* generated_with_wsdl2h/axis_soap_event_action:564 */
class ns5__UsedActionConfiguration;	/* generated_with_wsdl2h/axis_soap_event_action:567 */
class ns5__UsedByActionRules;	/* generated_with_wsdl2h/axis_soap_event_action:570 */
class ns5__UsedActionRule;	/* generated_with_wsdl2h/axis_soap_event_action:573 */
class _ns5__GetActionTemplates;	/* generated_with_wsdl2h/axis_soap_event_action:576 */
class _ns5__GetActionTemplatesResponse;	/* generated_with_wsdl2h/axis_soap_event_action:579 */
class _ns5__AddActionConfiguration;	/* generated_with_wsdl2h/axis_soap_event_action:582 */
class _ns5__AddActionConfigurationResponse;	/* generated_with_wsdl2h/axis_soap_event_action:585 */
class _ns5__RemoveActionConfiguration;	/* generated_with_wsdl2h/axis_soap_event_action:588 */
class _ns5__RemoveActionConfigurationResponse;	/* generated_with_wsdl2h/axis_soap_event_action:591 */
class _ns5__GetActionConfigurations;	/* generated_with_wsdl2h/axis_soap_event_action:594 */
class _ns5__GetActionConfigurationsResponse;	/* generated_with_wsdl2h/axis_soap_event_action:597 */
class _ns5__GetRecipientTemplates;	/* generated_with_wsdl2h/axis_soap_event_action:600 */
class _ns5__GetRecipientTemplatesResponse;	/* generated_with_wsdl2h/axis_soap_event_action:603 */
class _ns5__AddRecipientConfiguration;	/* generated_with_wsdl2h/axis_soap_event_action:606 */
class _ns5__AddRecipientConfigurationResponse;	/* generated_with_wsdl2h/axis_soap_event_action:609 */
class _ns5__RemoveRecipientConfiguration;	/* generated_with_wsdl2h/axis_soap_event_action:612 */
class _ns5__RemoveRecipientConfigurationResponse;	/* generated_with_wsdl2h/axis_soap_event_action:615 */
class _ns5__GetRecipientConfigurations;	/* generated_with_wsdl2h/axis_soap_event_action:618 */
class _ns5__GetRecipientConfigurationsResponse;	/* generated_with_wsdl2h/axis_soap_event_action:621 */
class _ns5__AddActionRule;	/* generated_with_wsdl2h/axis_soap_event_action:624 */
class _ns5__AddActionRuleResponse;	/* generated_with_wsdl2h/axis_soap_event_action:627 */
class _ns5__GetActionRules;	/* generated_with_wsdl2h/axis_soap_event_action:630 */
class _ns5__GetActionRulesResponse;	/* generated_with_wsdl2h/axis_soap_event_action:633 */
class _ns5__RemoveActionRule;	/* generated_with_wsdl2h/axis_soap_event_action:636 */
class _ns5__RemoveActionRuleResponse;	/* generated_with_wsdl2h/axis_soap_event_action:639 */
class _ns5__ActionTemplateNotFoundFault;	/* generated_with_wsdl2h/axis_soap_event_action:642 */
class _ns5__RecipientConfigurationNotFoundFault;	/* generated_with_wsdl2h/axis_soap_event_action:645 */
class _ns5__ParametersMissmatchFault;	/* generated_with_wsdl2h/axis_soap_event_action:648 */
class _ns5__InvalidActionConfigurationFault;	/* generated_with_wsdl2h/axis_soap_event_action:651 */
class _ns5__ActionConfigurationNotFoundFault;	/* generated_with_wsdl2h/axis_soap_event_action:654 */
class _ns5__RecipientTemplateNotFoundFault;	/* generated_with_wsdl2h/axis_soap_event_action:657 */
class _ns5__ActionConfigurationIsInUseFault;	/* generated_with_wsdl2h/axis_soap_event_action:660 */
class _ns5__InvalidConditionFilterFault;	/* generated_with_wsdl2h/axis_soap_event_action:663 */
class _ns5__InsufficientActivationRuleFault;	/* generated_with_wsdl2h/axis_soap_event_action:666 */
class _ns5__ActionRuleNotFoundFault;	/* generated_with_wsdl2h/axis_soap_event_action:669 */
class _ns5__InvalidActivationTimeoutFault;	/* generated_with_wsdl2h/axis_soap_event_action:672 */
class ns6__EndpointReferenceType;	/* generated_with_wsdl2h/axis_soap_event_action:675 */
class ns6__ReferenceParametersType;	/* generated_with_wsdl2h/axis_soap_event_action:678 */
class ns6__MetadataType;	/* generated_with_wsdl2h/axis_soap_event_action:681 */
class ns6__ProblemActionType;	/* generated_with_wsdl2h/axis_soap_event_action:696 */
class ns1__ICalendar;	/* generated_with_wsdl2h/axis_soap_event_action:300 */
class _ns2__TopicNamespaceType_Topic;	/* generated_with_wsdl2h/axis_soap_event_action:3833 */
class ns2__TopicNamespaceType;	/* generated_with_wsdl2h/axis_soap_event_action:357 */
class ns2__TopicType;	/* generated_with_wsdl2h/axis_soap_event_action:360 */
class ns2__TopicSetType;	/* generated_with_wsdl2h/axis_soap_event_action:363 */
class ns3__SubscribeCreationFailedFaultType;	/* generated_with_wsdl2h/axis_soap_event_action:381 */
class ns3__InvalidFilterFaultType;	/* generated_with_wsdl2h/axis_soap_event_action:384 */
class ns3__TopicExpressionDialectUnknownFaultType;	/* generated_with_wsdl2h/axis_soap_event_action:387 */
class ns3__InvalidTopicExpressionFaultType;	/* generated_with_wsdl2h/axis_soap_event_action:390 */
class ns3__TopicNotSupportedFaultType;	/* generated_with_wsdl2h/axis_soap_event_action:393 */
class ns3__MultipleTopicsSpecifiedFaultType;	/* generated_with_wsdl2h/axis_soap_event_action:396 */
class ns3__InvalidProducerPropertiesExpressionFaultType;	/* generated_with_wsdl2h/axis_soap_event_action:399 */
class ns3__InvalidMessageContentExpressionFaultType;	/* generated_with_wsdl2h/axis_soap_event_action:402 */
class ns3__UnrecognizedPolicyRequestFaultType;	/* generated_with_wsdl2h/axis_soap_event_action:405 */
class ns3__UnsupportedPolicyRequestFaultType;	/* generated_with_wsdl2h/axis_soap_event_action:408 */
class ns3__NotifyMessageNotSupportedFaultType;	/* generated_with_wsdl2h/axis_soap_event_action:411 */
class ns3__UnacceptableInitialTerminationTimeFaultType;	/* generated_with_wsdl2h/axis_soap_event_action:414 */
class ns3__NoCurrentMessageOnTopicFaultType;	/* generated_with_wsdl2h/axis_soap_event_action:417 */
class ns3__UnableToGetMessagesFaultType;	/* generated_with_wsdl2h/axis_soap_event_action:420 */
class ns3__UnableToDestroyPullPointFaultType;	/* generated_with_wsdl2h/axis_soap_event_action:423 */
class ns3__UnableToCreatePullPointFaultType;	/* generated_with_wsdl2h/axis_soap_event_action:426 */
class ns3__UnacceptableTerminationTimeFaultType;	/* generated_with_wsdl2h/axis_soap_event_action:429 */
class ns3__UnableToDestroySubscriptionFaultType;	/* generated_with_wsdl2h/axis_soap_event_action:432 */
class ns3__PauseFailedFaultType;	/* generated_with_wsdl2h/axis_soap_event_action:435 */
class ns3__ResumeFailedFaultType;	/* generated_with_wsdl2h/axis_soap_event_action:438 */
class ns6__RelatesToType;	/* generated_with_wsdl2h/axis_soap_event_action:684 */
class ns6__AttributedURIType;	/* generated_with_wsdl2h/axis_soap_event_action:687 */
class ns6__AttributedUnsignedLongType;	/* generated_with_wsdl2h/axis_soap_event_action:690 */
class ns6__AttributedQNameType;	/* generated_with_wsdl2h/axis_soap_event_action:693 */
struct __ns1__GetEventInstances;	/* generated_with_wsdl2h/axis_soap_event_action:6454 */
struct __ns1__AddScheduledEvent;	/* generated_with_wsdl2h/axis_soap_event_action:6534 */
struct __ns1__RemoveScheduledEvent;	/* generated_with_wsdl2h/axis_soap_event_action:6607 */
struct __ns1__GetScheduledEvents;	/* generated_with_wsdl2h/axis_soap_event_action:6677 */
struct __ns1__ChangeVirtualInputState;	/* generated_with_wsdl2h/axis_soap_event_action:6747 */
struct __ns5__GetActionTemplates;	/* generated_with_wsdl2h/axis_soap_event_action:6835 */
struct __ns5__AddActionConfiguration;	/* generated_with_wsdl2h/axis_soap_event_action:6914 */
struct __ns5__RemoveActionConfiguration;	/* generated_with_wsdl2h/axis_soap_event_action:6990 */
struct __ns5__GetActionConfigurations;	/* generated_with_wsdl2h/axis_soap_event_action:7060 */
struct __ns5__GetRecipientTemplates;	/* generated_with_wsdl2h/axis_soap_event_action:7130 */
struct __ns5__AddRecipientConfiguration;	/* generated_with_wsdl2h/axis_soap_event_action:7206 */
struct __ns5__RemoveRecipientConfiguration;	/* generated_with_wsdl2h/axis_soap_event_action:7279 */
struct __ns5__GetRecipientConfigurations;	/* generated_with_wsdl2h/axis_soap_event_action:7349 */
struct __ns5__AddActionRule;	/* generated_with_wsdl2h/axis_soap_event_action:7443 */
struct __ns5__GetActionRules;	/* generated_with_wsdl2h/axis_soap_event_action:7513 */
struct __ns5__RemoveActionRule;	/* generated_with_wsdl2h/axis_soap_event_action:7586 */

/* generated_with_wsdl2h/axis_soap_event_action:179 */
#ifndef SOAP_TYPE_xsd__NCName_
#define SOAP_TYPE_xsd__NCName_ (16)
/* Type xsd__NCName_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:NCName': */
class SOAP_CMAC xsd__NCName_ : public soap_dom_element {
      public:
        /// Simple content of XSD type 'xsd:NCName' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__NCName_
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__NCName_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__NCName_, default initialized and not managed by a soap context
        virtual xsd__NCName_ *soap_alloc(void) const { return SOAP_NEW(xsd__NCName_); }
      public:
        /// Constructor with initializations
        xsd__NCName_() : __item() { }
        virtual ~xsd__NCName_() { }
        /// Friend allocator used by soap_new_xsd__NCName_(struct soap*, int)
        friend SOAP_FMAC1 xsd__NCName_ * SOAP_FMAC2 soap_instantiate_xsd__NCName_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:186 */
#ifndef SOAP_TYPE_xsd__QName_
#define SOAP_TYPE_xsd__QName_ (17)
/* Type xsd__QName_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:QName': */
class SOAP_CMAC xsd__QName_ : public soap_dom_element {
      public:
        /// Simple content of XSD type 'xsd:QName' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__QName_
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__QName_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__QName_, default initialized and not managed by a soap context
        virtual xsd__QName_ *soap_alloc(void) const { return SOAP_NEW(xsd__QName_); }
      public:
        /// Constructor with initializations
        xsd__QName_() : __item() { }
        virtual ~xsd__QName_() { }
        /// Friend allocator used by soap_new_xsd__QName_(struct soap*, int)
        friend SOAP_FMAC1 xsd__QName_ * SOAP_FMAC2 soap_instantiate_xsd__QName_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:196 */
#ifndef SOAP_TYPE_xsd__anyURI_
#define SOAP_TYPE_xsd__anyURI_ (19)
/* Type xsd__anyURI_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:anyURI': */
class SOAP_CMAC xsd__anyURI_ : public soap_dom_element {
      public:
        /// Simple content of XSD type 'xsd:anyURI' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__anyURI_
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__anyURI_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__anyURI_, default initialized and not managed by a soap context
        virtual xsd__anyURI_ *soap_alloc(void) const { return SOAP_NEW(xsd__anyURI_); }
      public:
        /// Constructor with initializations
        xsd__anyURI_() : __item() { }
        virtual ~xsd__anyURI_() { }
        /// Friend allocator used by soap_new_xsd__anyURI_(struct soap*, int)
        friend SOAP_FMAC1 xsd__anyURI_ * SOAP_FMAC2 soap_instantiate_xsd__anyURI_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:203 */
#ifndef SOAP_TYPE_xsd__boolean
#define SOAP_TYPE_xsd__boolean (20)
/* Type xsd__boolean is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:boolean': */
class SOAP_CMAC xsd__boolean : public soap_dom_element {
      public:
        /// Simple content of XSD type 'xsd:boolean' wrapped by this struct
        bool __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__boolean
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__boolean; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__boolean, default initialized and not managed by a soap context
        virtual xsd__boolean *soap_alloc(void) const { return SOAP_NEW(xsd__boolean); }
      public:
        /// Constructor with initializations
        xsd__boolean() : __item() { }
        virtual ~xsd__boolean() { }
        /// Friend allocator used by soap_new_xsd__boolean(struct soap*, int)
        friend SOAP_FMAC1 xsd__boolean * SOAP_FMAC2 soap_instantiate_xsd__boolean(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:210 */
#ifndef SOAP_TYPE_xsd__dateTime
#define SOAP_TYPE_xsd__dateTime (22)
/* Type xsd__dateTime is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:dateTime': */
class SOAP_CMAC xsd__dateTime : public soap_dom_element {
      public:
        /// Simple content of XSD type 'xsd:dateTime' wrapped by this struct
        time_t __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__dateTime
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__dateTime; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__dateTime, default initialized and not managed by a soap context
        virtual xsd__dateTime *soap_alloc(void) const { return SOAP_NEW(xsd__dateTime); }
      public:
        /// Constructor with initializations
        xsd__dateTime() : __item() { }
        virtual ~xsd__dateTime() { }
        /// Friend allocator used by soap_new_xsd__dateTime(struct soap*, int)
        friend SOAP_FMAC1 xsd__dateTime * SOAP_FMAC2 soap_instantiate_xsd__dateTime(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:220 */
#ifndef SOAP_TYPE_xsd__duration_
#define SOAP_TYPE_xsd__duration_ (25)
/* Type xsd__duration_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:duration': */
class SOAP_CMAC xsd__duration_ : public soap_dom_element {
      public:
        /// Simple content of XSD type 'xsd:duration' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__duration_
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__duration_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__duration_, default initialized and not managed by a soap context
        virtual xsd__duration_ *soap_alloc(void) const { return SOAP_NEW(xsd__duration_); }
      public:
        /// Constructor with initializations
        xsd__duration_() : __item() { }
        virtual ~xsd__duration_() { }
        /// Friend allocator used by soap_new_xsd__duration_(struct soap*, int)
        friend SOAP_FMAC1 xsd__duration_ * SOAP_FMAC2 soap_instantiate_xsd__duration_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:227 */
#ifndef SOAP_TYPE_xsd__int
#define SOAP_TYPE_xsd__int (26)
/* Type xsd__int is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:int': */
class SOAP_CMAC xsd__int : public soap_dom_element {
      public:
        /// Simple content of XSD type 'xsd:int' wrapped by this struct
        int __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__int
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__int; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__int, default initialized and not managed by a soap context
        virtual xsd__int *soap_alloc(void) const { return SOAP_NEW(xsd__int); }
      public:
        /// Constructor with initializations
        xsd__int() : __item() { }
        virtual ~xsd__int() { }
        /// Friend allocator used by soap_new_xsd__int(struct soap*, int)
        friend SOAP_FMAC1 xsd__int * SOAP_FMAC2 soap_instantiate_xsd__int(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:237 */
#ifndef SOAP_TYPE_xsd__integer_
#define SOAP_TYPE_xsd__integer_ (28)
/* Type xsd__integer_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:integer': */
class SOAP_CMAC xsd__integer_ : public soap_dom_element {
      public:
        /// Simple content of XSD type 'xsd:integer' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__integer_
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__integer_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__integer_, default initialized and not managed by a soap context
        virtual xsd__integer_ *soap_alloc(void) const { return SOAP_NEW(xsd__integer_); }
      public:
        /// Constructor with initializations
        xsd__integer_() : __item() { }
        virtual ~xsd__integer_() { }
        /// Friend allocator used by soap_new_xsd__integer_(struct soap*, int)
        friend SOAP_FMAC1 xsd__integer_ * SOAP_FMAC2 soap_instantiate_xsd__integer_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:247 */
#ifndef SOAP_TYPE_xsd__nonNegativeInteger_
#define SOAP_TYPE_xsd__nonNegativeInteger_ (30)
/* Type xsd__nonNegativeInteger_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:nonNegativeInteger': */
class SOAP_CMAC xsd__nonNegativeInteger_ : public soap_dom_element {
      public:
        /// Simple content of XSD type 'xsd:nonNegativeInteger' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__nonNegativeInteger_
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__nonNegativeInteger_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__nonNegativeInteger_, default initialized and not managed by a soap context
        virtual xsd__nonNegativeInteger_ *soap_alloc(void) const { return SOAP_NEW(xsd__nonNegativeInteger_); }
      public:
        /// Constructor with initializations
        xsd__nonNegativeInteger_() : __item() { }
        virtual ~xsd__nonNegativeInteger_() { }
        /// Friend allocator used by soap_new_xsd__nonNegativeInteger_(struct soap*, int)
        friend SOAP_FMAC1 xsd__nonNegativeInteger_ * SOAP_FMAC2 soap_instantiate_xsd__nonNegativeInteger_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:254 */
#ifndef SOAP_TYPE_xsd__string
#define SOAP_TYPE_xsd__string (31)
/* Type xsd__string is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:string': */
class SOAP_CMAC xsd__string : public soap_dom_element {
      public:
        /// Simple content of XSD type 'xsd:string' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__string
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__string; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__string, default initialized and not managed by a soap context
        virtual xsd__string *soap_alloc(void) const { return SOAP_NEW(xsd__string); }
      public:
        /// Constructor with initializations
        xsd__string() : __item() { }
        virtual ~xsd__string() { }
        /// Friend allocator used by soap_new_xsd__string(struct soap*, int)
        friend SOAP_FMAC1 xsd__string * SOAP_FMAC2 soap_instantiate_xsd__string(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:264 */
#ifndef SOAP_TYPE_xsd__token_
#define SOAP_TYPE_xsd__token_ (33)
/* Type xsd__token_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:token': */
class SOAP_CMAC xsd__token_ : public soap_dom_element {
      public:
        /// Simple content of XSD type 'xsd:token' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__token_
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__token_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__token_, default initialized and not managed by a soap context
        virtual xsd__token_ *soap_alloc(void) const { return SOAP_NEW(xsd__token_); }
      public:
        /// Constructor with initializations
        xsd__token_() : __item() { }
        virtual ~xsd__token_() { }
        /// Friend allocator used by soap_new_xsd__token_(struct soap*, int)
        friend SOAP_FMAC1 xsd__token_ * SOAP_FMAC2 soap_instantiate_xsd__token_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:271 */
#ifndef SOAP_TYPE_xsd__unsignedLong
#define SOAP_TYPE_xsd__unsignedLong (34)
/* Type xsd__unsignedLong is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:unsignedLong': */
class SOAP_CMAC xsd__unsignedLong : public soap_dom_element {
      public:
        /// Simple content of XSD type 'xsd:unsignedLong' wrapped by this struct
        ULONG64 __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__unsignedLong
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__unsignedLong; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__unsignedLong, default initialized and not managed by a soap context
        virtual xsd__unsignedLong *soap_alloc(void) const { return SOAP_NEW(xsd__unsignedLong); }
      public:
        /// Constructor with initializations
        xsd__unsignedLong() : __item() { }
        virtual ~xsd__unsignedLong() { }
        /// Friend allocator used by soap_new_xsd__unsignedLong(struct soap*, int)
        friend SOAP_FMAC1 xsd__unsignedLong * SOAP_FMAC2 soap_instantiate_xsd__unsignedLong(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:765 */
#ifndef SOAP_TYPE_ns1__ScheduledType__
#define SOAP_TYPE_ns1__ScheduledType__ (178)
/* Type ns1__ScheduledType__ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'ns1:ScheduledType': */
class SOAP_CMAC ns1__ScheduledType__ : public soap_dom_element {
      public:
        /// Simple content of XSD type 'ns1:ScheduledType' wrapped by this struct
        ns1__ScheduledType __item;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ScheduledType__
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__ScheduledType__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ScheduledType__, default initialized and not managed by a soap context
        virtual ns1__ScheduledType__ *soap_alloc(void) const { return SOAP_NEW(ns1__ScheduledType__); }
      public:
        /// Constructor with initializations
        ns1__ScheduledType__() : __item() { }
        virtual ~ns1__ScheduledType__() { }
        /// Friend allocator used by soap_new_ns1__ScheduledType__(struct soap*, int)
        friend SOAP_FMAC1 ns1__ScheduledType__ * SOAP_FMAC2 soap_instantiate_ns1__ScheduledType__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:788 */
#ifndef SOAP_TYPE_ns2__FullTopicExpression__
#define SOAP_TYPE_ns2__FullTopicExpression__ (180)
/* Type ns2__FullTopicExpression__ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'ns2:FullTopicExpression': */
class SOAP_CMAC ns2__FullTopicExpression__ : public soap_dom_element {
      public:
        /// Simple content of XSD type 'ns2:FullTopicExpression' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_ns2__FullTopicExpression__
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__FullTopicExpression__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__FullTopicExpression__, default initialized and not managed by a soap context
        virtual ns2__FullTopicExpression__ *soap_alloc(void) const { return SOAP_NEW(ns2__FullTopicExpression__); }
      public:
        /// Constructor with initializations
        ns2__FullTopicExpression__() : __item() { }
        virtual ~ns2__FullTopicExpression__() { }
        /// Friend allocator used by soap_new_ns2__FullTopicExpression__(struct soap*, int)
        friend SOAP_FMAC1 ns2__FullTopicExpression__ * SOAP_FMAC2 soap_instantiate_ns2__FullTopicExpression__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:804 */
#ifndef SOAP_TYPE_ns2__ConcreteTopicExpression__
#define SOAP_TYPE_ns2__ConcreteTopicExpression__ (182)
/* Type ns2__ConcreteTopicExpression__ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'ns2:ConcreteTopicExpression': */
class SOAP_CMAC ns2__ConcreteTopicExpression__ : public soap_dom_element {
      public:
        /// Simple content of XSD type 'ns2:ConcreteTopicExpression' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ConcreteTopicExpression__
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__ConcreteTopicExpression__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ConcreteTopicExpression__, default initialized and not managed by a soap context
        virtual ns2__ConcreteTopicExpression__ *soap_alloc(void) const { return SOAP_NEW(ns2__ConcreteTopicExpression__); }
      public:
        /// Constructor with initializations
        ns2__ConcreteTopicExpression__() : __item() { }
        virtual ~ns2__ConcreteTopicExpression__() { }
        /// Friend allocator used by soap_new_ns2__ConcreteTopicExpression__(struct soap*, int)
        friend SOAP_FMAC1 ns2__ConcreteTopicExpression__ * SOAP_FMAC2 soap_instantiate_ns2__ConcreteTopicExpression__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:819 */
#ifndef SOAP_TYPE_ns2__SimpleTopicExpression__
#define SOAP_TYPE_ns2__SimpleTopicExpression__ (184)
/* Type ns2__SimpleTopicExpression__ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'ns2:SimpleTopicExpression': */
class SOAP_CMAC ns2__SimpleTopicExpression__ : public soap_dom_element {
      public:
        /// Simple content of XSD type 'xsd:QName' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_ns2__SimpleTopicExpression__
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__SimpleTopicExpression__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__SimpleTopicExpression__, default initialized and not managed by a soap context
        virtual ns2__SimpleTopicExpression__ *soap_alloc(void) const { return SOAP_NEW(ns2__SimpleTopicExpression__); }
      public:
        /// Constructor with initializations
        ns2__SimpleTopicExpression__() : __item() { }
        virtual ~ns2__SimpleTopicExpression__() { }
        /// Friend allocator used by soap_new_ns2__SimpleTopicExpression__(struct soap*, int)
        friend SOAP_FMAC1 ns2__SimpleTopicExpression__ * SOAP_FMAC2 soap_instantiate_ns2__SimpleTopicExpression__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:865 */
#ifndef SOAP_TYPE_ns6__RelationshipType__
#define SOAP_TYPE_ns6__RelationshipType__ (186)
/* Type ns6__RelationshipType__ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'ns6:RelationshipType': */
class SOAP_CMAC ns6__RelationshipType__ : public soap_dom_element {
      public:
        /// Simple content of XSD type 'ns6:RelationshipType' wrapped by this struct
        ns6__RelationshipType __item;
      public:
        /// Return unique type id SOAP_TYPE_ns6__RelationshipType__
        virtual long soap_type(void) const { return SOAP_TYPE_ns6__RelationshipType__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns6__RelationshipType__, default initialized and not managed by a soap context
        virtual ns6__RelationshipType__ *soap_alloc(void) const { return SOAP_NEW(ns6__RelationshipType__); }
      public:
        /// Constructor with initializations
        ns6__RelationshipType__() : __item() { }
        virtual ~ns6__RelationshipType__() { }
        /// Friend allocator used by soap_new_ns6__RelationshipType__(struct soap*, int)
        friend SOAP_FMAC1 ns6__RelationshipType__ * SOAP_FMAC2 soap_instantiate_ns6__RelationshipType__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:889 */
#ifndef SOAP_TYPE_ns6__FaultCodesType__
#define SOAP_TYPE_ns6__FaultCodesType__ (188)
/* Type ns6__FaultCodesType__ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'ns6:FaultCodesType': */
class SOAP_CMAC ns6__FaultCodesType__ : public soap_dom_element {
      public:
        /// Simple content of XSD type 'ns6:FaultCodesType' wrapped by this struct
        ns6__FaultCodesType __item;
      public:
        /// Return unique type id SOAP_TYPE_ns6__FaultCodesType__
        virtual long soap_type(void) const { return SOAP_TYPE_ns6__FaultCodesType__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns6__FaultCodesType__, default initialized and not managed by a soap context
        virtual ns6__FaultCodesType__ *soap_alloc(void) const { return SOAP_NEW(ns6__FaultCodesType__); }
      public:
        /// Constructor with initializations
        ns6__FaultCodesType__() : __item() { }
        virtual ~ns6__FaultCodesType__() { }
        /// Friend allocator used by soap_new_ns6__FaultCodesType__(struct soap*, int)
        friend SOAP_FMAC1 ns6__FaultCodesType__ * SOAP_FMAC2 soap_instantiate_ns6__FaultCodesType__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:288 */
#ifndef SOAP_TYPE_ns1__NewScheduledEvent
#define SOAP_TYPE_ns1__NewScheduledEvent (37)
/* Type ns1__NewScheduledEvent is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:NewScheduledEvent': */
class SOAP_CMAC ns1__NewScheduledEvent : public soap_dom_element {
      public:
        /// Optional element 'ns1:EventID' of XSD type 'xsd:string'
        std::string *EventID;
        /// Optional element 'ns1:Name' of XSD type 'xsd:string'
        std::string *Name;
        /// Required element 'ns1:Schedule' of XSD type 'ns1:Schedule'
        ns1__Schedule *Schedule;
      public:
        /// Return unique type id SOAP_TYPE_ns1__NewScheduledEvent
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__NewScheduledEvent; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__NewScheduledEvent, default initialized and not managed by a soap context
        virtual ns1__NewScheduledEvent *soap_alloc(void) const { return SOAP_NEW(ns1__NewScheduledEvent); }
      public:
        /// Constructor with initializations
        ns1__NewScheduledEvent() : EventID(), Name(), Schedule() { }
        virtual ~ns1__NewScheduledEvent() { }
        /// Friend allocator used by soap_new_ns1__NewScheduledEvent(struct soap*, int)
        friend SOAP_FMAC1 ns1__NewScheduledEvent * SOAP_FMAC2 soap_instantiate_ns1__NewScheduledEvent(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:291 */
#ifndef SOAP_TYPE_ns1__ScheduledEvents
#define SOAP_TYPE_ns1__ScheduledEvents (38)
/* Type ns1__ScheduledEvents is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:ScheduledEvents': */
class SOAP_CMAC ns1__ScheduledEvents : public soap_dom_element {
      public:
        /// Optional element 'ns1:ScheduledEvent' of XSD type 'ns1:ScheduledEvent'
        std::vector<ns1__ScheduledEvent *> ScheduledEvent;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ScheduledEvents
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__ScheduledEvents; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ScheduledEvents, default initialized and not managed by a soap context
        virtual ns1__ScheduledEvents *soap_alloc(void) const { return SOAP_NEW(ns1__ScheduledEvents); }
      public:
        /// Constructor with initializations
        ns1__ScheduledEvents() : ScheduledEvent() { }
        virtual ~ns1__ScheduledEvents() { }
        /// Friend allocator used by soap_new_ns1__ScheduledEvents(struct soap*, int)
        friend SOAP_FMAC1 ns1__ScheduledEvents * SOAP_FMAC2 soap_instantiate_ns1__ScheduledEvents(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:294 */
#ifndef SOAP_TYPE_ns1__ScheduledEvent
#define SOAP_TYPE_ns1__ScheduledEvent (39)
/* Type ns1__ScheduledEvent is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:ScheduledEvent': */
class SOAP_CMAC ns1__ScheduledEvent : public soap_dom_element {
      public:
        /// Required element 'ns1:EventID' of XSD type 'xsd:string'
        std::string EventID;
        /// Optional element 'ns1:Name' of XSD type 'xsd:string'
        std::string *Name;
        /// Required element 'ns1:Schedule' of XSD type 'ns1:Schedule'
        ns1__Schedule *Schedule;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ScheduledEvent
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__ScheduledEvent; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ScheduledEvent, default initialized and not managed by a soap context
        virtual ns1__ScheduledEvent *soap_alloc(void) const { return SOAP_NEW(ns1__ScheduledEvent); }
      public:
        /// Constructor with initializations
        ns1__ScheduledEvent() : EventID(), Name(), Schedule() { }
        virtual ~ns1__ScheduledEvent() { }
        /// Friend allocator used by soap_new_ns1__ScheduledEvent(struct soap*, int)
        friend SOAP_FMAC1 ns1__ScheduledEvent * SOAP_FMAC2 soap_instantiate_ns1__ScheduledEvent(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:297 */
#ifndef SOAP_TYPE_ns1__Schedule
#define SOAP_TYPE_ns1__Schedule (40)
/* Type ns1__Schedule is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:Schedule': */
class SOAP_CMAC ns1__Schedule : public soap_dom_element {
      public:
        /// Required element 'ns1:ICalendar' of XSD type 'ns1:ICalendar'
        ns1__ICalendar *ICalendar;
      public:
        /// Return unique type id SOAP_TYPE_ns1__Schedule
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__Schedule; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__Schedule, default initialized and not managed by a soap context
        virtual ns1__Schedule *soap_alloc(void) const { return SOAP_NEW(ns1__Schedule); }
      public:
        /// Constructor with initializations
        ns1__Schedule() : ICalendar() { }
        virtual ~ns1__Schedule() { }
        /// Friend allocator used by soap_new_ns1__Schedule(struct soap*, int)
        friend SOAP_FMAC1 ns1__Schedule * SOAP_FMAC2 soap_instantiate_ns1__Schedule(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:303 */
#ifndef SOAP_TYPE_ns1__ScheduleFilter
#define SOAP_TYPE_ns1__ScheduleFilter (42)
/* Type ns1__ScheduleFilter is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:ScheduleFilter': */
class SOAP_CMAC ns1__ScheduleFilter : public soap_dom_element {
      public:
        /// Optional element 'ns1:ScheduleType' of XSD type 'ns1:ScheduledType'
        ns1__ScheduledType *ScheduleType;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ScheduleFilter
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__ScheduleFilter; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ScheduleFilter, default initialized and not managed by a soap context
        virtual ns1__ScheduleFilter *soap_alloc(void) const { return SOAP_NEW(ns1__ScheduleFilter); }
      public:
        /// Constructor with initializations
        ns1__ScheduleFilter() : ScheduleType() { }
        virtual ~ns1__ScheduleFilter() { }
        /// Friend allocator used by soap_new_ns1__ScheduleFilter(struct soap*, int)
        friend SOAP_FMAC1 ns1__ScheduleFilter * SOAP_FMAC2 soap_instantiate_ns1__ScheduleFilter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:306 */
#ifndef SOAP_TYPE__ns1__GetEventInstances
#define SOAP_TYPE__ns1__GetEventInstances (43)
/* complex XSD type 'ns1:GetEventInstances': */
class SOAP_CMAC _ns1__GetEventInstances {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetEventInstances
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__GetEventInstances; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetEventInstances, default initialized and not managed by a soap context
        virtual _ns1__GetEventInstances *soap_alloc(void) const { return SOAP_NEW(_ns1__GetEventInstances); }
      public:
        /// Constructor with initializations
        _ns1__GetEventInstances() : soap() { }
        virtual ~_ns1__GetEventInstances() { }
        /// Friend allocator used by soap_new__ns1__GetEventInstances(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetEventInstances * SOAP_FMAC2 soap_instantiate__ns1__GetEventInstances(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:309 */
#ifndef SOAP_TYPE__ns1__GetEventInstancesResponse
#define SOAP_TYPE__ns1__GetEventInstancesResponse (44)
/* complex XSD type 'ns1:GetEventInstancesResponse': */
class SOAP_CMAC _ns1__GetEventInstancesResponse {
      public:
        /// Required element 'ns2:TopicSet' of XSD type 'ns2:TopicSetType'
        ns2__TopicSetType *ns2__TopicSet;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetEventInstancesResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__GetEventInstancesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetEventInstancesResponse, default initialized and not managed by a soap context
        virtual _ns1__GetEventInstancesResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetEventInstancesResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetEventInstancesResponse() : ns2__TopicSet(), soap() { }
        virtual ~_ns1__GetEventInstancesResponse() { }
        /// Friend allocator used by soap_new__ns1__GetEventInstancesResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetEventInstancesResponse * SOAP_FMAC2 soap_instantiate__ns1__GetEventInstancesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:312 */
#ifndef SOAP_TYPE__ns1__AddScheduledEvent
#define SOAP_TYPE__ns1__AddScheduledEvent (45)
/* complex XSD type 'ns1:AddScheduledEvent': */
class SOAP_CMAC _ns1__AddScheduledEvent {
      public:
        /// Required element 'ns1:NewScheduledEvent' of XSD type 'ns1:NewScheduledEvent'
        ns1__NewScheduledEvent *NewScheduledEvent;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__AddScheduledEvent
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__AddScheduledEvent; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__AddScheduledEvent, default initialized and not managed by a soap context
        virtual _ns1__AddScheduledEvent *soap_alloc(void) const { return SOAP_NEW(_ns1__AddScheduledEvent); }
      public:
        /// Constructor with initializations
        _ns1__AddScheduledEvent() : NewScheduledEvent(), soap() { }
        virtual ~_ns1__AddScheduledEvent() { }
        /// Friend allocator used by soap_new__ns1__AddScheduledEvent(struct soap*, int)
        friend SOAP_FMAC1 _ns1__AddScheduledEvent * SOAP_FMAC2 soap_instantiate__ns1__AddScheduledEvent(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:315 */
#ifndef SOAP_TYPE__ns1__AddScheduledEventResponse
#define SOAP_TYPE__ns1__AddScheduledEventResponse (46)
/* complex XSD type 'ns1:AddScheduledEventResponse': */
class SOAP_CMAC _ns1__AddScheduledEventResponse {
      public:
        /// Optional element 'ns1:EventID' of XSD type 'xsd:string'
        std::string *EventID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__AddScheduledEventResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__AddScheduledEventResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__AddScheduledEventResponse, default initialized and not managed by a soap context
        virtual _ns1__AddScheduledEventResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__AddScheduledEventResponse); }
      public:
        /// Constructor with initializations
        _ns1__AddScheduledEventResponse() : EventID(), soap() { }
        virtual ~_ns1__AddScheduledEventResponse() { }
        /// Friend allocator used by soap_new__ns1__AddScheduledEventResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__AddScheduledEventResponse * SOAP_FMAC2 soap_instantiate__ns1__AddScheduledEventResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:318 */
#ifndef SOAP_TYPE__ns1__RemoveScheduledEvent
#define SOAP_TYPE__ns1__RemoveScheduledEvent (47)
/* complex XSD type 'ns1:RemoveScheduledEvent': */
class SOAP_CMAC _ns1__RemoveScheduledEvent {
      public:
        /// Required element 'ns1:EventID' of XSD type 'xsd:string'
        std::string EventID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__RemoveScheduledEvent
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__RemoveScheduledEvent; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__RemoveScheduledEvent, default initialized and not managed by a soap context
        virtual _ns1__RemoveScheduledEvent *soap_alloc(void) const { return SOAP_NEW(_ns1__RemoveScheduledEvent); }
      public:
        /// Constructor with initializations
        _ns1__RemoveScheduledEvent() : EventID(), soap() { }
        virtual ~_ns1__RemoveScheduledEvent() { }
        /// Friend allocator used by soap_new__ns1__RemoveScheduledEvent(struct soap*, int)
        friend SOAP_FMAC1 _ns1__RemoveScheduledEvent * SOAP_FMAC2 soap_instantiate__ns1__RemoveScheduledEvent(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:321 */
#ifndef SOAP_TYPE__ns1__RemoveScheduledEventResponse
#define SOAP_TYPE__ns1__RemoveScheduledEventResponse (48)
/* complex XSD type 'ns1:RemoveScheduledEventResponse': */
class SOAP_CMAC _ns1__RemoveScheduledEventResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__RemoveScheduledEventResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__RemoveScheduledEventResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__RemoveScheduledEventResponse, default initialized and not managed by a soap context
        virtual _ns1__RemoveScheduledEventResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__RemoveScheduledEventResponse); }
      public:
        /// Constructor with initializations
        _ns1__RemoveScheduledEventResponse() : soap() { }
        virtual ~_ns1__RemoveScheduledEventResponse() { }
        /// Friend allocator used by soap_new__ns1__RemoveScheduledEventResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__RemoveScheduledEventResponse * SOAP_FMAC2 soap_instantiate__ns1__RemoveScheduledEventResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:324 */
#ifndef SOAP_TYPE__ns1__GetScheduledEvents
#define SOAP_TYPE__ns1__GetScheduledEvents (49)
/* complex XSD type 'ns1:GetScheduledEvents': */
class SOAP_CMAC _ns1__GetScheduledEvents {
      public:
        /// Optional element 'ns1:ScheduleFilter' of XSD type 'ns1:ScheduleFilter'
        ns1__ScheduleFilter *ScheduleFilter;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetScheduledEvents
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__GetScheduledEvents; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetScheduledEvents, default initialized and not managed by a soap context
        virtual _ns1__GetScheduledEvents *soap_alloc(void) const { return SOAP_NEW(_ns1__GetScheduledEvents); }
      public:
        /// Constructor with initializations
        _ns1__GetScheduledEvents() : ScheduleFilter(), soap() { }
        virtual ~_ns1__GetScheduledEvents() { }
        /// Friend allocator used by soap_new__ns1__GetScheduledEvents(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetScheduledEvents * SOAP_FMAC2 soap_instantiate__ns1__GetScheduledEvents(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:327 */
#ifndef SOAP_TYPE__ns1__GetScheduledEventsResponse
#define SOAP_TYPE__ns1__GetScheduledEventsResponse (50)
/* complex XSD type 'ns1:GetScheduledEventsResponse': */
class SOAP_CMAC _ns1__GetScheduledEventsResponse {
      public:
        /// Required element 'ns1:ScheduledEvents' of XSD type 'ns1:ScheduledEvents'
        ns1__ScheduledEvents *ScheduledEvents;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetScheduledEventsResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__GetScheduledEventsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetScheduledEventsResponse, default initialized and not managed by a soap context
        virtual _ns1__GetScheduledEventsResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetScheduledEventsResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetScheduledEventsResponse() : ScheduledEvents(), soap() { }
        virtual ~_ns1__GetScheduledEventsResponse() { }
        /// Friend allocator used by soap_new__ns1__GetScheduledEventsResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetScheduledEventsResponse * SOAP_FMAC2 soap_instantiate__ns1__GetScheduledEventsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:330 */
#ifndef SOAP_TYPE__ns1__ScheduledEventNotFoundFault
#define SOAP_TYPE__ns1__ScheduledEventNotFoundFault (51)
/* complex XSD type 'ns1:ScheduledEventNotFoundFault': */
class SOAP_CMAC _ns1__ScheduledEventNotFoundFault {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__ScheduledEventNotFoundFault
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__ScheduledEventNotFoundFault; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__ScheduledEventNotFoundFault, default initialized and not managed by a soap context
        virtual _ns1__ScheduledEventNotFoundFault *soap_alloc(void) const { return SOAP_NEW(_ns1__ScheduledEventNotFoundFault); }
      public:
        /// Constructor with initializations
        _ns1__ScheduledEventNotFoundFault() : soap() { }
        virtual ~_ns1__ScheduledEventNotFoundFault() { }
        /// Friend allocator used by soap_new__ns1__ScheduledEventNotFoundFault(struct soap*, int)
        friend SOAP_FMAC1 _ns1__ScheduledEventNotFoundFault * SOAP_FMAC2 soap_instantiate__ns1__ScheduledEventNotFoundFault(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:333 */
#ifndef SOAP_TYPE__ns1__InvalidScheduleFault
#define SOAP_TYPE__ns1__InvalidScheduleFault (52)
/* complex XSD type 'ns1:InvalidScheduleFault': */
class SOAP_CMAC _ns1__InvalidScheduleFault {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__InvalidScheduleFault
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__InvalidScheduleFault; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__InvalidScheduleFault, default initialized and not managed by a soap context
        virtual _ns1__InvalidScheduleFault *soap_alloc(void) const { return SOAP_NEW(_ns1__InvalidScheduleFault); }
      public:
        /// Constructor with initializations
        _ns1__InvalidScheduleFault() : soap() { }
        virtual ~_ns1__InvalidScheduleFault() { }
        /// Friend allocator used by soap_new__ns1__InvalidScheduleFault(struct soap*, int)
        friend SOAP_FMAC1 _ns1__InvalidScheduleFault * SOAP_FMAC2 soap_instantiate__ns1__InvalidScheduleFault(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:336 */
#ifndef SOAP_TYPE__ns1__InvalidScheduledEventIDFault
#define SOAP_TYPE__ns1__InvalidScheduledEventIDFault (53)
/* complex XSD type 'ns1:InvalidScheduledEventIDFault': */
class SOAP_CMAC _ns1__InvalidScheduledEventIDFault {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__InvalidScheduledEventIDFault
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__InvalidScheduledEventIDFault; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__InvalidScheduledEventIDFault, default initialized and not managed by a soap context
        virtual _ns1__InvalidScheduledEventIDFault *soap_alloc(void) const { return SOAP_NEW(_ns1__InvalidScheduledEventIDFault); }
      public:
        /// Constructor with initializations
        _ns1__InvalidScheduledEventIDFault() : soap() { }
        virtual ~_ns1__InvalidScheduledEventIDFault() { }
        /// Friend allocator used by soap_new__ns1__InvalidScheduledEventIDFault(struct soap*, int)
        friend SOAP_FMAC1 _ns1__InvalidScheduledEventIDFault * SOAP_FMAC2 soap_instantiate__ns1__InvalidScheduledEventIDFault(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:339 */
#ifndef SOAP_TYPE__ns1__ScheduledEventAlreadyExistsFault
#define SOAP_TYPE__ns1__ScheduledEventAlreadyExistsFault (54)
/* complex XSD type 'ns1:ScheduledEventAlreadyExistsFault': */
class SOAP_CMAC _ns1__ScheduledEventAlreadyExistsFault {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__ScheduledEventAlreadyExistsFault
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__ScheduledEventAlreadyExistsFault; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__ScheduledEventAlreadyExistsFault, default initialized and not managed by a soap context
        virtual _ns1__ScheduledEventAlreadyExistsFault *soap_alloc(void) const { return SOAP_NEW(_ns1__ScheduledEventAlreadyExistsFault); }
      public:
        /// Constructor with initializations
        _ns1__ScheduledEventAlreadyExistsFault() : soap() { }
        virtual ~_ns1__ScheduledEventAlreadyExistsFault() { }
        /// Friend allocator used by soap_new__ns1__ScheduledEventAlreadyExistsFault(struct soap*, int)
        friend SOAP_FMAC1 _ns1__ScheduledEventAlreadyExistsFault * SOAP_FMAC2 soap_instantiate__ns1__ScheduledEventAlreadyExistsFault(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:342 */
#ifndef SOAP_TYPE__ns1__ChangeVirtualInputState
#define SOAP_TYPE__ns1__ChangeVirtualInputState (55)
/* complex XSD type 'ns1:ChangeVirtualInputState': */
class SOAP_CMAC _ns1__ChangeVirtualInputState {
      public:
        /// Required element 'ns1:port' of XSD type 'xsd:int'
        int port;
        /// Required element 'ns1:active' of XSD type 'xsd:boolean'
        bool active;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__ChangeVirtualInputState
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__ChangeVirtualInputState; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__ChangeVirtualInputState, default initialized and not managed by a soap context
        virtual _ns1__ChangeVirtualInputState *soap_alloc(void) const { return SOAP_NEW(_ns1__ChangeVirtualInputState); }
      public:
        /// Constructor with initializations
        _ns1__ChangeVirtualInputState() : port(), active(), soap() { }
        virtual ~_ns1__ChangeVirtualInputState() { }
        /// Friend allocator used by soap_new__ns1__ChangeVirtualInputState(struct soap*, int)
        friend SOAP_FMAC1 _ns1__ChangeVirtualInputState * SOAP_FMAC2 soap_instantiate__ns1__ChangeVirtualInputState(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:345 */
#ifndef SOAP_TYPE__ns1__ChangeVirtualInputStateResponse
#define SOAP_TYPE__ns1__ChangeVirtualInputStateResponse (56)
/* complex XSD type 'ns1:ChangeVirtualInputStateResponse': */
class SOAP_CMAC _ns1__ChangeVirtualInputStateResponse {
      public:
        /// Required element 'ns1:stateChanged' of XSD type 'xsd:boolean'
        bool stateChanged;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__ChangeVirtualInputStateResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__ChangeVirtualInputStateResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__ChangeVirtualInputStateResponse, default initialized and not managed by a soap context
        virtual _ns1__ChangeVirtualInputStateResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__ChangeVirtualInputStateResponse); }
      public:
        /// Constructor with initializations
        _ns1__ChangeVirtualInputStateResponse() : stateChanged(), soap() { }
        virtual ~_ns1__ChangeVirtualInputStateResponse() { }
        /// Friend allocator used by soap_new__ns1__ChangeVirtualInputStateResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__ChangeVirtualInputStateResponse * SOAP_FMAC2 soap_instantiate__ns1__ChangeVirtualInputStateResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:348 */
#ifndef SOAP_TYPE_ns2__Documentation
#define SOAP_TYPE_ns2__Documentation (57)
/* Type ns2__Documentation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns2:Documentation': */
class SOAP_CMAC ns2__Documentation : public soap_dom_element {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM element node graph
        struct soap_dom_element __mixed;
      public:
        /// Return unique type id SOAP_TYPE_ns2__Documentation
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__Documentation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__Documentation, default initialized and not managed by a soap context
        virtual ns2__Documentation *soap_alloc(void) const { return SOAP_NEW(ns2__Documentation); }
      public:
        /// Constructor with initializations
        ns2__Documentation() : __any(), __mixed() { }
        virtual ~ns2__Documentation() { }
        /// Friend allocator used by soap_new_ns2__Documentation(struct soap*, int)
        friend SOAP_FMAC1 ns2__Documentation * SOAP_FMAC2 soap_instantiate_ns2__Documentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:351 */
#ifndef SOAP_TYPE_ns2__ExtensibleDocumented
#define SOAP_TYPE_ns2__ExtensibleDocumented (58)
/* Type ns2__ExtensibleDocumented is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns2:ExtensibleDocumented': */
class SOAP_CMAC ns2__ExtensibleDocumented : public soap_dom_element {
      public:
        /// Optional element 'ns2:documentation' of XSD type 'ns2:Documentation'
        ns2__Documentation *documentation;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ExtensibleDocumented
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__ExtensibleDocumented; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ExtensibleDocumented, default initialized and not managed by a soap context
        virtual ns2__ExtensibleDocumented *soap_alloc(void) const { return SOAP_NEW(ns2__ExtensibleDocumented); }
      public:
        /// Constructor with initializations
        ns2__ExtensibleDocumented() : documentation(), __anyAttribute() { }
        virtual ~ns2__ExtensibleDocumented() { }
        /// Friend allocator used by soap_new_ns2__ExtensibleDocumented(struct soap*, int)
        friend SOAP_FMAC1 ns2__ExtensibleDocumented * SOAP_FMAC2 soap_instantiate_ns2__ExtensibleDocumented(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:354 */
#ifndef SOAP_TYPE_ns2__QueryExpressionType
#define SOAP_TYPE_ns2__QueryExpressionType (59)
/* Type ns2__QueryExpressionType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns2:QueryExpressionType': */
class SOAP_CMAC ns2__QueryExpressionType : public soap_dom_element {
      public:
        /// XML DOM element node graph
        struct soap_dom_element __any;
        /// required attribute 'Dialect' of XSD type 'xsd:anyURI'
        std::string Dialect;
        /// XML DOM element node graph
        struct soap_dom_element __mixed;
      public:
        /// Return unique type id SOAP_TYPE_ns2__QueryExpressionType
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__QueryExpressionType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__QueryExpressionType, default initialized and not managed by a soap context
        virtual ns2__QueryExpressionType *soap_alloc(void) const { return SOAP_NEW(ns2__QueryExpressionType); }
      public:
        /// Constructor with initializations
        ns2__QueryExpressionType() : __any(), Dialect(), __mixed() { }
        virtual ~ns2__QueryExpressionType() { }
        /// Friend allocator used by soap_new_ns2__QueryExpressionType(struct soap*, int)
        friend SOAP_FMAC1 ns2__QueryExpressionType * SOAP_FMAC2 soap_instantiate_ns2__QueryExpressionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:366 */
#ifndef SOAP_TYPE_ns3__QueryExpressionType
#define SOAP_TYPE_ns3__QueryExpressionType (63)
/* Type ns3__QueryExpressionType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns3:QueryExpressionType': */
class SOAP_CMAC ns3__QueryExpressionType : public soap_dom_element {
      public:
        /// XML DOM element node graph
        struct soap_dom_element __any;
        /// required attribute 'Dialect' of XSD type 'xsd:anyURI'
        std::string Dialect;
        /// XML DOM element node graph
        struct soap_dom_element __mixed;
      public:
        /// Return unique type id SOAP_TYPE_ns3__QueryExpressionType
        virtual long soap_type(void) const { return SOAP_TYPE_ns3__QueryExpressionType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__QueryExpressionType, default initialized and not managed by a soap context
        virtual ns3__QueryExpressionType *soap_alloc(void) const { return SOAP_NEW(ns3__QueryExpressionType); }
      public:
        /// Constructor with initializations
        ns3__QueryExpressionType() : __any(), Dialect(), __mixed() { }
        virtual ~ns3__QueryExpressionType() { }
        /// Friend allocator used by soap_new_ns3__QueryExpressionType(struct soap*, int)
        friend SOAP_FMAC1 ns3__QueryExpressionType * SOAP_FMAC2 soap_instantiate_ns3__QueryExpressionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:369 */
#ifndef SOAP_TYPE_ns3__TopicExpressionType
#define SOAP_TYPE_ns3__TopicExpressionType (64)
/* Type ns3__TopicExpressionType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns3:TopicExpressionType': */
class SOAP_CMAC ns3__TopicExpressionType : public soap_dom_element {
      public:
        /// XML DOM element node graph
        struct soap_dom_element __any;
        /// required attribute 'Dialect' of XSD type 'xsd:anyURI'
        std::string Dialect;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// XML DOM element node graph
        struct soap_dom_element __mixed;
      public:
        /// Return unique type id SOAP_TYPE_ns3__TopicExpressionType
        virtual long soap_type(void) const { return SOAP_TYPE_ns3__TopicExpressionType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__TopicExpressionType, default initialized and not managed by a soap context
        virtual ns3__TopicExpressionType *soap_alloc(void) const { return SOAP_NEW(ns3__TopicExpressionType); }
      public:
        /// Constructor with initializations
        ns3__TopicExpressionType() : __any(), Dialect(), __anyAttribute(), __mixed() { }
        virtual ~ns3__TopicExpressionType() { }
        /// Friend allocator used by soap_new_ns3__TopicExpressionType(struct soap*, int)
        friend SOAP_FMAC1 ns3__TopicExpressionType * SOAP_FMAC2 soap_instantiate_ns3__TopicExpressionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:372 */
#ifndef SOAP_TYPE_ns3__FilterType
#define SOAP_TYPE_ns3__FilterType (65)
/* Type ns3__FilterType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns3:FilterType': */
class SOAP_CMAC ns3__FilterType : public soap_dom_element {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
      public:
        /// Return unique type id SOAP_TYPE_ns3__FilterType
        virtual long soap_type(void) const { return SOAP_TYPE_ns3__FilterType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__FilterType, default initialized and not managed by a soap context
        virtual ns3__FilterType *soap_alloc(void) const { return SOAP_NEW(ns3__FilterType); }
      public:
        /// Constructor with initializations
        ns3__FilterType() : __any() { }
        virtual ~ns3__FilterType() { }
        /// Friend allocator used by soap_new_ns3__FilterType(struct soap*, int)
        friend SOAP_FMAC1 ns3__FilterType * SOAP_FMAC2 soap_instantiate_ns3__FilterType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:375 */
#ifndef SOAP_TYPE_ns3__SubscriptionPolicyType
#define SOAP_TYPE_ns3__SubscriptionPolicyType (66)
/* Type ns3__SubscriptionPolicyType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns3:SubscriptionPolicyType': */
class SOAP_CMAC ns3__SubscriptionPolicyType : public soap_dom_element {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
      public:
        /// Return unique type id SOAP_TYPE_ns3__SubscriptionPolicyType
        virtual long soap_type(void) const { return SOAP_TYPE_ns3__SubscriptionPolicyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__SubscriptionPolicyType, default initialized and not managed by a soap context
        virtual ns3__SubscriptionPolicyType *soap_alloc(void) const { return SOAP_NEW(ns3__SubscriptionPolicyType); }
      public:
        /// Constructor with initializations
        ns3__SubscriptionPolicyType() : __any() { }
        virtual ~ns3__SubscriptionPolicyType() { }
        /// Friend allocator used by soap_new_ns3__SubscriptionPolicyType(struct soap*, int)
        friend SOAP_FMAC1 ns3__SubscriptionPolicyType * SOAP_FMAC2 soap_instantiate_ns3__SubscriptionPolicyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:1563 */
#ifndef SOAP_TYPE__ns3__NotificationMessageHolderType_Message
#define SOAP_TYPE__ns3__NotificationMessageHolderType_Message (204)
/* complex XSD type 'ns3:NotificationMessageHolderType-Message': */
class SOAP_CMAC _ns3__NotificationMessageHolderType_Message {
      public:
        /// XML DOM element node graph
        struct soap_dom_element __any;
      public:
        /// Return unique type id SOAP_TYPE__ns3__NotificationMessageHolderType_Message
        virtual long soap_type(void) const { return SOAP_TYPE__ns3__NotificationMessageHolderType_Message; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns3__NotificationMessageHolderType_Message, default initialized and not managed by a soap context
        virtual _ns3__NotificationMessageHolderType_Message *soap_alloc(void) const { return SOAP_NEW(_ns3__NotificationMessageHolderType_Message); }
      public:
        /// Constructor with initializations
        _ns3__NotificationMessageHolderType_Message() : __any() { }
        virtual ~_ns3__NotificationMessageHolderType_Message() { }
        /// Friend allocator used by soap_new__ns3__NotificationMessageHolderType_Message(struct soap*, int)
        friend SOAP_FMAC1 _ns3__NotificationMessageHolderType_Message * SOAP_FMAC2 soap_instantiate__ns3__NotificationMessageHolderType_Message(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:378 */
#ifndef SOAP_TYPE_ns3__NotificationMessageHolderType
#define SOAP_TYPE_ns3__NotificationMessageHolderType (67)
/* Type ns3__NotificationMessageHolderType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns3:NotificationMessageHolderType': */
class SOAP_CMAC ns3__NotificationMessageHolderType : public soap_dom_element {
      public:
        /// Optional element 'ns3:SubscriptionReference' of XSD type 'ns6:EndpointReferenceType'
        ns6__EndpointReferenceType *SubscriptionReference;
        /// Optional element 'ns3:Topic' of XSD type 'ns3:TopicExpressionType'
        ns3__TopicExpressionType *Topic;
        /// Optional element 'ns3:ProducerReference' of XSD type 'ns6:EndpointReferenceType'
        ns6__EndpointReferenceType *ProducerReference;
        /// Required element 'ns3:Message' of XSD type 'ns3:NotificationMessageHolderType-Message'
        _ns3__NotificationMessageHolderType_Message Message;
      public:
        /// Return unique type id SOAP_TYPE_ns3__NotificationMessageHolderType
        virtual long soap_type(void) const { return SOAP_TYPE_ns3__NotificationMessageHolderType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__NotificationMessageHolderType, default initialized and not managed by a soap context
        virtual ns3__NotificationMessageHolderType *soap_alloc(void) const { return SOAP_NEW(ns3__NotificationMessageHolderType); }
      public:
        /// Constructor with initializations
        ns3__NotificationMessageHolderType() : SubscriptionReference(), Topic(), ProducerReference(), Message() { }
        virtual ~ns3__NotificationMessageHolderType() { }
        /// Friend allocator used by soap_new_ns3__NotificationMessageHolderType(struct soap*, int)
        friend SOAP_FMAC1 ns3__NotificationMessageHolderType * SOAP_FMAC2 soap_instantiate_ns3__NotificationMessageHolderType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:441 */
#ifndef SOAP_TYPE__ns3__NotificationProducerRP
#define SOAP_TYPE__ns3__NotificationProducerRP (88)
/* complex XSD type 'ns3:NotificationProducerRP': */
class SOAP_CMAC _ns3__NotificationProducerRP {
      public:
        /// Optional element 'ns3:TopicExpression' of XSD type 'ns3:TopicExpressionType'
        std::vector<ns3__TopicExpressionType *> TopicExpression;
        /// Optional element 'ns3:FixedTopicSet' of XSD type 'xsd:boolean'
        bool *FixedTopicSet;	///< optional with default value = (bool)1
        /// Optional element 'ns3:TopicExpressionDialect' of XSD type 'xsd:anyURI'
        std::vector<std::string> TopicExpressionDialect;
        /// Optional element 'ns2:TopicSet' of XSD type 'ns2:TopicSetType'
        ns2__TopicSetType *ns2__TopicSet;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns3__NotificationProducerRP
        virtual long soap_type(void) const { return SOAP_TYPE__ns3__NotificationProducerRP; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns3__NotificationProducerRP, default initialized and not managed by a soap context
        virtual _ns3__NotificationProducerRP *soap_alloc(void) const { return SOAP_NEW(_ns3__NotificationProducerRP); }
      public:
        /// Constructor with initializations
        _ns3__NotificationProducerRP() : TopicExpression(), FixedTopicSet(), TopicExpressionDialect(), ns2__TopicSet(), soap() { }
        virtual ~_ns3__NotificationProducerRP() { }
        /// Friend allocator used by soap_new__ns3__NotificationProducerRP(struct soap*, int)
        friend SOAP_FMAC1 _ns3__NotificationProducerRP * SOAP_FMAC2 soap_instantiate__ns3__NotificationProducerRP(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:444 */
#ifndef SOAP_TYPE__ns3__SubscriptionManagerRP
#define SOAP_TYPE__ns3__SubscriptionManagerRP (89)
/* complex XSD type 'ns3:SubscriptionManagerRP': */
class SOAP_CMAC _ns3__SubscriptionManagerRP {
      public:
        /// Required element 'ns3:ConsumerReference' of XSD type 'ns6:EndpointReferenceType'
        ns6__EndpointReferenceType *ConsumerReference;
        /// Optional element 'ns3:Filter' of XSD type 'ns3:FilterType'
        ns3__FilterType *Filter;
        /// Optional element 'ns3:SubscriptionPolicy' of XSD type 'ns3:SubscriptionPolicyType'
        ns3__SubscriptionPolicyType *SubscriptionPolicy;
        /// Optional element 'ns3:CreationTime' of XSD type 'xsd:dateTime'
        time_t *CreationTime;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns3__SubscriptionManagerRP
        virtual long soap_type(void) const { return SOAP_TYPE__ns3__SubscriptionManagerRP; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns3__SubscriptionManagerRP, default initialized and not managed by a soap context
        virtual _ns3__SubscriptionManagerRP *soap_alloc(void) const { return SOAP_NEW(_ns3__SubscriptionManagerRP); }
      public:
        /// Constructor with initializations
        _ns3__SubscriptionManagerRP() : ConsumerReference(), Filter(), SubscriptionPolicy(), CreationTime(), soap() { }
        virtual ~_ns3__SubscriptionManagerRP() { }
        /// Friend allocator used by soap_new__ns3__SubscriptionManagerRP(struct soap*, int)
        friend SOAP_FMAC1 _ns3__SubscriptionManagerRP * SOAP_FMAC2 soap_instantiate__ns3__SubscriptionManagerRP(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:447 */
#ifndef SOAP_TYPE__ns3__Notify
#define SOAP_TYPE__ns3__Notify (90)
/* complex XSD type 'ns3:Notify': */
class SOAP_CMAC _ns3__Notify {
      public:
        /// Required element 'ns3:NotificationMessage' of XSD type 'ns3:NotificationMessageHolderType'
        std::vector<ns3__NotificationMessageHolderType *> NotificationMessage;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns3__Notify
        virtual long soap_type(void) const { return SOAP_TYPE__ns3__Notify; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns3__Notify, default initialized and not managed by a soap context
        virtual _ns3__Notify *soap_alloc(void) const { return SOAP_NEW(_ns3__Notify); }
      public:
        /// Constructor with initializations
        _ns3__Notify() : NotificationMessage(), __any(), soap() { }
        virtual ~_ns3__Notify() { }
        /// Friend allocator used by soap_new__ns3__Notify(struct soap*, int)
        friend SOAP_FMAC1 _ns3__Notify * SOAP_FMAC2 soap_instantiate__ns3__Notify(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:450 */
#ifndef SOAP_TYPE__ns3__UseRaw
#define SOAP_TYPE__ns3__UseRaw (91)
/* complex XSD type 'ns3:UseRaw': */
class SOAP_CMAC _ns3__UseRaw {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns3__UseRaw
        virtual long soap_type(void) const { return SOAP_TYPE__ns3__UseRaw; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns3__UseRaw, default initialized and not managed by a soap context
        virtual _ns3__UseRaw *soap_alloc(void) const { return SOAP_NEW(_ns3__UseRaw); }
      public:
        /// Constructor with initializations
        _ns3__UseRaw() : soap() { }
        virtual ~_ns3__UseRaw() { }
        /// Friend allocator used by soap_new__ns3__UseRaw(struct soap*, int)
        friend SOAP_FMAC1 _ns3__UseRaw * SOAP_FMAC2 soap_instantiate__ns3__UseRaw(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:1704 */
#ifndef SOAP_TYPE__ns3__Subscribe_SubscriptionPolicy
#define SOAP_TYPE__ns3__Subscribe_SubscriptionPolicy (214)
/* complex XSD type 'ns3:Subscribe-SubscriptionPolicy': */
class SOAP_CMAC _ns3__Subscribe_SubscriptionPolicy {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
      public:
        /// Return unique type id SOAP_TYPE__ns3__Subscribe_SubscriptionPolicy
        virtual long soap_type(void) const { return SOAP_TYPE__ns3__Subscribe_SubscriptionPolicy; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns3__Subscribe_SubscriptionPolicy, default initialized and not managed by a soap context
        virtual _ns3__Subscribe_SubscriptionPolicy *soap_alloc(void) const { return SOAP_NEW(_ns3__Subscribe_SubscriptionPolicy); }
      public:
        /// Constructor with initializations
        _ns3__Subscribe_SubscriptionPolicy() : __any() { }
        virtual ~_ns3__Subscribe_SubscriptionPolicy() { }
        /// Friend allocator used by soap_new__ns3__Subscribe_SubscriptionPolicy(struct soap*, int)
        friend SOAP_FMAC1 _ns3__Subscribe_SubscriptionPolicy * SOAP_FMAC2 soap_instantiate__ns3__Subscribe_SubscriptionPolicy(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:453 */
#ifndef SOAP_TYPE__ns3__Subscribe
#define SOAP_TYPE__ns3__Subscribe (92)
/* complex XSD type 'ns3:Subscribe': */
class SOAP_CMAC _ns3__Subscribe {
      public:
        /// Required element 'ns3:ConsumerReference' of XSD type 'ns6:EndpointReferenceType'
        ns6__EndpointReferenceType *ConsumerReference;
        /// Optional element 'ns3:Filter' of XSD type 'ns3:FilterType'
        ns3__FilterType *Filter;
        /// Optional element 'ns3:InitialTerminationTime' of XSD type 'ns3:AbsoluteOrRelativeTimeType'
        std::string *InitialTerminationTime;
        /// Optional element 'ns3:SubscriptionPolicy' of XSD type 'ns3:Subscribe-SubscriptionPolicy'
        _ns3__Subscribe_SubscriptionPolicy *SubscriptionPolicy;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns3__Subscribe
        virtual long soap_type(void) const { return SOAP_TYPE__ns3__Subscribe; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns3__Subscribe, default initialized and not managed by a soap context
        virtual _ns3__Subscribe *soap_alloc(void) const { return SOAP_NEW(_ns3__Subscribe); }
      public:
        /// Constructor with initializations
        _ns3__Subscribe() : ConsumerReference(), Filter(), InitialTerminationTime(), SubscriptionPolicy(), __any(), soap() { }
        virtual ~_ns3__Subscribe() { }
        /// Friend allocator used by soap_new__ns3__Subscribe(struct soap*, int)
        friend SOAP_FMAC1 _ns3__Subscribe * SOAP_FMAC2 soap_instantiate__ns3__Subscribe(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:456 */
#ifndef SOAP_TYPE__ns3__SubscribeResponse
#define SOAP_TYPE__ns3__SubscribeResponse (93)
/* complex XSD type 'ns3:SubscribeResponse': */
class SOAP_CMAC _ns3__SubscribeResponse {
      public:
        /// Required element 'ns3:SubscriptionReference' of XSD type 'ns6:EndpointReferenceType'
        ns6__EndpointReferenceType *SubscriptionReference;
        /// Optional element 'ns3:CurrentTime' of XSD type 'xsd:dateTime'
        time_t *CurrentTime;
        /// Optional element 'ns3:TerminationTime' of XSD type 'xsd:dateTime'
        time_t *TerminationTime;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns3__SubscribeResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns3__SubscribeResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns3__SubscribeResponse, default initialized and not managed by a soap context
        virtual _ns3__SubscribeResponse *soap_alloc(void) const { return SOAP_NEW(_ns3__SubscribeResponse); }
      public:
        /// Constructor with initializations
        _ns3__SubscribeResponse() : SubscriptionReference(), CurrentTime(), TerminationTime(), __any(), soap() { }
        virtual ~_ns3__SubscribeResponse() { }
        /// Friend allocator used by soap_new__ns3__SubscribeResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns3__SubscribeResponse * SOAP_FMAC2 soap_instantiate__ns3__SubscribeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:459 */
#ifndef SOAP_TYPE__ns3__GetCurrentMessage
#define SOAP_TYPE__ns3__GetCurrentMessage (94)
/* complex XSD type 'ns3:GetCurrentMessage': */
class SOAP_CMAC _ns3__GetCurrentMessage {
      public:
        /// Required element 'ns3:Topic' of XSD type 'ns3:TopicExpressionType'
        ns3__TopicExpressionType *Topic;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns3__GetCurrentMessage
        virtual long soap_type(void) const { return SOAP_TYPE__ns3__GetCurrentMessage; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns3__GetCurrentMessage, default initialized and not managed by a soap context
        virtual _ns3__GetCurrentMessage *soap_alloc(void) const { return SOAP_NEW(_ns3__GetCurrentMessage); }
      public:
        /// Constructor with initializations
        _ns3__GetCurrentMessage() : Topic(), __any(), soap() { }
        virtual ~_ns3__GetCurrentMessage() { }
        /// Friend allocator used by soap_new__ns3__GetCurrentMessage(struct soap*, int)
        friend SOAP_FMAC1 _ns3__GetCurrentMessage * SOAP_FMAC2 soap_instantiate__ns3__GetCurrentMessage(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:462 */
#ifndef SOAP_TYPE__ns3__GetCurrentMessageResponse
#define SOAP_TYPE__ns3__GetCurrentMessageResponse (95)
/* complex XSD type 'ns3:GetCurrentMessageResponse': */
class SOAP_CMAC _ns3__GetCurrentMessageResponse {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns3__GetCurrentMessageResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns3__GetCurrentMessageResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns3__GetCurrentMessageResponse, default initialized and not managed by a soap context
        virtual _ns3__GetCurrentMessageResponse *soap_alloc(void) const { return SOAP_NEW(_ns3__GetCurrentMessageResponse); }
      public:
        /// Constructor with initializations
        _ns3__GetCurrentMessageResponse() : __any(), soap() { }
        virtual ~_ns3__GetCurrentMessageResponse() { }
        /// Friend allocator used by soap_new__ns3__GetCurrentMessageResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns3__GetCurrentMessageResponse * SOAP_FMAC2 soap_instantiate__ns3__GetCurrentMessageResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:465 */
#ifndef SOAP_TYPE__ns3__GetMessages
#define SOAP_TYPE__ns3__GetMessages (96)
/* complex XSD type 'ns3:GetMessages': */
class SOAP_CMAC _ns3__GetMessages {
      public:
        /// Optional element 'ns3:MaximumNumber' of XSD type 'xsd:nonNegativeInteger'
        std::string *MaximumNumber;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns3__GetMessages
        virtual long soap_type(void) const { return SOAP_TYPE__ns3__GetMessages; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns3__GetMessages, default initialized and not managed by a soap context
        virtual _ns3__GetMessages *soap_alloc(void) const { return SOAP_NEW(_ns3__GetMessages); }
      public:
        /// Constructor with initializations
        _ns3__GetMessages() : MaximumNumber(), __any(), __anyAttribute(), soap() { }
        virtual ~_ns3__GetMessages() { }
        /// Friend allocator used by soap_new__ns3__GetMessages(struct soap*, int)
        friend SOAP_FMAC1 _ns3__GetMessages * SOAP_FMAC2 soap_instantiate__ns3__GetMessages(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:468 */
#ifndef SOAP_TYPE__ns3__GetMessagesResponse
#define SOAP_TYPE__ns3__GetMessagesResponse (97)
/* complex XSD type 'ns3:GetMessagesResponse': */
class SOAP_CMAC _ns3__GetMessagesResponse {
      public:
        /// Optional element 'ns3:NotificationMessage' of XSD type 'ns3:NotificationMessageHolderType'
        std::vector<ns3__NotificationMessageHolderType *> NotificationMessage;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns3__GetMessagesResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns3__GetMessagesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns3__GetMessagesResponse, default initialized and not managed by a soap context
        virtual _ns3__GetMessagesResponse *soap_alloc(void) const { return SOAP_NEW(_ns3__GetMessagesResponse); }
      public:
        /// Constructor with initializations
        _ns3__GetMessagesResponse() : NotificationMessage(), __any(), __anyAttribute(), soap() { }
        virtual ~_ns3__GetMessagesResponse() { }
        /// Friend allocator used by soap_new__ns3__GetMessagesResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns3__GetMessagesResponse * SOAP_FMAC2 soap_instantiate__ns3__GetMessagesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:471 */
#ifndef SOAP_TYPE__ns3__DestroyPullPoint
#define SOAP_TYPE__ns3__DestroyPullPoint (98)
/* complex XSD type 'ns3:DestroyPullPoint': */
class SOAP_CMAC _ns3__DestroyPullPoint {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns3__DestroyPullPoint
        virtual long soap_type(void) const { return SOAP_TYPE__ns3__DestroyPullPoint; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns3__DestroyPullPoint, default initialized and not managed by a soap context
        virtual _ns3__DestroyPullPoint *soap_alloc(void) const { return SOAP_NEW(_ns3__DestroyPullPoint); }
      public:
        /// Constructor with initializations
        _ns3__DestroyPullPoint() : __any(), __anyAttribute(), soap() { }
        virtual ~_ns3__DestroyPullPoint() { }
        /// Friend allocator used by soap_new__ns3__DestroyPullPoint(struct soap*, int)
        friend SOAP_FMAC1 _ns3__DestroyPullPoint * SOAP_FMAC2 soap_instantiate__ns3__DestroyPullPoint(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:474 */
#ifndef SOAP_TYPE__ns3__DestroyPullPointResponse
#define SOAP_TYPE__ns3__DestroyPullPointResponse (99)
/* complex XSD type 'ns3:DestroyPullPointResponse': */
class SOAP_CMAC _ns3__DestroyPullPointResponse {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns3__DestroyPullPointResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns3__DestroyPullPointResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns3__DestroyPullPointResponse, default initialized and not managed by a soap context
        virtual _ns3__DestroyPullPointResponse *soap_alloc(void) const { return SOAP_NEW(_ns3__DestroyPullPointResponse); }
      public:
        /// Constructor with initializations
        _ns3__DestroyPullPointResponse() : __any(), __anyAttribute(), soap() { }
        virtual ~_ns3__DestroyPullPointResponse() { }
        /// Friend allocator used by soap_new__ns3__DestroyPullPointResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns3__DestroyPullPointResponse * SOAP_FMAC2 soap_instantiate__ns3__DestroyPullPointResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:477 */
#ifndef SOAP_TYPE__ns3__CreatePullPoint
#define SOAP_TYPE__ns3__CreatePullPoint (100)
/* complex XSD type 'ns3:CreatePullPoint': */
class SOAP_CMAC _ns3__CreatePullPoint {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns3__CreatePullPoint
        virtual long soap_type(void) const { return SOAP_TYPE__ns3__CreatePullPoint; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns3__CreatePullPoint, default initialized and not managed by a soap context
        virtual _ns3__CreatePullPoint *soap_alloc(void) const { return SOAP_NEW(_ns3__CreatePullPoint); }
      public:
        /// Constructor with initializations
        _ns3__CreatePullPoint() : __any(), __anyAttribute(), soap() { }
        virtual ~_ns3__CreatePullPoint() { }
        /// Friend allocator used by soap_new__ns3__CreatePullPoint(struct soap*, int)
        friend SOAP_FMAC1 _ns3__CreatePullPoint * SOAP_FMAC2 soap_instantiate__ns3__CreatePullPoint(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:480 */
#ifndef SOAP_TYPE__ns3__CreatePullPointResponse
#define SOAP_TYPE__ns3__CreatePullPointResponse (101)
/* complex XSD type 'ns3:CreatePullPointResponse': */
class SOAP_CMAC _ns3__CreatePullPointResponse {
      public:
        /// Required element 'ns3:PullPoint' of XSD type 'ns6:EndpointReferenceType'
        ns6__EndpointReferenceType *PullPoint;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns3__CreatePullPointResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns3__CreatePullPointResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns3__CreatePullPointResponse, default initialized and not managed by a soap context
        virtual _ns3__CreatePullPointResponse *soap_alloc(void) const { return SOAP_NEW(_ns3__CreatePullPointResponse); }
      public:
        /// Constructor with initializations
        _ns3__CreatePullPointResponse() : PullPoint(), __any(), __anyAttribute(), soap() { }
        virtual ~_ns3__CreatePullPointResponse() { }
        /// Friend allocator used by soap_new__ns3__CreatePullPointResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns3__CreatePullPointResponse * SOAP_FMAC2 soap_instantiate__ns3__CreatePullPointResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:483 */
#ifndef SOAP_TYPE__ns3__Renew
#define SOAP_TYPE__ns3__Renew (102)
/* complex XSD type 'ns3:Renew': */
class SOAP_CMAC _ns3__Renew {
      public:
        /// Required nillable (xsi:nil when NULL) element 'ns3:TerminationTime' of XSD type 'ns3:AbsoluteOrRelativeTimeType'
        std::string *TerminationTime;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns3__Renew
        virtual long soap_type(void) const { return SOAP_TYPE__ns3__Renew; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns3__Renew, default initialized and not managed by a soap context
        virtual _ns3__Renew *soap_alloc(void) const { return SOAP_NEW(_ns3__Renew); }
      public:
        /// Constructor with initializations
        _ns3__Renew() : TerminationTime(), __any(), soap() { }
        virtual ~_ns3__Renew() { }
        /// Friend allocator used by soap_new__ns3__Renew(struct soap*, int)
        friend SOAP_FMAC1 _ns3__Renew * SOAP_FMAC2 soap_instantiate__ns3__Renew(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:486 */
#ifndef SOAP_TYPE__ns3__RenewResponse
#define SOAP_TYPE__ns3__RenewResponse (103)
/* complex XSD type 'ns3:RenewResponse': */
class SOAP_CMAC _ns3__RenewResponse {
      public:
        /// Required element 'ns3:TerminationTime' of XSD type 'xsd:dateTime'
        time_t TerminationTime;
        /// Optional element 'ns3:CurrentTime' of XSD type 'xsd:dateTime'
        time_t *CurrentTime;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns3__RenewResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns3__RenewResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns3__RenewResponse, default initialized and not managed by a soap context
        virtual _ns3__RenewResponse *soap_alloc(void) const { return SOAP_NEW(_ns3__RenewResponse); }
      public:
        /// Constructor with initializations
        _ns3__RenewResponse() : TerminationTime(), CurrentTime(), __any(), soap() { }
        virtual ~_ns3__RenewResponse() { }
        /// Friend allocator used by soap_new__ns3__RenewResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns3__RenewResponse * SOAP_FMAC2 soap_instantiate__ns3__RenewResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:489 */
#ifndef SOAP_TYPE__ns3__Unsubscribe
#define SOAP_TYPE__ns3__Unsubscribe (104)
/* complex XSD type 'ns3:Unsubscribe': */
class SOAP_CMAC _ns3__Unsubscribe {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns3__Unsubscribe
        virtual long soap_type(void) const { return SOAP_TYPE__ns3__Unsubscribe; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns3__Unsubscribe, default initialized and not managed by a soap context
        virtual _ns3__Unsubscribe *soap_alloc(void) const { return SOAP_NEW(_ns3__Unsubscribe); }
      public:
        /// Constructor with initializations
        _ns3__Unsubscribe() : __any(), soap() { }
        virtual ~_ns3__Unsubscribe() { }
        /// Friend allocator used by soap_new__ns3__Unsubscribe(struct soap*, int)
        friend SOAP_FMAC1 _ns3__Unsubscribe * SOAP_FMAC2 soap_instantiate__ns3__Unsubscribe(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:492 */
#ifndef SOAP_TYPE__ns3__UnsubscribeResponse
#define SOAP_TYPE__ns3__UnsubscribeResponse (105)
/* complex XSD type 'ns3:UnsubscribeResponse': */
class SOAP_CMAC _ns3__UnsubscribeResponse {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns3__UnsubscribeResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns3__UnsubscribeResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns3__UnsubscribeResponse, default initialized and not managed by a soap context
        virtual _ns3__UnsubscribeResponse *soap_alloc(void) const { return SOAP_NEW(_ns3__UnsubscribeResponse); }
      public:
        /// Constructor with initializations
        _ns3__UnsubscribeResponse() : __any(), soap() { }
        virtual ~_ns3__UnsubscribeResponse() { }
        /// Friend allocator used by soap_new__ns3__UnsubscribeResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns3__UnsubscribeResponse * SOAP_FMAC2 soap_instantiate__ns3__UnsubscribeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:495 */
#ifndef SOAP_TYPE__ns3__PauseSubscription
#define SOAP_TYPE__ns3__PauseSubscription (106)
/* complex XSD type 'ns3:PauseSubscription': */
class SOAP_CMAC _ns3__PauseSubscription {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns3__PauseSubscription
        virtual long soap_type(void) const { return SOAP_TYPE__ns3__PauseSubscription; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns3__PauseSubscription, default initialized and not managed by a soap context
        virtual _ns3__PauseSubscription *soap_alloc(void) const { return SOAP_NEW(_ns3__PauseSubscription); }
      public:
        /// Constructor with initializations
        _ns3__PauseSubscription() : __any(), soap() { }
        virtual ~_ns3__PauseSubscription() { }
        /// Friend allocator used by soap_new__ns3__PauseSubscription(struct soap*, int)
        friend SOAP_FMAC1 _ns3__PauseSubscription * SOAP_FMAC2 soap_instantiate__ns3__PauseSubscription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:498 */
#ifndef SOAP_TYPE__ns3__PauseSubscriptionResponse
#define SOAP_TYPE__ns3__PauseSubscriptionResponse (107)
/* complex XSD type 'ns3:PauseSubscriptionResponse': */
class SOAP_CMAC _ns3__PauseSubscriptionResponse {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns3__PauseSubscriptionResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns3__PauseSubscriptionResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns3__PauseSubscriptionResponse, default initialized and not managed by a soap context
        virtual _ns3__PauseSubscriptionResponse *soap_alloc(void) const { return SOAP_NEW(_ns3__PauseSubscriptionResponse); }
      public:
        /// Constructor with initializations
        _ns3__PauseSubscriptionResponse() : __any(), soap() { }
        virtual ~_ns3__PauseSubscriptionResponse() { }
        /// Friend allocator used by soap_new__ns3__PauseSubscriptionResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns3__PauseSubscriptionResponse * SOAP_FMAC2 soap_instantiate__ns3__PauseSubscriptionResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:501 */
#ifndef SOAP_TYPE__ns3__ResumeSubscription
#define SOAP_TYPE__ns3__ResumeSubscription (108)
/* complex XSD type 'ns3:ResumeSubscription': */
class SOAP_CMAC _ns3__ResumeSubscription {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns3__ResumeSubscription
        virtual long soap_type(void) const { return SOAP_TYPE__ns3__ResumeSubscription; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns3__ResumeSubscription, default initialized and not managed by a soap context
        virtual _ns3__ResumeSubscription *soap_alloc(void) const { return SOAP_NEW(_ns3__ResumeSubscription); }
      public:
        /// Constructor with initializations
        _ns3__ResumeSubscription() : __any(), soap() { }
        virtual ~_ns3__ResumeSubscription() { }
        /// Friend allocator used by soap_new__ns3__ResumeSubscription(struct soap*, int)
        friend SOAP_FMAC1 _ns3__ResumeSubscription * SOAP_FMAC2 soap_instantiate__ns3__ResumeSubscription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:504 */
#ifndef SOAP_TYPE__ns3__ResumeSubscriptionResponse
#define SOAP_TYPE__ns3__ResumeSubscriptionResponse (109)
/* complex XSD type 'ns3:ResumeSubscriptionResponse': */
class SOAP_CMAC _ns3__ResumeSubscriptionResponse {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns3__ResumeSubscriptionResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns3__ResumeSubscriptionResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns3__ResumeSubscriptionResponse, default initialized and not managed by a soap context
        virtual _ns3__ResumeSubscriptionResponse *soap_alloc(void) const { return SOAP_NEW(_ns3__ResumeSubscriptionResponse); }
      public:
        /// Constructor with initializations
        _ns3__ResumeSubscriptionResponse() : __any(), soap() { }
        virtual ~_ns3__ResumeSubscriptionResponse() { }
        /// Friend allocator used by soap_new__ns3__ResumeSubscriptionResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns3__ResumeSubscriptionResponse * SOAP_FMAC2 soap_instantiate__ns3__ResumeSubscriptionResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:2268 */
#ifndef SOAP_TYPE__ns4__BaseFaultType_ErrorCode
#define SOAP_TYPE__ns4__BaseFaultType_ErrorCode (217)
/* complex XSD type 'ns4:BaseFaultType-ErrorCode': */
class SOAP_CMAC _ns4__BaseFaultType_ErrorCode {
      public:
        /// required attribute 'dialect' of XSD type 'xsd:anyURI'
        std::string dialect;
        /// XML DOM element node graph
        struct soap_dom_element __mixed;
      public:
        /// Return unique type id SOAP_TYPE__ns4__BaseFaultType_ErrorCode
        virtual long soap_type(void) const { return SOAP_TYPE__ns4__BaseFaultType_ErrorCode; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns4__BaseFaultType_ErrorCode, default initialized and not managed by a soap context
        virtual _ns4__BaseFaultType_ErrorCode *soap_alloc(void) const { return SOAP_NEW(_ns4__BaseFaultType_ErrorCode); }
      public:
        /// Constructor with initializations
        _ns4__BaseFaultType_ErrorCode() : dialect(), __mixed() { }
        virtual ~_ns4__BaseFaultType_ErrorCode() { }
        /// Friend allocator used by soap_new__ns4__BaseFaultType_ErrorCode(struct soap*, int)
        friend SOAP_FMAC1 _ns4__BaseFaultType_ErrorCode * SOAP_FMAC2 soap_instantiate__ns4__BaseFaultType_ErrorCode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:2289 */
#ifndef SOAP_TYPE__ns4__BaseFaultType_Description
#define SOAP_TYPE__ns4__BaseFaultType_Description (219)
/* simple XSD type 'ns4:BaseFaultType-Description': */
class SOAP_CMAC _ns4__BaseFaultType_Description {
      public:
        /// Simple content of XSD type 'xsd:string' wrapped by this struct
        std::string __item;
        /// optional attribute 'xml:lang' of XSD type 'xml:lang'
        std::string *xml__lang;
      public:
        /// Return unique type id SOAP_TYPE__ns4__BaseFaultType_Description
        virtual long soap_type(void) const { return SOAP_TYPE__ns4__BaseFaultType_Description; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns4__BaseFaultType_Description, default initialized and not managed by a soap context
        virtual _ns4__BaseFaultType_Description *soap_alloc(void) const { return SOAP_NEW(_ns4__BaseFaultType_Description); }
      public:
        /// Constructor with initializations
        _ns4__BaseFaultType_Description() : __item(), xml__lang() { }
        virtual ~_ns4__BaseFaultType_Description() { }
        /// Friend allocator used by soap_new__ns4__BaseFaultType_Description(struct soap*, int)
        friend SOAP_FMAC1 _ns4__BaseFaultType_Description * SOAP_FMAC2 soap_instantiate__ns4__BaseFaultType_Description(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:2306 */
#ifndef SOAP_TYPE__ns4__BaseFaultType_FaultCause
#define SOAP_TYPE__ns4__BaseFaultType_FaultCause (222)
/* complex XSD type 'ns4:BaseFaultType-FaultCause': */
class SOAP_CMAC _ns4__BaseFaultType_FaultCause {
      public:
        /// XML DOM element node graph
        struct soap_dom_element __any;
      public:
        /// Return unique type id SOAP_TYPE__ns4__BaseFaultType_FaultCause
        virtual long soap_type(void) const { return SOAP_TYPE__ns4__BaseFaultType_FaultCause; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns4__BaseFaultType_FaultCause, default initialized and not managed by a soap context
        virtual _ns4__BaseFaultType_FaultCause *soap_alloc(void) const { return SOAP_NEW(_ns4__BaseFaultType_FaultCause); }
      public:
        /// Constructor with initializations
        _ns4__BaseFaultType_FaultCause() : __any() { }
        virtual ~_ns4__BaseFaultType_FaultCause() { }
        /// Friend allocator used by soap_new__ns4__BaseFaultType_FaultCause(struct soap*, int)
        friend SOAP_FMAC1 _ns4__BaseFaultType_FaultCause * SOAP_FMAC2 soap_instantiate__ns4__BaseFaultType_FaultCause(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:507 */
#ifndef SOAP_TYPE_ns4__BaseFaultType
#define SOAP_TYPE_ns4__BaseFaultType (110)
/* Type ns4__BaseFaultType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns4:BaseFaultType': */
class SOAP_CMAC ns4__BaseFaultType : public soap_dom_element {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Required element 'ns4:Timestamp' of XSD type 'xsd:dateTime'
        time_t Timestamp;
        /// Optional element 'ns4:Originator' of XSD type 'ns6:EndpointReferenceType'
        ns6__EndpointReferenceType *Originator;
        /// Optional element 'ns4:ErrorCode' of XSD type 'ns4:BaseFaultType-ErrorCode'
        _ns4__BaseFaultType_ErrorCode *ErrorCode;
        /// Optional element 'ns4:Description' of XSD type 'ns4:BaseFaultType-Description'
        std::vector<_ns4__BaseFaultType_Description> Description;
        /// Optional element 'ns4:FaultCause' of XSD type 'ns4:BaseFaultType-FaultCause'
        _ns4__BaseFaultType_FaultCause *FaultCause;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_ns4__BaseFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_ns4__BaseFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns4__BaseFaultType, default initialized and not managed by a soap context
        virtual ns4__BaseFaultType *soap_alloc(void) const { return SOAP_NEW(ns4__BaseFaultType); }
      public:
        /// Constructor with initializations
        ns4__BaseFaultType() : __any(), Timestamp(), Originator(), ErrorCode(), Description(), FaultCause(), __anyAttribute() { }
        virtual ~ns4__BaseFaultType() { }
        /// Friend allocator used by soap_new_ns4__BaseFaultType(struct soap*, int)
        friend SOAP_FMAC1 ns4__BaseFaultType * SOAP_FMAC2 soap_instantiate_ns4__BaseFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:510 */
#ifndef SOAP_TYPE_ns5__NewActionRule
#define SOAP_TYPE_ns5__NewActionRule (111)
/* Type ns5__NewActionRule is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns5:NewActionRule': */
class SOAP_CMAC ns5__NewActionRule : public soap_dom_element {
      public:
        /// Optional element 'ns5:Name' of XSD type 'xsd:string'
        std::string *Name;
        /// Required element 'ns5:Enabled' of XSD type 'xsd:boolean'
        bool Enabled;
        /// Optional element 'ns5:StartEvent' of XSD type 'ns3:FilterType'
        ns3__FilterType *StartEvent;
        /// Optional element 'ns5:Conditions' of XSD type 'ns5:Conditions'
        ns5__Conditions *Conditions;
        /// Optional element 'ns5:ActivationTimeout' of XSD type 'xsd:duration'
        std::string *ActivationTimeout;
        /// Required element 'ns5:PrimaryAction' of XSD type 'xsd:integer'
        std::string PrimaryAction;
        /// Optional element 'ns5:FailoverAction' of XSD type 'xsd:integer'
        std::string *FailoverAction;
      public:
        /// Return unique type id SOAP_TYPE_ns5__NewActionRule
        virtual long soap_type(void) const { return SOAP_TYPE_ns5__NewActionRule; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns5__NewActionRule, default initialized and not managed by a soap context
        virtual ns5__NewActionRule *soap_alloc(void) const { return SOAP_NEW(ns5__NewActionRule); }
      public:
        /// Constructor with initializations
        ns5__NewActionRule() : Name(), Enabled(), StartEvent(), Conditions(), ActivationTimeout(), PrimaryAction(), FailoverAction() { }
        virtual ~ns5__NewActionRule() { }
        /// Friend allocator used by soap_new_ns5__NewActionRule(struct soap*, int)
        friend SOAP_FMAC1 ns5__NewActionRule * SOAP_FMAC2 soap_instantiate_ns5__NewActionRule(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:513 */
#ifndef SOAP_TYPE_ns5__Conditions
#define SOAP_TYPE_ns5__Conditions (112)
/* Type ns5__Conditions is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns5:Conditions': */
class SOAP_CMAC ns5__Conditions : public soap_dom_element {
      public:
        /// Required element 'ns5:Condition' of XSD type 'ns3:FilterType'
        std::vector<ns3__FilterType *> Condition;
      public:
        /// Return unique type id SOAP_TYPE_ns5__Conditions
        virtual long soap_type(void) const { return SOAP_TYPE_ns5__Conditions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns5__Conditions, default initialized and not managed by a soap context
        virtual ns5__Conditions *soap_alloc(void) const { return SOAP_NEW(ns5__Conditions); }
      public:
        /// Constructor with initializations
        ns5__Conditions() : Condition() { }
        virtual ~ns5__Conditions() { }
        /// Friend allocator used by soap_new_ns5__Conditions(struct soap*, int)
        friend SOAP_FMAC1 ns5__Conditions * SOAP_FMAC2 soap_instantiate_ns5__Conditions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:516 */
#ifndef SOAP_TYPE_ns5__ActionRules
#define SOAP_TYPE_ns5__ActionRules (113)
/* Type ns5__ActionRules is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns5:ActionRules': */
class SOAP_CMAC ns5__ActionRules : public soap_dom_element {
      public:
        /// Optional element 'ns5:ActionRule' of XSD type 'ns5:ActionRule'
        std::vector<ns5__ActionRule *> ActionRule;
      public:
        /// Return unique type id SOAP_TYPE_ns5__ActionRules
        virtual long soap_type(void) const { return SOAP_TYPE_ns5__ActionRules; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns5__ActionRules, default initialized and not managed by a soap context
        virtual ns5__ActionRules *soap_alloc(void) const { return SOAP_NEW(ns5__ActionRules); }
      public:
        /// Constructor with initializations
        ns5__ActionRules() : ActionRule() { }
        virtual ~ns5__ActionRules() { }
        /// Friend allocator used by soap_new_ns5__ActionRules(struct soap*, int)
        friend SOAP_FMAC1 ns5__ActionRules * SOAP_FMAC2 soap_instantiate_ns5__ActionRules(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:519 */
#ifndef SOAP_TYPE_ns5__ActionRule
#define SOAP_TYPE_ns5__ActionRule (114)
/* Type ns5__ActionRule is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns5:ActionRule': */
class SOAP_CMAC ns5__ActionRule : public soap_dom_element {
      public:
        /// Required element 'ns5:RuleID' of XSD type 'xsd:integer'
        std::string RuleID;
        /// Optional element 'ns5:Name' of XSD type 'xsd:string'
        std::string *Name;
        /// Required element 'ns5:Enabled' of XSD type 'xsd:boolean'
        bool Enabled;
        /// Optional element 'ns5:StartEvent' of XSD type 'ns3:FilterType'
        ns3__FilterType *StartEvent;
        /// Optional element 'ns5:Conditions' of XSD type 'ns5:Conditions'
        ns5__Conditions *Conditions;
        /// Optional element 'ns5:ActivationTimeout' of XSD type 'xsd:duration'
        std::string *ActivationTimeout;
        /// Required element 'ns5:PrimaryAction' of XSD type 'xsd:integer'
        std::string PrimaryAction;
        /// Optional element 'ns5:FailoverAction' of XSD type 'xsd:integer'
        std::string *FailoverAction;
      public:
        /// Return unique type id SOAP_TYPE_ns5__ActionRule
        virtual long soap_type(void) const { return SOAP_TYPE_ns5__ActionRule; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns5__ActionRule, default initialized and not managed by a soap context
        virtual ns5__ActionRule *soap_alloc(void) const { return SOAP_NEW(ns5__ActionRule); }
      public:
        /// Constructor with initializations
        ns5__ActionRule() : RuleID(), Name(), Enabled(), StartEvent(), Conditions(), ActivationTimeout(), PrimaryAction(), FailoverAction() { }
        virtual ~ns5__ActionRule() { }
        /// Friend allocator used by soap_new_ns5__ActionRule(struct soap*, int)
        friend SOAP_FMAC1 ns5__ActionRule * SOAP_FMAC2 soap_instantiate_ns5__ActionRule(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:522 */
#ifndef SOAP_TYPE_ns5__NewRecipientConfiguration
#define SOAP_TYPE_ns5__NewRecipientConfiguration (115)
/* Type ns5__NewRecipientConfiguration is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns5:NewRecipientConfiguration': */
class SOAP_CMAC ns5__NewRecipientConfiguration : public soap_dom_element {
      public:
        /// Optional element 'ns5:Name' of XSD type 'xsd:string'
        std::string *Name;
        /// Required element 'ns5:TemplateToken' of XSD type 'xsd:string'
        std::string TemplateToken;
        /// Optional element 'ns5:Parameters' of XSD type 'ns5:ActionParameters'
        ns5__ActionParameters *Parameters;
      public:
        /// Return unique type id SOAP_TYPE_ns5__NewRecipientConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE_ns5__NewRecipientConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns5__NewRecipientConfiguration, default initialized and not managed by a soap context
        virtual ns5__NewRecipientConfiguration *soap_alloc(void) const { return SOAP_NEW(ns5__NewRecipientConfiguration); }
      public:
        /// Constructor with initializations
        ns5__NewRecipientConfiguration() : Name(), TemplateToken(), Parameters() { }
        virtual ~ns5__NewRecipientConfiguration() { }
        /// Friend allocator used by soap_new_ns5__NewRecipientConfiguration(struct soap*, int)
        friend SOAP_FMAC1 ns5__NewRecipientConfiguration * SOAP_FMAC2 soap_instantiate_ns5__NewRecipientConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:525 */
#ifndef SOAP_TYPE_ns5__RecipientConfiguration
#define SOAP_TYPE_ns5__RecipientConfiguration (116)
/* Type ns5__RecipientConfiguration is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns5:RecipientConfiguration': */
class SOAP_CMAC ns5__RecipientConfiguration : public soap_dom_element {
      public:
        /// Required element 'ns5:ConfigurationID' of XSD type 'xsd:integer'
        std::string ConfigurationID;
        /// Required element 'ns5:TemplateToken' of XSD type 'xsd:string'
        std::string TemplateToken;
        /// Optional element 'ns5:Name' of XSD type 'xsd:string'
        std::string *Name;
        /// Optional element 'ns5:Parameters' of XSD type 'ns5:ActionParameters'
        ns5__ActionParameters *Parameters;
      public:
        /// Return unique type id SOAP_TYPE_ns5__RecipientConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE_ns5__RecipientConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns5__RecipientConfiguration, default initialized and not managed by a soap context
        virtual ns5__RecipientConfiguration *soap_alloc(void) const { return SOAP_NEW(ns5__RecipientConfiguration); }
      public:
        /// Constructor with initializations
        ns5__RecipientConfiguration() : ConfigurationID(), TemplateToken(), Name(), Parameters() { }
        virtual ~ns5__RecipientConfiguration() { }
        /// Friend allocator used by soap_new_ns5__RecipientConfiguration(struct soap*, int)
        friend SOAP_FMAC1 ns5__RecipientConfiguration * SOAP_FMAC2 soap_instantiate_ns5__RecipientConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:528 */
#ifndef SOAP_TYPE_ns5__RecipientConfigurations
#define SOAP_TYPE_ns5__RecipientConfigurations (117)
/* Type ns5__RecipientConfigurations is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns5:RecipientConfigurations': */
class SOAP_CMAC ns5__RecipientConfigurations : public soap_dom_element {
      public:
        /// Optional element 'ns5:RecipientConfiguration' of XSD type 'ns5:RecipientConfiguration'
        std::vector<ns5__RecipientConfiguration *> RecipientConfiguration;
      public:
        /// Return unique type id SOAP_TYPE_ns5__RecipientConfigurations
        virtual long soap_type(void) const { return SOAP_TYPE_ns5__RecipientConfigurations; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns5__RecipientConfigurations, default initialized and not managed by a soap context
        virtual ns5__RecipientConfigurations *soap_alloc(void) const { return SOAP_NEW(ns5__RecipientConfigurations); }
      public:
        /// Constructor with initializations
        ns5__RecipientConfigurations() : RecipientConfiguration() { }
        virtual ~ns5__RecipientConfigurations() { }
        /// Friend allocator used by soap_new_ns5__RecipientConfigurations(struct soap*, int)
        friend SOAP_FMAC1 ns5__RecipientConfigurations * SOAP_FMAC2 soap_instantiate_ns5__RecipientConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:531 */
#ifndef SOAP_TYPE_ns5__RecipientTemplates
#define SOAP_TYPE_ns5__RecipientTemplates (118)
/* Type ns5__RecipientTemplates is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns5:RecipientTemplates': */
class SOAP_CMAC ns5__RecipientTemplates : public soap_dom_element {
      public:
        /// Optional element 'ns5:RecipientTemplate' of XSD type 'ns5:RecipientTemplate'
        std::vector<ns5__RecipientTemplate *> RecipientTemplate;
      public:
        /// Return unique type id SOAP_TYPE_ns5__RecipientTemplates
        virtual long soap_type(void) const { return SOAP_TYPE_ns5__RecipientTemplates; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns5__RecipientTemplates, default initialized and not managed by a soap context
        virtual ns5__RecipientTemplates *soap_alloc(void) const { return SOAP_NEW(ns5__RecipientTemplates); }
      public:
        /// Constructor with initializations
        ns5__RecipientTemplates() : RecipientTemplate() { }
        virtual ~ns5__RecipientTemplates() { }
        /// Friend allocator used by soap_new_ns5__RecipientTemplates(struct soap*, int)
        friend SOAP_FMAC1 ns5__RecipientTemplates * SOAP_FMAC2 soap_instantiate_ns5__RecipientTemplates(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:534 */
#ifndef SOAP_TYPE_ns5__RecipientTemplate
#define SOAP_TYPE_ns5__RecipientTemplate (119)
/* Type ns5__RecipientTemplate is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns5:RecipientTemplate': */
class SOAP_CMAC ns5__RecipientTemplate : public soap_dom_element {
      public:
        /// Required element 'ns5:TemplateToken' of XSD type 'xsd:string'
        std::string TemplateToken;
        /// Optional element 'ns5:Parameters' of XSD type 'ns5:ActionTemplateParameters'
        ns5__ActionTemplateParameters *Parameters;
      public:
        /// Return unique type id SOAP_TYPE_ns5__RecipientTemplate
        virtual long soap_type(void) const { return SOAP_TYPE_ns5__RecipientTemplate; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns5__RecipientTemplate, default initialized and not managed by a soap context
        virtual ns5__RecipientTemplate *soap_alloc(void) const { return SOAP_NEW(ns5__RecipientTemplate); }
      public:
        /// Constructor with initializations
        ns5__RecipientTemplate() : TemplateToken(), Parameters() { }
        virtual ~ns5__RecipientTemplate() { }
        /// Friend allocator used by soap_new_ns5__RecipientTemplate(struct soap*, int)
        friend SOAP_FMAC1 ns5__RecipientTemplate * SOAP_FMAC2 soap_instantiate_ns5__RecipientTemplate(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:537 */
#ifndef SOAP_TYPE_ns5__ActionConfigurations
#define SOAP_TYPE_ns5__ActionConfigurations (120)
/* Type ns5__ActionConfigurations is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns5:ActionConfigurations': */
class SOAP_CMAC ns5__ActionConfigurations : public soap_dom_element {
      public:
        /// Optional element 'ns5:ActionConfiguration' of XSD type 'ns5:ActionConfiguration'
        std::vector<ns5__ActionConfiguration *> ActionConfiguration;
      public:
        /// Return unique type id SOAP_TYPE_ns5__ActionConfigurations
        virtual long soap_type(void) const { return SOAP_TYPE_ns5__ActionConfigurations; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns5__ActionConfigurations, default initialized and not managed by a soap context
        virtual ns5__ActionConfigurations *soap_alloc(void) const { return SOAP_NEW(ns5__ActionConfigurations); }
      public:
        /// Constructor with initializations
        ns5__ActionConfigurations() : ActionConfiguration() { }
        virtual ~ns5__ActionConfigurations() { }
        /// Friend allocator used by soap_new_ns5__ActionConfigurations(struct soap*, int)
        friend SOAP_FMAC1 ns5__ActionConfigurations * SOAP_FMAC2 soap_instantiate_ns5__ActionConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:540 */
#ifndef SOAP_TYPE_ns5__NewActionConfiguration
#define SOAP_TYPE_ns5__NewActionConfiguration (121)
/* Type ns5__NewActionConfiguration is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns5:NewActionConfiguration': */
class SOAP_CMAC ns5__NewActionConfiguration : public soap_dom_element {
      public:
        /// Optional element 'ns5:Name' of XSD type 'xsd:string'
        std::string *Name;
        /// Required element 'ns5:TemplateToken' of XSD type 'xsd:string'
        std::string TemplateToken;
        /// Optional element 'ns5:Parameters' of XSD type 'ns5:ActionParameters'
        ns5__ActionParameters *Parameters;
      public:
        /// Return unique type id SOAP_TYPE_ns5__NewActionConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE_ns5__NewActionConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns5__NewActionConfiguration, default initialized and not managed by a soap context
        virtual ns5__NewActionConfiguration *soap_alloc(void) const { return SOAP_NEW(ns5__NewActionConfiguration); }
      public:
        /// Constructor with initializations
        ns5__NewActionConfiguration() : Name(), TemplateToken(), Parameters() { }
        virtual ~ns5__NewActionConfiguration() { }
        /// Friend allocator used by soap_new_ns5__NewActionConfiguration(struct soap*, int)
        friend SOAP_FMAC1 ns5__NewActionConfiguration * SOAP_FMAC2 soap_instantiate_ns5__NewActionConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:543 */
#ifndef SOAP_TYPE_ns5__ActionConfiguration
#define SOAP_TYPE_ns5__ActionConfiguration (122)
/* Type ns5__ActionConfiguration is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns5:ActionConfiguration': */
class SOAP_CMAC ns5__ActionConfiguration : public soap_dom_element {
      public:
        /// Required element 'ns5:ConfigurationID' of XSD type 'xsd:integer'
        std::string ConfigurationID;
        /// Optional element 'ns5:Name' of XSD type 'xsd:string'
        std::string *Name;
        /// Required element 'ns5:TemplateToken' of XSD type 'xsd:string'
        std::string TemplateToken;
        /// Optional element 'ns5:Parameters' of XSD type 'ns5:ActionParameters'
        ns5__ActionParameters *Parameters;
      public:
        /// Return unique type id SOAP_TYPE_ns5__ActionConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE_ns5__ActionConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns5__ActionConfiguration, default initialized and not managed by a soap context
        virtual ns5__ActionConfiguration *soap_alloc(void) const { return SOAP_NEW(ns5__ActionConfiguration); }
      public:
        /// Constructor with initializations
        ns5__ActionConfiguration() : ConfigurationID(), Name(), TemplateToken(), Parameters() { }
        virtual ~ns5__ActionConfiguration() { }
        /// Friend allocator used by soap_new_ns5__ActionConfiguration(struct soap*, int)
        friend SOAP_FMAC1 ns5__ActionConfiguration * SOAP_FMAC2 soap_instantiate_ns5__ActionConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:546 */
#ifndef SOAP_TYPE_ns5__ActionParameters
#define SOAP_TYPE_ns5__ActionParameters (123)
/* Type ns5__ActionParameters is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns5:ActionParameters': */
class SOAP_CMAC ns5__ActionParameters : public soap_dom_element {
      public:
        /// Optional element 'ns5:Parameter' of XSD type 'ns5:ActionParameter'
        std::vector<ns5__ActionParameter *> Parameter;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_ns5__ActionParameters
        virtual long soap_type(void) const { return SOAP_TYPE_ns5__ActionParameters; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns5__ActionParameters, default initialized and not managed by a soap context
        virtual ns5__ActionParameters *soap_alloc(void) const { return SOAP_NEW(ns5__ActionParameters); }
      public:
        /// Constructor with initializations
        ns5__ActionParameters() : Parameter(), __anyAttribute() { }
        virtual ~ns5__ActionParameters() { }
        /// Friend allocator used by soap_new_ns5__ActionParameters(struct soap*, int)
        friend SOAP_FMAC1 ns5__ActionParameters * SOAP_FMAC2 soap_instantiate_ns5__ActionParameters(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:549 */
#ifndef SOAP_TYPE_ns5__ActionTemplates
#define SOAP_TYPE_ns5__ActionTemplates (124)
/* Type ns5__ActionTemplates is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns5:ActionTemplates': */
class SOAP_CMAC ns5__ActionTemplates : public soap_dom_element {
      public:
        /// Optional element 'ns5:ActionTemplate' of XSD type 'ns5:ActionTemplate'
        std::vector<ns5__ActionTemplate *> ActionTemplate;
      public:
        /// Return unique type id SOAP_TYPE_ns5__ActionTemplates
        virtual long soap_type(void) const { return SOAP_TYPE_ns5__ActionTemplates; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns5__ActionTemplates, default initialized and not managed by a soap context
        virtual ns5__ActionTemplates *soap_alloc(void) const { return SOAP_NEW(ns5__ActionTemplates); }
      public:
        /// Constructor with initializations
        ns5__ActionTemplates() : ActionTemplate() { }
        virtual ~ns5__ActionTemplates() { }
        /// Friend allocator used by soap_new_ns5__ActionTemplates(struct soap*, int)
        friend SOAP_FMAC1 ns5__ActionTemplates * SOAP_FMAC2 soap_instantiate_ns5__ActionTemplates(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:552 */
#ifndef SOAP_TYPE_ns5__ActionParameter
#define SOAP_TYPE_ns5__ActionParameter (125)
/* Type ns5__ActionParameter is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns5:ActionParameter': */
class SOAP_CMAC ns5__ActionParameter : public soap_dom_element {
      public:
        /// required attribute 'Name' of XSD type 'xsd:string'
        std::string Name;
        /// required attribute 'Value' of XSD type 'xsd:string'
        std::string Value;
      public:
        /// Return unique type id SOAP_TYPE_ns5__ActionParameter
        virtual long soap_type(void) const { return SOAP_TYPE_ns5__ActionParameter; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns5__ActionParameter, default initialized and not managed by a soap context
        virtual ns5__ActionParameter *soap_alloc(void) const { return SOAP_NEW(ns5__ActionParameter); }
      public:
        /// Constructor with initializations
        ns5__ActionParameter() : Name(), Value() { }
        virtual ~ns5__ActionParameter() { }
        /// Friend allocator used by soap_new_ns5__ActionParameter(struct soap*, int)
        friend SOAP_FMAC1 ns5__ActionParameter * SOAP_FMAC2 soap_instantiate_ns5__ActionParameter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:555 */
#ifndef SOAP_TYPE_ns5__ActionTemplate
#define SOAP_TYPE_ns5__ActionTemplate (126)
/* Type ns5__ActionTemplate is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns5:ActionTemplate': */
class SOAP_CMAC ns5__ActionTemplate : public soap_dom_element {
      public:
        /// Required element 'ns5:TemplateToken' of XSD type 'xsd:string'
        std::string TemplateToken;
        /// Optional element 'ns5:RecipientTemplate' of XSD type 'xsd:string'
        std::string *RecipientTemplate;
        /// Optional element 'ns5:Parameters' of XSD type 'ns5:ActionTemplateParameters'
        ns5__ActionTemplateParameters *Parameters;
      public:
        /// Return unique type id SOAP_TYPE_ns5__ActionTemplate
        virtual long soap_type(void) const { return SOAP_TYPE_ns5__ActionTemplate; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns5__ActionTemplate, default initialized and not managed by a soap context
        virtual ns5__ActionTemplate *soap_alloc(void) const { return SOAP_NEW(ns5__ActionTemplate); }
      public:
        /// Constructor with initializations
        ns5__ActionTemplate() : TemplateToken(), RecipientTemplate(), Parameters() { }
        virtual ~ns5__ActionTemplate() { }
        /// Friend allocator used by soap_new_ns5__ActionTemplate(struct soap*, int)
        friend SOAP_FMAC1 ns5__ActionTemplate * SOAP_FMAC2 soap_instantiate_ns5__ActionTemplate(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:558 */
#ifndef SOAP_TYPE_ns5__ActionTemplateParameters
#define SOAP_TYPE_ns5__ActionTemplateParameters (127)
/* Type ns5__ActionTemplateParameters is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns5:ActionTemplateParameters': */
class SOAP_CMAC ns5__ActionTemplateParameters : public soap_dom_element {
      public:
        /// Required element 'ns5:Parameter' of XSD type 'ns5:ActionTemplateParameter'
        std::vector<ns5__ActionTemplateParameter *> Parameter;
      public:
        /// Return unique type id SOAP_TYPE_ns5__ActionTemplateParameters
        virtual long soap_type(void) const { return SOAP_TYPE_ns5__ActionTemplateParameters; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns5__ActionTemplateParameters, default initialized and not managed by a soap context
        virtual ns5__ActionTemplateParameters *soap_alloc(void) const { return SOAP_NEW(ns5__ActionTemplateParameters); }
      public:
        /// Constructor with initializations
        ns5__ActionTemplateParameters() : Parameter() { }
        virtual ~ns5__ActionTemplateParameters() { }
        /// Friend allocator used by soap_new_ns5__ActionTemplateParameters(struct soap*, int)
        friend SOAP_FMAC1 ns5__ActionTemplateParameters * SOAP_FMAC2 soap_instantiate_ns5__ActionTemplateParameters(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:561 */
#ifndef SOAP_TYPE_ns5__ActionTemplateParameter
#define SOAP_TYPE_ns5__ActionTemplateParameter (128)
/* Type ns5__ActionTemplateParameter is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns5:ActionTemplateParameter': */
class SOAP_CMAC ns5__ActionTemplateParameter : public soap_dom_element {
      public:
        /// required attribute 'Name' of XSD type 'xsd:string'
        std::string Name;
        /// required attribute 'Type' of XSD type 'xsd:string'
        std::string Type;
      public:
        /// Return unique type id SOAP_TYPE_ns5__ActionTemplateParameter
        virtual long soap_type(void) const { return SOAP_TYPE_ns5__ActionTemplateParameter; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns5__ActionTemplateParameter, default initialized and not managed by a soap context
        virtual ns5__ActionTemplateParameter *soap_alloc(void) const { return SOAP_NEW(ns5__ActionTemplateParameter); }
      public:
        /// Constructor with initializations
        ns5__ActionTemplateParameter() : Name(), Type() { }
        virtual ~ns5__ActionTemplateParameter() { }
        /// Friend allocator used by soap_new_ns5__ActionTemplateParameter(struct soap*, int)
        friend SOAP_FMAC1 ns5__ActionTemplateParameter * SOAP_FMAC2 soap_instantiate_ns5__ActionTemplateParameter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:564 */
#ifndef SOAP_TYPE_ns5__UsedByActionConfigurations
#define SOAP_TYPE_ns5__UsedByActionConfigurations (129)
/* Type ns5__UsedByActionConfigurations is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns5:UsedByActionConfigurations': */
class SOAP_CMAC ns5__UsedByActionConfigurations : public soap_dom_element {
      public:
        /// Optional element 'ns5:ActionConfiguration' of XSD type 'ns5:UsedActionConfiguration'
        std::vector<ns5__UsedActionConfiguration *> ActionConfiguration;
      public:
        /// Return unique type id SOAP_TYPE_ns5__UsedByActionConfigurations
        virtual long soap_type(void) const { return SOAP_TYPE_ns5__UsedByActionConfigurations; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns5__UsedByActionConfigurations, default initialized and not managed by a soap context
        virtual ns5__UsedByActionConfigurations *soap_alloc(void) const { return SOAP_NEW(ns5__UsedByActionConfigurations); }
      public:
        /// Constructor with initializations
        ns5__UsedByActionConfigurations() : ActionConfiguration() { }
        virtual ~ns5__UsedByActionConfigurations() { }
        /// Friend allocator used by soap_new_ns5__UsedByActionConfigurations(struct soap*, int)
        friend SOAP_FMAC1 ns5__UsedByActionConfigurations * SOAP_FMAC2 soap_instantiate_ns5__UsedByActionConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:567 */
#ifndef SOAP_TYPE_ns5__UsedActionConfiguration
#define SOAP_TYPE_ns5__UsedActionConfiguration (130)
/* Type ns5__UsedActionConfiguration is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns5:UsedActionConfiguration': */
class SOAP_CMAC ns5__UsedActionConfiguration : public soap_dom_element {
      public:
        /// Required element 'ns5:ActionConfigurationID' of XSD type 'xsd:integer'
        std::string ActionConfigurationID;
        /// Optional element 'ns5:ActionConfigurationName' of XSD type 'xsd:string'
        std::string *ActionConfigurationName;
      public:
        /// Return unique type id SOAP_TYPE_ns5__UsedActionConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE_ns5__UsedActionConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns5__UsedActionConfiguration, default initialized and not managed by a soap context
        virtual ns5__UsedActionConfiguration *soap_alloc(void) const { return SOAP_NEW(ns5__UsedActionConfiguration); }
      public:
        /// Constructor with initializations
        ns5__UsedActionConfiguration() : ActionConfigurationID(), ActionConfigurationName() { }
        virtual ~ns5__UsedActionConfiguration() { }
        /// Friend allocator used by soap_new_ns5__UsedActionConfiguration(struct soap*, int)
        friend SOAP_FMAC1 ns5__UsedActionConfiguration * SOAP_FMAC2 soap_instantiate_ns5__UsedActionConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:570 */
#ifndef SOAP_TYPE_ns5__UsedByActionRules
#define SOAP_TYPE_ns5__UsedByActionRules (131)
/* Type ns5__UsedByActionRules is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns5:UsedByActionRules': */
class SOAP_CMAC ns5__UsedByActionRules : public soap_dom_element {
      public:
        /// Optional element 'ns5:ActionRule' of XSD type 'ns5:UsedActionRule'
        std::vector<ns5__UsedActionRule *> ActionRule;
      public:
        /// Return unique type id SOAP_TYPE_ns5__UsedByActionRules
        virtual long soap_type(void) const { return SOAP_TYPE_ns5__UsedByActionRules; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns5__UsedByActionRules, default initialized and not managed by a soap context
        virtual ns5__UsedByActionRules *soap_alloc(void) const { return SOAP_NEW(ns5__UsedByActionRules); }
      public:
        /// Constructor with initializations
        ns5__UsedByActionRules() : ActionRule() { }
        virtual ~ns5__UsedByActionRules() { }
        /// Friend allocator used by soap_new_ns5__UsedByActionRules(struct soap*, int)
        friend SOAP_FMAC1 ns5__UsedByActionRules * SOAP_FMAC2 soap_instantiate_ns5__UsedByActionRules(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:573 */
#ifndef SOAP_TYPE_ns5__UsedActionRule
#define SOAP_TYPE_ns5__UsedActionRule (132)
/* Type ns5__UsedActionRule is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns5:UsedActionRule': */
class SOAP_CMAC ns5__UsedActionRule : public soap_dom_element {
      public:
        /// Required element 'ns5:ActionRuleID' of XSD type 'xsd:integer'
        std::string ActionRuleID;
        /// Optional element 'ns5:ActionRuleName' of XSD type 'xsd:string'
        std::string *ActionRuleName;
      public:
        /// Return unique type id SOAP_TYPE_ns5__UsedActionRule
        virtual long soap_type(void) const { return SOAP_TYPE_ns5__UsedActionRule; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns5__UsedActionRule, default initialized and not managed by a soap context
        virtual ns5__UsedActionRule *soap_alloc(void) const { return SOAP_NEW(ns5__UsedActionRule); }
      public:
        /// Constructor with initializations
        ns5__UsedActionRule() : ActionRuleID(), ActionRuleName() { }
        virtual ~ns5__UsedActionRule() { }
        /// Friend allocator used by soap_new_ns5__UsedActionRule(struct soap*, int)
        friend SOAP_FMAC1 ns5__UsedActionRule * SOAP_FMAC2 soap_instantiate_ns5__UsedActionRule(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:576 */
#ifndef SOAP_TYPE__ns5__GetActionTemplates
#define SOAP_TYPE__ns5__GetActionTemplates (133)
/* complex XSD type 'ns5:GetActionTemplates': */
class SOAP_CMAC _ns5__GetActionTemplates {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns5__GetActionTemplates
        virtual long soap_type(void) const { return SOAP_TYPE__ns5__GetActionTemplates; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns5__GetActionTemplates, default initialized and not managed by a soap context
        virtual _ns5__GetActionTemplates *soap_alloc(void) const { return SOAP_NEW(_ns5__GetActionTemplates); }
      public:
        /// Constructor with initializations
        _ns5__GetActionTemplates() : soap() { }
        virtual ~_ns5__GetActionTemplates() { }
        /// Friend allocator used by soap_new__ns5__GetActionTemplates(struct soap*, int)
        friend SOAP_FMAC1 _ns5__GetActionTemplates * SOAP_FMAC2 soap_instantiate__ns5__GetActionTemplates(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:579 */
#ifndef SOAP_TYPE__ns5__GetActionTemplatesResponse
#define SOAP_TYPE__ns5__GetActionTemplatesResponse (134)
/* complex XSD type 'ns5:GetActionTemplatesResponse': */
class SOAP_CMAC _ns5__GetActionTemplatesResponse {
      public:
        /// Required element 'ns5:ActionTemplates' of XSD type 'ns5:ActionTemplates'
        ns5__ActionTemplates *ActionTemplates;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns5__GetActionTemplatesResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns5__GetActionTemplatesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns5__GetActionTemplatesResponse, default initialized and not managed by a soap context
        virtual _ns5__GetActionTemplatesResponse *soap_alloc(void) const { return SOAP_NEW(_ns5__GetActionTemplatesResponse); }
      public:
        /// Constructor with initializations
        _ns5__GetActionTemplatesResponse() : ActionTemplates(), soap() { }
        virtual ~_ns5__GetActionTemplatesResponse() { }
        /// Friend allocator used by soap_new__ns5__GetActionTemplatesResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns5__GetActionTemplatesResponse * SOAP_FMAC2 soap_instantiate__ns5__GetActionTemplatesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:582 */
#ifndef SOAP_TYPE__ns5__AddActionConfiguration
#define SOAP_TYPE__ns5__AddActionConfiguration (135)
/* complex XSD type 'ns5:AddActionConfiguration': */
class SOAP_CMAC _ns5__AddActionConfiguration {
      public:
        /// Required element 'ns5:NewActionConfiguration' of XSD type 'ns5:NewActionConfiguration'
        ns5__NewActionConfiguration *NewActionConfiguration;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns5__AddActionConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE__ns5__AddActionConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns5__AddActionConfiguration, default initialized and not managed by a soap context
        virtual _ns5__AddActionConfiguration *soap_alloc(void) const { return SOAP_NEW(_ns5__AddActionConfiguration); }
      public:
        /// Constructor with initializations
        _ns5__AddActionConfiguration() : NewActionConfiguration(), soap() { }
        virtual ~_ns5__AddActionConfiguration() { }
        /// Friend allocator used by soap_new__ns5__AddActionConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _ns5__AddActionConfiguration * SOAP_FMAC2 soap_instantiate__ns5__AddActionConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:585 */
#ifndef SOAP_TYPE__ns5__AddActionConfigurationResponse
#define SOAP_TYPE__ns5__AddActionConfigurationResponse (136)
/* complex XSD type 'ns5:AddActionConfigurationResponse': */
class SOAP_CMAC _ns5__AddActionConfigurationResponse {
      public:
        /// Required element 'ns5:ConfigurationID' of XSD type 'xsd:integer'
        std::string ConfigurationID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns5__AddActionConfigurationResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns5__AddActionConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns5__AddActionConfigurationResponse, default initialized and not managed by a soap context
        virtual _ns5__AddActionConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_ns5__AddActionConfigurationResponse); }
      public:
        /// Constructor with initializations
        _ns5__AddActionConfigurationResponse() : ConfigurationID(), soap() { }
        virtual ~_ns5__AddActionConfigurationResponse() { }
        /// Friend allocator used by soap_new__ns5__AddActionConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns5__AddActionConfigurationResponse * SOAP_FMAC2 soap_instantiate__ns5__AddActionConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:588 */
#ifndef SOAP_TYPE__ns5__RemoveActionConfiguration
#define SOAP_TYPE__ns5__RemoveActionConfiguration (137)
/* complex XSD type 'ns5:RemoveActionConfiguration': */
class SOAP_CMAC _ns5__RemoveActionConfiguration {
      public:
        /// Required element 'ns5:ConfigurationID' of XSD type 'xsd:integer'
        std::string ConfigurationID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns5__RemoveActionConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE__ns5__RemoveActionConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns5__RemoveActionConfiguration, default initialized and not managed by a soap context
        virtual _ns5__RemoveActionConfiguration *soap_alloc(void) const { return SOAP_NEW(_ns5__RemoveActionConfiguration); }
      public:
        /// Constructor with initializations
        _ns5__RemoveActionConfiguration() : ConfigurationID(), soap() { }
        virtual ~_ns5__RemoveActionConfiguration() { }
        /// Friend allocator used by soap_new__ns5__RemoveActionConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _ns5__RemoveActionConfiguration * SOAP_FMAC2 soap_instantiate__ns5__RemoveActionConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:591 */
#ifndef SOAP_TYPE__ns5__RemoveActionConfigurationResponse
#define SOAP_TYPE__ns5__RemoveActionConfigurationResponse (138)
/* complex XSD type 'ns5:RemoveActionConfigurationResponse': */
class SOAP_CMAC _ns5__RemoveActionConfigurationResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns5__RemoveActionConfigurationResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns5__RemoveActionConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns5__RemoveActionConfigurationResponse, default initialized and not managed by a soap context
        virtual _ns5__RemoveActionConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_ns5__RemoveActionConfigurationResponse); }
      public:
        /// Constructor with initializations
        _ns5__RemoveActionConfigurationResponse() : soap() { }
        virtual ~_ns5__RemoveActionConfigurationResponse() { }
        /// Friend allocator used by soap_new__ns5__RemoveActionConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns5__RemoveActionConfigurationResponse * SOAP_FMAC2 soap_instantiate__ns5__RemoveActionConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:594 */
#ifndef SOAP_TYPE__ns5__GetActionConfigurations
#define SOAP_TYPE__ns5__GetActionConfigurations (139)
/* complex XSD type 'ns5:GetActionConfigurations': */
class SOAP_CMAC _ns5__GetActionConfigurations {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns5__GetActionConfigurations
        virtual long soap_type(void) const { return SOAP_TYPE__ns5__GetActionConfigurations; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns5__GetActionConfigurations, default initialized and not managed by a soap context
        virtual _ns5__GetActionConfigurations *soap_alloc(void) const { return SOAP_NEW(_ns5__GetActionConfigurations); }
      public:
        /// Constructor with initializations
        _ns5__GetActionConfigurations() : soap() { }
        virtual ~_ns5__GetActionConfigurations() { }
        /// Friend allocator used by soap_new__ns5__GetActionConfigurations(struct soap*, int)
        friend SOAP_FMAC1 _ns5__GetActionConfigurations * SOAP_FMAC2 soap_instantiate__ns5__GetActionConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:597 */
#ifndef SOAP_TYPE__ns5__GetActionConfigurationsResponse
#define SOAP_TYPE__ns5__GetActionConfigurationsResponse (140)
/* complex XSD type 'ns5:GetActionConfigurationsResponse': */
class SOAP_CMAC _ns5__GetActionConfigurationsResponse {
      public:
        /// Required element 'ns5:ActionConfigurations' of XSD type 'ns5:ActionConfigurations'
        ns5__ActionConfigurations *ActionConfigurations;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns5__GetActionConfigurationsResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns5__GetActionConfigurationsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns5__GetActionConfigurationsResponse, default initialized and not managed by a soap context
        virtual _ns5__GetActionConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW(_ns5__GetActionConfigurationsResponse); }
      public:
        /// Constructor with initializations
        _ns5__GetActionConfigurationsResponse() : ActionConfigurations(), soap() { }
        virtual ~_ns5__GetActionConfigurationsResponse() { }
        /// Friend allocator used by soap_new__ns5__GetActionConfigurationsResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns5__GetActionConfigurationsResponse * SOAP_FMAC2 soap_instantiate__ns5__GetActionConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:600 */
#ifndef SOAP_TYPE__ns5__GetRecipientTemplates
#define SOAP_TYPE__ns5__GetRecipientTemplates (141)
/* complex XSD type 'ns5:GetRecipientTemplates': */
class SOAP_CMAC _ns5__GetRecipientTemplates {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns5__GetRecipientTemplates
        virtual long soap_type(void) const { return SOAP_TYPE__ns5__GetRecipientTemplates; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns5__GetRecipientTemplates, default initialized and not managed by a soap context
        virtual _ns5__GetRecipientTemplates *soap_alloc(void) const { return SOAP_NEW(_ns5__GetRecipientTemplates); }
      public:
        /// Constructor with initializations
        _ns5__GetRecipientTemplates() : soap() { }
        virtual ~_ns5__GetRecipientTemplates() { }
        /// Friend allocator used by soap_new__ns5__GetRecipientTemplates(struct soap*, int)
        friend SOAP_FMAC1 _ns5__GetRecipientTemplates * SOAP_FMAC2 soap_instantiate__ns5__GetRecipientTemplates(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:603 */
#ifndef SOAP_TYPE__ns5__GetRecipientTemplatesResponse
#define SOAP_TYPE__ns5__GetRecipientTemplatesResponse (142)
/* complex XSD type 'ns5:GetRecipientTemplatesResponse': */
class SOAP_CMAC _ns5__GetRecipientTemplatesResponse {
      public:
        /// Required element 'ns5:RecipientTemplates' of XSD type 'ns5:RecipientTemplates'
        ns5__RecipientTemplates *RecipientTemplates;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns5__GetRecipientTemplatesResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns5__GetRecipientTemplatesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns5__GetRecipientTemplatesResponse, default initialized and not managed by a soap context
        virtual _ns5__GetRecipientTemplatesResponse *soap_alloc(void) const { return SOAP_NEW(_ns5__GetRecipientTemplatesResponse); }
      public:
        /// Constructor with initializations
        _ns5__GetRecipientTemplatesResponse() : RecipientTemplates(), soap() { }
        virtual ~_ns5__GetRecipientTemplatesResponse() { }
        /// Friend allocator used by soap_new__ns5__GetRecipientTemplatesResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns5__GetRecipientTemplatesResponse * SOAP_FMAC2 soap_instantiate__ns5__GetRecipientTemplatesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:606 */
#ifndef SOAP_TYPE__ns5__AddRecipientConfiguration
#define SOAP_TYPE__ns5__AddRecipientConfiguration (143)
/* complex XSD type 'ns5:AddRecipientConfiguration': */
class SOAP_CMAC _ns5__AddRecipientConfiguration {
      public:
        /// Required element 'ns5:NewRecipientConfiguration' of XSD type 'ns5:NewRecipientConfiguration'
        ns5__NewRecipientConfiguration *NewRecipientConfiguration;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns5__AddRecipientConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE__ns5__AddRecipientConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns5__AddRecipientConfiguration, default initialized and not managed by a soap context
        virtual _ns5__AddRecipientConfiguration *soap_alloc(void) const { return SOAP_NEW(_ns5__AddRecipientConfiguration); }
      public:
        /// Constructor with initializations
        _ns5__AddRecipientConfiguration() : NewRecipientConfiguration(), soap() { }
        virtual ~_ns5__AddRecipientConfiguration() { }
        /// Friend allocator used by soap_new__ns5__AddRecipientConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _ns5__AddRecipientConfiguration * SOAP_FMAC2 soap_instantiate__ns5__AddRecipientConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:609 */
#ifndef SOAP_TYPE__ns5__AddRecipientConfigurationResponse
#define SOAP_TYPE__ns5__AddRecipientConfigurationResponse (144)
/* complex XSD type 'ns5:AddRecipientConfigurationResponse': */
class SOAP_CMAC _ns5__AddRecipientConfigurationResponse {
      public:
        /// Required element 'ns5:ConfigurationID' of XSD type 'xsd:integer'
        std::string ConfigurationID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns5__AddRecipientConfigurationResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns5__AddRecipientConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns5__AddRecipientConfigurationResponse, default initialized and not managed by a soap context
        virtual _ns5__AddRecipientConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_ns5__AddRecipientConfigurationResponse); }
      public:
        /// Constructor with initializations
        _ns5__AddRecipientConfigurationResponse() : ConfigurationID(), soap() { }
        virtual ~_ns5__AddRecipientConfigurationResponse() { }
        /// Friend allocator used by soap_new__ns5__AddRecipientConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns5__AddRecipientConfigurationResponse * SOAP_FMAC2 soap_instantiate__ns5__AddRecipientConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:612 */
#ifndef SOAP_TYPE__ns5__RemoveRecipientConfiguration
#define SOAP_TYPE__ns5__RemoveRecipientConfiguration (145)
/* complex XSD type 'ns5:RemoveRecipientConfiguration': */
class SOAP_CMAC _ns5__RemoveRecipientConfiguration {
      public:
        /// Required element 'ns5:ConfigurationID' of XSD type 'xsd:integer'
        std::string ConfigurationID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns5__RemoveRecipientConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE__ns5__RemoveRecipientConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns5__RemoveRecipientConfiguration, default initialized and not managed by a soap context
        virtual _ns5__RemoveRecipientConfiguration *soap_alloc(void) const { return SOAP_NEW(_ns5__RemoveRecipientConfiguration); }
      public:
        /// Constructor with initializations
        _ns5__RemoveRecipientConfiguration() : ConfigurationID(), soap() { }
        virtual ~_ns5__RemoveRecipientConfiguration() { }
        /// Friend allocator used by soap_new__ns5__RemoveRecipientConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _ns5__RemoveRecipientConfiguration * SOAP_FMAC2 soap_instantiate__ns5__RemoveRecipientConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:615 */
#ifndef SOAP_TYPE__ns5__RemoveRecipientConfigurationResponse
#define SOAP_TYPE__ns5__RemoveRecipientConfigurationResponse (146)
/* complex XSD type 'ns5:RemoveRecipientConfigurationResponse': */
class SOAP_CMAC _ns5__RemoveRecipientConfigurationResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns5__RemoveRecipientConfigurationResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns5__RemoveRecipientConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns5__RemoveRecipientConfigurationResponse, default initialized and not managed by a soap context
        virtual _ns5__RemoveRecipientConfigurationResponse *soap_alloc(void) const { return SOAP_NEW(_ns5__RemoveRecipientConfigurationResponse); }
      public:
        /// Constructor with initializations
        _ns5__RemoveRecipientConfigurationResponse() : soap() { }
        virtual ~_ns5__RemoveRecipientConfigurationResponse() { }
        /// Friend allocator used by soap_new__ns5__RemoveRecipientConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns5__RemoveRecipientConfigurationResponse * SOAP_FMAC2 soap_instantiate__ns5__RemoveRecipientConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:618 */
#ifndef SOAP_TYPE__ns5__GetRecipientConfigurations
#define SOAP_TYPE__ns5__GetRecipientConfigurations (147)
/* complex XSD type 'ns5:GetRecipientConfigurations': */
class SOAP_CMAC _ns5__GetRecipientConfigurations {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns5__GetRecipientConfigurations
        virtual long soap_type(void) const { return SOAP_TYPE__ns5__GetRecipientConfigurations; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns5__GetRecipientConfigurations, default initialized and not managed by a soap context
        virtual _ns5__GetRecipientConfigurations *soap_alloc(void) const { return SOAP_NEW(_ns5__GetRecipientConfigurations); }
      public:
        /// Constructor with initializations
        _ns5__GetRecipientConfigurations() : soap() { }
        virtual ~_ns5__GetRecipientConfigurations() { }
        /// Friend allocator used by soap_new__ns5__GetRecipientConfigurations(struct soap*, int)
        friend SOAP_FMAC1 _ns5__GetRecipientConfigurations * SOAP_FMAC2 soap_instantiate__ns5__GetRecipientConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:621 */
#ifndef SOAP_TYPE__ns5__GetRecipientConfigurationsResponse
#define SOAP_TYPE__ns5__GetRecipientConfigurationsResponse (148)
/* complex XSD type 'ns5:GetRecipientConfigurationsResponse': */
class SOAP_CMAC _ns5__GetRecipientConfigurationsResponse {
      public:
        /// Required element 'ns5:RecipientConfigurations' of XSD type 'ns5:RecipientConfigurations'
        ns5__RecipientConfigurations *RecipientConfigurations;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns5__GetRecipientConfigurationsResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns5__GetRecipientConfigurationsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns5__GetRecipientConfigurationsResponse, default initialized and not managed by a soap context
        virtual _ns5__GetRecipientConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW(_ns5__GetRecipientConfigurationsResponse); }
      public:
        /// Constructor with initializations
        _ns5__GetRecipientConfigurationsResponse() : RecipientConfigurations(), soap() { }
        virtual ~_ns5__GetRecipientConfigurationsResponse() { }
        /// Friend allocator used by soap_new__ns5__GetRecipientConfigurationsResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns5__GetRecipientConfigurationsResponse * SOAP_FMAC2 soap_instantiate__ns5__GetRecipientConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:624 */
#ifndef SOAP_TYPE__ns5__AddActionRule
#define SOAP_TYPE__ns5__AddActionRule (149)
/* complex XSD type 'ns5:AddActionRule': */
class SOAP_CMAC _ns5__AddActionRule {
      public:
        /// Required element 'ns5:NewActionRule' of XSD type 'ns5:NewActionRule'
        ns5__NewActionRule *NewActionRule;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns5__AddActionRule
        virtual long soap_type(void) const { return SOAP_TYPE__ns5__AddActionRule; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns5__AddActionRule, default initialized and not managed by a soap context
        virtual _ns5__AddActionRule *soap_alloc(void) const { return SOAP_NEW(_ns5__AddActionRule); }
      public:
        /// Constructor with initializations
        _ns5__AddActionRule() : NewActionRule(), soap() { }
        virtual ~_ns5__AddActionRule() { }
        /// Friend allocator used by soap_new__ns5__AddActionRule(struct soap*, int)
        friend SOAP_FMAC1 _ns5__AddActionRule * SOAP_FMAC2 soap_instantiate__ns5__AddActionRule(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:627 */
#ifndef SOAP_TYPE__ns5__AddActionRuleResponse
#define SOAP_TYPE__ns5__AddActionRuleResponse (150)
/* complex XSD type 'ns5:AddActionRuleResponse': */
class SOAP_CMAC _ns5__AddActionRuleResponse {
      public:
        /// Required element 'ns5:RuleID' of XSD type 'xsd:integer'
        std::string RuleID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns5__AddActionRuleResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns5__AddActionRuleResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns5__AddActionRuleResponse, default initialized and not managed by a soap context
        virtual _ns5__AddActionRuleResponse *soap_alloc(void) const { return SOAP_NEW(_ns5__AddActionRuleResponse); }
      public:
        /// Constructor with initializations
        _ns5__AddActionRuleResponse() : RuleID(), soap() { }
        virtual ~_ns5__AddActionRuleResponse() { }
        /// Friend allocator used by soap_new__ns5__AddActionRuleResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns5__AddActionRuleResponse * SOAP_FMAC2 soap_instantiate__ns5__AddActionRuleResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:630 */
#ifndef SOAP_TYPE__ns5__GetActionRules
#define SOAP_TYPE__ns5__GetActionRules (151)
/* complex XSD type 'ns5:GetActionRules': */
class SOAP_CMAC _ns5__GetActionRules {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns5__GetActionRules
        virtual long soap_type(void) const { return SOAP_TYPE__ns5__GetActionRules; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns5__GetActionRules, default initialized and not managed by a soap context
        virtual _ns5__GetActionRules *soap_alloc(void) const { return SOAP_NEW(_ns5__GetActionRules); }
      public:
        /// Constructor with initializations
        _ns5__GetActionRules() : soap() { }
        virtual ~_ns5__GetActionRules() { }
        /// Friend allocator used by soap_new__ns5__GetActionRules(struct soap*, int)
        friend SOAP_FMAC1 _ns5__GetActionRules * SOAP_FMAC2 soap_instantiate__ns5__GetActionRules(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:633 */
#ifndef SOAP_TYPE__ns5__GetActionRulesResponse
#define SOAP_TYPE__ns5__GetActionRulesResponse (152)
/* complex XSD type 'ns5:GetActionRulesResponse': */
class SOAP_CMAC _ns5__GetActionRulesResponse {
      public:
        /// Required element 'ns5:ActionRules' of XSD type 'ns5:ActionRules'
        ns5__ActionRules *ActionRules;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns5__GetActionRulesResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns5__GetActionRulesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns5__GetActionRulesResponse, default initialized and not managed by a soap context
        virtual _ns5__GetActionRulesResponse *soap_alloc(void) const { return SOAP_NEW(_ns5__GetActionRulesResponse); }
      public:
        /// Constructor with initializations
        _ns5__GetActionRulesResponse() : ActionRules(), soap() { }
        virtual ~_ns5__GetActionRulesResponse() { }
        /// Friend allocator used by soap_new__ns5__GetActionRulesResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns5__GetActionRulesResponse * SOAP_FMAC2 soap_instantiate__ns5__GetActionRulesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:636 */
#ifndef SOAP_TYPE__ns5__RemoveActionRule
#define SOAP_TYPE__ns5__RemoveActionRule (153)
/* complex XSD type 'ns5:RemoveActionRule': */
class SOAP_CMAC _ns5__RemoveActionRule {
      public:
        /// Required element 'ns5:RuleID' of XSD type 'xsd:integer'
        std::string RuleID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns5__RemoveActionRule
        virtual long soap_type(void) const { return SOAP_TYPE__ns5__RemoveActionRule; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns5__RemoveActionRule, default initialized and not managed by a soap context
        virtual _ns5__RemoveActionRule *soap_alloc(void) const { return SOAP_NEW(_ns5__RemoveActionRule); }
      public:
        /// Constructor with initializations
        _ns5__RemoveActionRule() : RuleID(), soap() { }
        virtual ~_ns5__RemoveActionRule() { }
        /// Friend allocator used by soap_new__ns5__RemoveActionRule(struct soap*, int)
        friend SOAP_FMAC1 _ns5__RemoveActionRule * SOAP_FMAC2 soap_instantiate__ns5__RemoveActionRule(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:639 */
#ifndef SOAP_TYPE__ns5__RemoveActionRuleResponse
#define SOAP_TYPE__ns5__RemoveActionRuleResponse (154)
/* complex XSD type 'ns5:RemoveActionRuleResponse': */
class SOAP_CMAC _ns5__RemoveActionRuleResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns5__RemoveActionRuleResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns5__RemoveActionRuleResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns5__RemoveActionRuleResponse, default initialized and not managed by a soap context
        virtual _ns5__RemoveActionRuleResponse *soap_alloc(void) const { return SOAP_NEW(_ns5__RemoveActionRuleResponse); }
      public:
        /// Constructor with initializations
        _ns5__RemoveActionRuleResponse() : soap() { }
        virtual ~_ns5__RemoveActionRuleResponse() { }
        /// Friend allocator used by soap_new__ns5__RemoveActionRuleResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns5__RemoveActionRuleResponse * SOAP_FMAC2 soap_instantiate__ns5__RemoveActionRuleResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:642 */
#ifndef SOAP_TYPE__ns5__ActionTemplateNotFoundFault
#define SOAP_TYPE__ns5__ActionTemplateNotFoundFault (155)
/* complex XSD type 'ns5:ActionTemplateNotFoundFault': */
class SOAP_CMAC _ns5__ActionTemplateNotFoundFault {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns5__ActionTemplateNotFoundFault
        virtual long soap_type(void) const { return SOAP_TYPE__ns5__ActionTemplateNotFoundFault; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns5__ActionTemplateNotFoundFault, default initialized and not managed by a soap context
        virtual _ns5__ActionTemplateNotFoundFault *soap_alloc(void) const { return SOAP_NEW(_ns5__ActionTemplateNotFoundFault); }
      public:
        /// Constructor with initializations
        _ns5__ActionTemplateNotFoundFault() : soap() { }
        virtual ~_ns5__ActionTemplateNotFoundFault() { }
        /// Friend allocator used by soap_new__ns5__ActionTemplateNotFoundFault(struct soap*, int)
        friend SOAP_FMAC1 _ns5__ActionTemplateNotFoundFault * SOAP_FMAC2 soap_instantiate__ns5__ActionTemplateNotFoundFault(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:645 */
#ifndef SOAP_TYPE__ns5__RecipientConfigurationNotFoundFault
#define SOAP_TYPE__ns5__RecipientConfigurationNotFoundFault (156)
/* complex XSD type 'ns5:RecipientConfigurationNotFoundFault': */
class SOAP_CMAC _ns5__RecipientConfigurationNotFoundFault {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns5__RecipientConfigurationNotFoundFault
        virtual long soap_type(void) const { return SOAP_TYPE__ns5__RecipientConfigurationNotFoundFault; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns5__RecipientConfigurationNotFoundFault, default initialized and not managed by a soap context
        virtual _ns5__RecipientConfigurationNotFoundFault *soap_alloc(void) const { return SOAP_NEW(_ns5__RecipientConfigurationNotFoundFault); }
      public:
        /// Constructor with initializations
        _ns5__RecipientConfigurationNotFoundFault() : soap() { }
        virtual ~_ns5__RecipientConfigurationNotFoundFault() { }
        /// Friend allocator used by soap_new__ns5__RecipientConfigurationNotFoundFault(struct soap*, int)
        friend SOAP_FMAC1 _ns5__RecipientConfigurationNotFoundFault * SOAP_FMAC2 soap_instantiate__ns5__RecipientConfigurationNotFoundFault(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:648 */
#ifndef SOAP_TYPE__ns5__ParametersMissmatchFault
#define SOAP_TYPE__ns5__ParametersMissmatchFault (157)
/* complex XSD type 'ns5:ParametersMissmatchFault': */
class SOAP_CMAC _ns5__ParametersMissmatchFault {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns5__ParametersMissmatchFault
        virtual long soap_type(void) const { return SOAP_TYPE__ns5__ParametersMissmatchFault; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns5__ParametersMissmatchFault, default initialized and not managed by a soap context
        virtual _ns5__ParametersMissmatchFault *soap_alloc(void) const { return SOAP_NEW(_ns5__ParametersMissmatchFault); }
      public:
        /// Constructor with initializations
        _ns5__ParametersMissmatchFault() : soap() { }
        virtual ~_ns5__ParametersMissmatchFault() { }
        /// Friend allocator used by soap_new__ns5__ParametersMissmatchFault(struct soap*, int)
        friend SOAP_FMAC1 _ns5__ParametersMissmatchFault * SOAP_FMAC2 soap_instantiate__ns5__ParametersMissmatchFault(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:651 */
#ifndef SOAP_TYPE__ns5__InvalidActionConfigurationFault
#define SOAP_TYPE__ns5__InvalidActionConfigurationFault (158)
/* complex XSD type 'ns5:InvalidActionConfigurationFault': */
class SOAP_CMAC _ns5__InvalidActionConfigurationFault {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns5__InvalidActionConfigurationFault
        virtual long soap_type(void) const { return SOAP_TYPE__ns5__InvalidActionConfigurationFault; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns5__InvalidActionConfigurationFault, default initialized and not managed by a soap context
        virtual _ns5__InvalidActionConfigurationFault *soap_alloc(void) const { return SOAP_NEW(_ns5__InvalidActionConfigurationFault); }
      public:
        /// Constructor with initializations
        _ns5__InvalidActionConfigurationFault() : soap() { }
        virtual ~_ns5__InvalidActionConfigurationFault() { }
        /// Friend allocator used by soap_new__ns5__InvalidActionConfigurationFault(struct soap*, int)
        friend SOAP_FMAC1 _ns5__InvalidActionConfigurationFault * SOAP_FMAC2 soap_instantiate__ns5__InvalidActionConfigurationFault(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:654 */
#ifndef SOAP_TYPE__ns5__ActionConfigurationNotFoundFault
#define SOAP_TYPE__ns5__ActionConfigurationNotFoundFault (159)
/* complex XSD type 'ns5:ActionConfigurationNotFoundFault': */
class SOAP_CMAC _ns5__ActionConfigurationNotFoundFault {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns5__ActionConfigurationNotFoundFault
        virtual long soap_type(void) const { return SOAP_TYPE__ns5__ActionConfigurationNotFoundFault; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns5__ActionConfigurationNotFoundFault, default initialized and not managed by a soap context
        virtual _ns5__ActionConfigurationNotFoundFault *soap_alloc(void) const { return SOAP_NEW(_ns5__ActionConfigurationNotFoundFault); }
      public:
        /// Constructor with initializations
        _ns5__ActionConfigurationNotFoundFault() : soap() { }
        virtual ~_ns5__ActionConfigurationNotFoundFault() { }
        /// Friend allocator used by soap_new__ns5__ActionConfigurationNotFoundFault(struct soap*, int)
        friend SOAP_FMAC1 _ns5__ActionConfigurationNotFoundFault * SOAP_FMAC2 soap_instantiate__ns5__ActionConfigurationNotFoundFault(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:657 */
#ifndef SOAP_TYPE__ns5__RecipientTemplateNotFoundFault
#define SOAP_TYPE__ns5__RecipientTemplateNotFoundFault (160)
/* complex XSD type 'ns5:RecipientTemplateNotFoundFault': */
class SOAP_CMAC _ns5__RecipientTemplateNotFoundFault {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns5__RecipientTemplateNotFoundFault
        virtual long soap_type(void) const { return SOAP_TYPE__ns5__RecipientTemplateNotFoundFault; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns5__RecipientTemplateNotFoundFault, default initialized and not managed by a soap context
        virtual _ns5__RecipientTemplateNotFoundFault *soap_alloc(void) const { return SOAP_NEW(_ns5__RecipientTemplateNotFoundFault); }
      public:
        /// Constructor with initializations
        _ns5__RecipientTemplateNotFoundFault() : soap() { }
        virtual ~_ns5__RecipientTemplateNotFoundFault() { }
        /// Friend allocator used by soap_new__ns5__RecipientTemplateNotFoundFault(struct soap*, int)
        friend SOAP_FMAC1 _ns5__RecipientTemplateNotFoundFault * SOAP_FMAC2 soap_instantiate__ns5__RecipientTemplateNotFoundFault(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:660 */
#ifndef SOAP_TYPE__ns5__ActionConfigurationIsInUseFault
#define SOAP_TYPE__ns5__ActionConfigurationIsInUseFault (161)
/* complex XSD type 'ns5:ActionConfigurationIsInUseFault': */
class SOAP_CMAC _ns5__ActionConfigurationIsInUseFault {
      public:
        /// Required element 'ns5:UsedByActionRules' of XSD type 'ns5:UsedByActionRules'
        ns5__UsedByActionRules *UsedByActionRules;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns5__ActionConfigurationIsInUseFault
        virtual long soap_type(void) const { return SOAP_TYPE__ns5__ActionConfigurationIsInUseFault; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns5__ActionConfigurationIsInUseFault, default initialized and not managed by a soap context
        virtual _ns5__ActionConfigurationIsInUseFault *soap_alloc(void) const { return SOAP_NEW(_ns5__ActionConfigurationIsInUseFault); }
      public:
        /// Constructor with initializations
        _ns5__ActionConfigurationIsInUseFault() : UsedByActionRules(), soap() { }
        virtual ~_ns5__ActionConfigurationIsInUseFault() { }
        /// Friend allocator used by soap_new__ns5__ActionConfigurationIsInUseFault(struct soap*, int)
        friend SOAP_FMAC1 _ns5__ActionConfigurationIsInUseFault * SOAP_FMAC2 soap_instantiate__ns5__ActionConfigurationIsInUseFault(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:663 */
#ifndef SOAP_TYPE__ns5__InvalidConditionFilterFault
#define SOAP_TYPE__ns5__InvalidConditionFilterFault (162)
/* complex XSD type 'ns5:InvalidConditionFilterFault': */
class SOAP_CMAC _ns5__InvalidConditionFilterFault {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns5__InvalidConditionFilterFault
        virtual long soap_type(void) const { return SOAP_TYPE__ns5__InvalidConditionFilterFault; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns5__InvalidConditionFilterFault, default initialized and not managed by a soap context
        virtual _ns5__InvalidConditionFilterFault *soap_alloc(void) const { return SOAP_NEW(_ns5__InvalidConditionFilterFault); }
      public:
        /// Constructor with initializations
        _ns5__InvalidConditionFilterFault() : soap() { }
        virtual ~_ns5__InvalidConditionFilterFault() { }
        /// Friend allocator used by soap_new__ns5__InvalidConditionFilterFault(struct soap*, int)
        friend SOAP_FMAC1 _ns5__InvalidConditionFilterFault * SOAP_FMAC2 soap_instantiate__ns5__InvalidConditionFilterFault(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:666 */
#ifndef SOAP_TYPE__ns5__InsufficientActivationRuleFault
#define SOAP_TYPE__ns5__InsufficientActivationRuleFault (163)
/* complex XSD type 'ns5:InsufficientActivationRuleFault': */
class SOAP_CMAC _ns5__InsufficientActivationRuleFault {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns5__InsufficientActivationRuleFault
        virtual long soap_type(void) const { return SOAP_TYPE__ns5__InsufficientActivationRuleFault; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns5__InsufficientActivationRuleFault, default initialized and not managed by a soap context
        virtual _ns5__InsufficientActivationRuleFault *soap_alloc(void) const { return SOAP_NEW(_ns5__InsufficientActivationRuleFault); }
      public:
        /// Constructor with initializations
        _ns5__InsufficientActivationRuleFault() : soap() { }
        virtual ~_ns5__InsufficientActivationRuleFault() { }
        /// Friend allocator used by soap_new__ns5__InsufficientActivationRuleFault(struct soap*, int)
        friend SOAP_FMAC1 _ns5__InsufficientActivationRuleFault * SOAP_FMAC2 soap_instantiate__ns5__InsufficientActivationRuleFault(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:669 */
#ifndef SOAP_TYPE__ns5__ActionRuleNotFoundFault
#define SOAP_TYPE__ns5__ActionRuleNotFoundFault (164)
/* complex XSD type 'ns5:ActionRuleNotFoundFault': */
class SOAP_CMAC _ns5__ActionRuleNotFoundFault {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns5__ActionRuleNotFoundFault
        virtual long soap_type(void) const { return SOAP_TYPE__ns5__ActionRuleNotFoundFault; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns5__ActionRuleNotFoundFault, default initialized and not managed by a soap context
        virtual _ns5__ActionRuleNotFoundFault *soap_alloc(void) const { return SOAP_NEW(_ns5__ActionRuleNotFoundFault); }
      public:
        /// Constructor with initializations
        _ns5__ActionRuleNotFoundFault() : soap() { }
        virtual ~_ns5__ActionRuleNotFoundFault() { }
        /// Friend allocator used by soap_new__ns5__ActionRuleNotFoundFault(struct soap*, int)
        friend SOAP_FMAC1 _ns5__ActionRuleNotFoundFault * SOAP_FMAC2 soap_instantiate__ns5__ActionRuleNotFoundFault(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:672 */
#ifndef SOAP_TYPE__ns5__InvalidActivationTimeoutFault
#define SOAP_TYPE__ns5__InvalidActivationTimeoutFault (165)
/* complex XSD type 'ns5:InvalidActivationTimeoutFault': */
class SOAP_CMAC _ns5__InvalidActivationTimeoutFault {
      public:
        /// Required element 'ns5:MaximumTimeout' of XSD type 'xsd:duration'
        std::string MaximumTimeout;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns5__InvalidActivationTimeoutFault
        virtual long soap_type(void) const { return SOAP_TYPE__ns5__InvalidActivationTimeoutFault; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns5__InvalidActivationTimeoutFault, default initialized and not managed by a soap context
        virtual _ns5__InvalidActivationTimeoutFault *soap_alloc(void) const { return SOAP_NEW(_ns5__InvalidActivationTimeoutFault); }
      public:
        /// Constructor with initializations
        _ns5__InvalidActivationTimeoutFault() : MaximumTimeout(), soap() { }
        virtual ~_ns5__InvalidActivationTimeoutFault() { }
        /// Friend allocator used by soap_new__ns5__InvalidActivationTimeoutFault(struct soap*, int)
        friend SOAP_FMAC1 _ns5__InvalidActivationTimeoutFault * SOAP_FMAC2 soap_instantiate__ns5__InvalidActivationTimeoutFault(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:675 */
#ifndef SOAP_TYPE_ns6__EndpointReferenceType
#define SOAP_TYPE_ns6__EndpointReferenceType (166)
/* Type ns6__EndpointReferenceType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns6:EndpointReferenceType': */
class SOAP_CMAC ns6__EndpointReferenceType : public soap_dom_element {
      public:
        /// Required element 'ns6:Address' of XSD type 'ns6:AttributedURIType'
        ns6__AttributedURIType *Address;
        /// Optional element 'ns6:ReferenceParameters' of XSD type 'ns6:ReferenceParametersType'
        ns6__ReferenceParametersType *ReferenceParameters;
        /// Optional element 'ns6:Metadata' of XSD type 'ns6:MetadataType'
        ns6__MetadataType *Metadata;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_ns6__EndpointReferenceType
        virtual long soap_type(void) const { return SOAP_TYPE_ns6__EndpointReferenceType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns6__EndpointReferenceType, default initialized and not managed by a soap context
        virtual ns6__EndpointReferenceType *soap_alloc(void) const { return SOAP_NEW(ns6__EndpointReferenceType); }
      public:
        /// Constructor with initializations
        ns6__EndpointReferenceType() : Address(), ReferenceParameters(), Metadata(), __any(), __anyAttribute() { }
        virtual ~ns6__EndpointReferenceType() { }
        /// Friend allocator used by soap_new_ns6__EndpointReferenceType(struct soap*, int)
        friend SOAP_FMAC1 ns6__EndpointReferenceType * SOAP_FMAC2 soap_instantiate_ns6__EndpointReferenceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:678 */
#ifndef SOAP_TYPE_ns6__ReferenceParametersType
#define SOAP_TYPE_ns6__ReferenceParametersType (167)
/* Type ns6__ReferenceParametersType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns6:ReferenceParametersType': */
class SOAP_CMAC ns6__ReferenceParametersType : public soap_dom_element {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_ns6__ReferenceParametersType
        virtual long soap_type(void) const { return SOAP_TYPE_ns6__ReferenceParametersType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns6__ReferenceParametersType, default initialized and not managed by a soap context
        virtual ns6__ReferenceParametersType *soap_alloc(void) const { return SOAP_NEW(ns6__ReferenceParametersType); }
      public:
        /// Constructor with initializations
        ns6__ReferenceParametersType() : __any(), __anyAttribute() { }
        virtual ~ns6__ReferenceParametersType() { }
        /// Friend allocator used by soap_new_ns6__ReferenceParametersType(struct soap*, int)
        friend SOAP_FMAC1 ns6__ReferenceParametersType * SOAP_FMAC2 soap_instantiate_ns6__ReferenceParametersType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:681 */
#ifndef SOAP_TYPE_ns6__MetadataType
#define SOAP_TYPE_ns6__MetadataType (168)
/* Type ns6__MetadataType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns6:MetadataType': */
class SOAP_CMAC ns6__MetadataType : public soap_dom_element {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_ns6__MetadataType
        virtual long soap_type(void) const { return SOAP_TYPE_ns6__MetadataType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns6__MetadataType, default initialized and not managed by a soap context
        virtual ns6__MetadataType *soap_alloc(void) const { return SOAP_NEW(ns6__MetadataType); }
      public:
        /// Constructor with initializations
        ns6__MetadataType() : __any(), __anyAttribute() { }
        virtual ~ns6__MetadataType() { }
        /// Friend allocator used by soap_new_ns6__MetadataType(struct soap*, int)
        friend SOAP_FMAC1 ns6__MetadataType * SOAP_FMAC2 soap_instantiate_ns6__MetadataType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:696 */
#ifndef SOAP_TYPE_ns6__ProblemActionType
#define SOAP_TYPE_ns6__ProblemActionType (173)
/* Type ns6__ProblemActionType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns6:ProblemActionType': */
class SOAP_CMAC ns6__ProblemActionType : public soap_dom_element {
      public:
        /// Optional element 'ns6:Action' of XSD type 'ns6:AttributedURIType'
        ns6__AttributedURIType *Action;
        /// Optional element 'ns6:SoapAction' of XSD type 'xsd:anyURI'
        std::string *SoapAction;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_ns6__ProblemActionType
        virtual long soap_type(void) const { return SOAP_TYPE_ns6__ProblemActionType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns6__ProblemActionType, default initialized and not managed by a soap context
        virtual ns6__ProblemActionType *soap_alloc(void) const { return SOAP_NEW(ns6__ProblemActionType); }
      public:
        /// Constructor with initializations
        ns6__ProblemActionType() : Action(), SoapAction(), __anyAttribute() { }
        virtual ~ns6__ProblemActionType() { }
        /// Friend allocator used by soap_new_ns6__ProblemActionType(struct soap*, int)
        friend SOAP_FMAC1 ns6__ProblemActionType * SOAP_FMAC2 soap_instantiate_ns6__ProblemActionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:300 */
#ifndef SOAP_TYPE_ns1__ICalendar
#define SOAP_TYPE_ns1__ICalendar (41)
/* Type ns1__ICalendar is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'ns1:ICalendar': */
class SOAP_CMAC ns1__ICalendar : public soap_dom_element {
      public:
        /// Simple content of XSD type 'xsd:string' wrapped by this struct
        std::string __item;
        /// optional attribute 'Dialect' of XSD type 'xsd:anyURI'
        std::string Dialect;	///< initialized with default value = "http://www.axis.com/vapix/ws/ical1"
      public:
        /// Return unique type id SOAP_TYPE_ns1__ICalendar
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__ICalendar; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ICalendar, default initialized and not managed by a soap context
        virtual ns1__ICalendar *soap_alloc(void) const { return SOAP_NEW(ns1__ICalendar); }
      public:
        /// Constructor with initializations
        ns1__ICalendar() : __item(), Dialect("http://www.axis.com/vapix/ws/ical1") { }
        virtual ~ns1__ICalendar() { }
        /// Friend allocator used by soap_new_ns1__ICalendar(struct soap*, int)
        friend SOAP_FMAC1 ns1__ICalendar * SOAP_FMAC2 soap_instantiate_ns1__ICalendar(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:3833 */
#ifndef SOAP_TYPE__ns2__TopicNamespaceType_Topic
#define SOAP_TYPE__ns2__TopicNamespaceType_Topic (261)
/* complex XSD type 'ns2:TopicNamespaceType-Topic': */
class SOAP_CMAC _ns2__TopicNamespaceType_Topic {
      public:
        /// Optional element 'ns2:documentation' of XSD type 'ns2:Documentation'
        ns2__Documentation *documentation;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Optional element 'ns2:MessagePattern' of XSD type 'ns2:QueryExpressionType'
        ns2__QueryExpressionType *MessagePattern;
        /// Optional element 'ns2:Topic' of XSD type 'ns2:TopicType'
        std::vector<ns2__TopicType *> Topic;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// required attribute 'name' of XSD type 'xsd:NCName'
        std::string name;
        /// optional attribute 'messageTypes' of XSD type 'xsd:QName'
        std::string *messageTypes;
        /// optional attribute 'final' of XSD type 'xsd:boolean'
        bool final_;	///< initialized with default value = (bool)0
        /// optional attribute 'parent' of XSD type 'ns2:ConcreteTopicExpression'
        std::string *parent;
      public:
        /// Return unique type id SOAP_TYPE__ns2__TopicNamespaceType_Topic
        virtual long soap_type(void) const { return SOAP_TYPE__ns2__TopicNamespaceType_Topic; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns2__TopicNamespaceType_Topic, default initialized and not managed by a soap context
        virtual _ns2__TopicNamespaceType_Topic *soap_alloc(void) const { return SOAP_NEW(_ns2__TopicNamespaceType_Topic); }
      public:
        /// Constructor with initializations
        _ns2__TopicNamespaceType_Topic() : documentation(), __anyAttribute(), MessagePattern(), Topic(), __any(), name(), messageTypes(), final_((bool)0), parent() { }
        virtual ~_ns2__TopicNamespaceType_Topic() { }
        /// Friend allocator used by soap_new__ns2__TopicNamespaceType_Topic(struct soap*, int)
        friend SOAP_FMAC1 _ns2__TopicNamespaceType_Topic * SOAP_FMAC2 soap_instantiate__ns2__TopicNamespaceType_Topic(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:357 */
#ifndef SOAP_TYPE_ns2__TopicNamespaceType
#define SOAP_TYPE_ns2__TopicNamespaceType (60)
/* Type ns2__TopicNamespaceType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns2:TopicNamespaceType': */
class SOAP_CMAC ns2__TopicNamespaceType : public ns2__ExtensibleDocumented {
      public:
        /// Optional element 'ns2:Topic' of XSD type 'ns2:TopicNamespaceType-Topic'
        std::vector<_ns2__TopicNamespaceType_Topic> Topic;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// optional attribute 'name' of XSD type 'xsd:NCName'
        std::string *name;
        /// required attribute 'targetNamespace' of XSD type 'xsd:anyURI'
        std::string targetNamespace;
        /// optional attribute 'final' of XSD type 'xsd:boolean'
        bool final_;	///< initialized with default value = (bool)0
      public:
        /// Return unique type id SOAP_TYPE_ns2__TopicNamespaceType
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__TopicNamespaceType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__TopicNamespaceType, default initialized and not managed by a soap context
        virtual ns2__TopicNamespaceType *soap_alloc(void) const { return SOAP_NEW(ns2__TopicNamespaceType); }
      public:
        /// Constructor with initializations
        ns2__TopicNamespaceType() : Topic(), __any(), name(), targetNamespace(), final_((bool)0) { }
        virtual ~ns2__TopicNamespaceType() { }
        /// Friend allocator used by soap_new_ns2__TopicNamespaceType(struct soap*, int)
        friend SOAP_FMAC1 ns2__TopicNamespaceType * SOAP_FMAC2 soap_instantiate_ns2__TopicNamespaceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:360 */
#ifndef SOAP_TYPE_ns2__TopicType
#define SOAP_TYPE_ns2__TopicType (61)
/* Type ns2__TopicType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns2:TopicType': */
class SOAP_CMAC ns2__TopicType : public ns2__ExtensibleDocumented {
      public:
        /// Optional element 'ns2:MessagePattern' of XSD type 'ns2:QueryExpressionType'
        ns2__QueryExpressionType *MessagePattern;
        /// Optional element 'ns2:Topic' of XSD type 'ns2:TopicType'
        std::vector<ns2__TopicType *> Topic;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// required attribute 'name' of XSD type 'xsd:NCName'
        std::string name;
        /// optional attribute 'messageTypes' of XSD type 'xsd:QName'
        std::string *messageTypes;
        /// optional attribute 'final' of XSD type 'xsd:boolean'
        bool final_;	///< initialized with default value = (bool)0
      public:
        /// Return unique type id SOAP_TYPE_ns2__TopicType
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__TopicType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__TopicType, default initialized and not managed by a soap context
        virtual ns2__TopicType *soap_alloc(void) const { return SOAP_NEW(ns2__TopicType); }
      public:
        /// Constructor with initializations
        ns2__TopicType() : MessagePattern(), Topic(), __any(), name(), messageTypes(), final_((bool)0) { }
        virtual ~ns2__TopicType() { }
        /// Friend allocator used by soap_new_ns2__TopicType(struct soap*, int)
        friend SOAP_FMAC1 ns2__TopicType * SOAP_FMAC2 soap_instantiate_ns2__TopicType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:363 */
#ifndef SOAP_TYPE_ns2__TopicSetType
#define SOAP_TYPE_ns2__TopicSetType (62)
/* Type ns2__TopicSetType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns2:TopicSetType': */
class SOAP_CMAC ns2__TopicSetType : public ns2__ExtensibleDocumented {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
      public:
        /// Return unique type id SOAP_TYPE_ns2__TopicSetType
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__TopicSetType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__TopicSetType, default initialized and not managed by a soap context
        virtual ns2__TopicSetType *soap_alloc(void) const { return SOAP_NEW(ns2__TopicSetType); }
      public:
        /// Constructor with initializations
        ns2__TopicSetType() : __any() { }
        virtual ~ns2__TopicSetType() { }
        /// Friend allocator used by soap_new_ns2__TopicSetType(struct soap*, int)
        friend SOAP_FMAC1 ns2__TopicSetType * SOAP_FMAC2 soap_instantiate_ns2__TopicSetType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:381 */
#ifndef SOAP_TYPE_ns3__SubscribeCreationFailedFaultType
#define SOAP_TYPE_ns3__SubscribeCreationFailedFaultType (68)
/* Type ns3__SubscribeCreationFailedFaultType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns3:SubscribeCreationFailedFaultType': */
class SOAP_CMAC ns3__SubscribeCreationFailedFaultType : public ns4__BaseFaultType {
      public:
        /// Return unique type id SOAP_TYPE_ns3__SubscribeCreationFailedFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_ns3__SubscribeCreationFailedFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__SubscribeCreationFailedFaultType, default initialized and not managed by a soap context
        virtual ns3__SubscribeCreationFailedFaultType *soap_alloc(void) const { return SOAP_NEW(ns3__SubscribeCreationFailedFaultType); }
      public:
        /// Constructor with initializations
        ns3__SubscribeCreationFailedFaultType() { }
        virtual ~ns3__SubscribeCreationFailedFaultType() { }
        /// Friend allocator used by soap_new_ns3__SubscribeCreationFailedFaultType(struct soap*, int)
        friend SOAP_FMAC1 ns3__SubscribeCreationFailedFaultType * SOAP_FMAC2 soap_instantiate_ns3__SubscribeCreationFailedFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:384 */
#ifndef SOAP_TYPE_ns3__InvalidFilterFaultType
#define SOAP_TYPE_ns3__InvalidFilterFaultType (69)
/* Type ns3__InvalidFilterFaultType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns3:InvalidFilterFaultType': */
class SOAP_CMAC ns3__InvalidFilterFaultType : public ns4__BaseFaultType {
      public:
        /// Required element 'ns3:UnknownFilter' of XSD type 'xsd:QName'
        std::vector<std::string> UnknownFilter;
      public:
        /// Return unique type id SOAP_TYPE_ns3__InvalidFilterFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_ns3__InvalidFilterFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__InvalidFilterFaultType, default initialized and not managed by a soap context
        virtual ns3__InvalidFilterFaultType *soap_alloc(void) const { return SOAP_NEW(ns3__InvalidFilterFaultType); }
      public:
        /// Constructor with initializations
        ns3__InvalidFilterFaultType() : UnknownFilter() { }
        virtual ~ns3__InvalidFilterFaultType() { }
        /// Friend allocator used by soap_new_ns3__InvalidFilterFaultType(struct soap*, int)
        friend SOAP_FMAC1 ns3__InvalidFilterFaultType * SOAP_FMAC2 soap_instantiate_ns3__InvalidFilterFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:387 */
#ifndef SOAP_TYPE_ns3__TopicExpressionDialectUnknownFaultType
#define SOAP_TYPE_ns3__TopicExpressionDialectUnknownFaultType (70)
/* Type ns3__TopicExpressionDialectUnknownFaultType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns3:TopicExpressionDialectUnknownFaultType': */
class SOAP_CMAC ns3__TopicExpressionDialectUnknownFaultType : public ns4__BaseFaultType {
      public:
        /// Return unique type id SOAP_TYPE_ns3__TopicExpressionDialectUnknownFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_ns3__TopicExpressionDialectUnknownFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__TopicExpressionDialectUnknownFaultType, default initialized and not managed by a soap context
        virtual ns3__TopicExpressionDialectUnknownFaultType *soap_alloc(void) const { return SOAP_NEW(ns3__TopicExpressionDialectUnknownFaultType); }
      public:
        /// Constructor with initializations
        ns3__TopicExpressionDialectUnknownFaultType() { }
        virtual ~ns3__TopicExpressionDialectUnknownFaultType() { }
        /// Friend allocator used by soap_new_ns3__TopicExpressionDialectUnknownFaultType(struct soap*, int)
        friend SOAP_FMAC1 ns3__TopicExpressionDialectUnknownFaultType * SOAP_FMAC2 soap_instantiate_ns3__TopicExpressionDialectUnknownFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:390 */
#ifndef SOAP_TYPE_ns3__InvalidTopicExpressionFaultType
#define SOAP_TYPE_ns3__InvalidTopicExpressionFaultType (71)
/* Type ns3__InvalidTopicExpressionFaultType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns3:InvalidTopicExpressionFaultType': */
class SOAP_CMAC ns3__InvalidTopicExpressionFaultType : public ns4__BaseFaultType {
      public:
        /// Return unique type id SOAP_TYPE_ns3__InvalidTopicExpressionFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_ns3__InvalidTopicExpressionFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__InvalidTopicExpressionFaultType, default initialized and not managed by a soap context
        virtual ns3__InvalidTopicExpressionFaultType *soap_alloc(void) const { return SOAP_NEW(ns3__InvalidTopicExpressionFaultType); }
      public:
        /// Constructor with initializations
        ns3__InvalidTopicExpressionFaultType() { }
        virtual ~ns3__InvalidTopicExpressionFaultType() { }
        /// Friend allocator used by soap_new_ns3__InvalidTopicExpressionFaultType(struct soap*, int)
        friend SOAP_FMAC1 ns3__InvalidTopicExpressionFaultType * SOAP_FMAC2 soap_instantiate_ns3__InvalidTopicExpressionFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:393 */
#ifndef SOAP_TYPE_ns3__TopicNotSupportedFaultType
#define SOAP_TYPE_ns3__TopicNotSupportedFaultType (72)
/* Type ns3__TopicNotSupportedFaultType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns3:TopicNotSupportedFaultType': */
class SOAP_CMAC ns3__TopicNotSupportedFaultType : public ns4__BaseFaultType {
      public:
        /// Return unique type id SOAP_TYPE_ns3__TopicNotSupportedFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_ns3__TopicNotSupportedFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__TopicNotSupportedFaultType, default initialized and not managed by a soap context
        virtual ns3__TopicNotSupportedFaultType *soap_alloc(void) const { return SOAP_NEW(ns3__TopicNotSupportedFaultType); }
      public:
        /// Constructor with initializations
        ns3__TopicNotSupportedFaultType() { }
        virtual ~ns3__TopicNotSupportedFaultType() { }
        /// Friend allocator used by soap_new_ns3__TopicNotSupportedFaultType(struct soap*, int)
        friend SOAP_FMAC1 ns3__TopicNotSupportedFaultType * SOAP_FMAC2 soap_instantiate_ns3__TopicNotSupportedFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:396 */
#ifndef SOAP_TYPE_ns3__MultipleTopicsSpecifiedFaultType
#define SOAP_TYPE_ns3__MultipleTopicsSpecifiedFaultType (73)
/* Type ns3__MultipleTopicsSpecifiedFaultType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns3:MultipleTopicsSpecifiedFaultType': */
class SOAP_CMAC ns3__MultipleTopicsSpecifiedFaultType : public ns4__BaseFaultType {
      public:
        /// Return unique type id SOAP_TYPE_ns3__MultipleTopicsSpecifiedFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_ns3__MultipleTopicsSpecifiedFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__MultipleTopicsSpecifiedFaultType, default initialized and not managed by a soap context
        virtual ns3__MultipleTopicsSpecifiedFaultType *soap_alloc(void) const { return SOAP_NEW(ns3__MultipleTopicsSpecifiedFaultType); }
      public:
        /// Constructor with initializations
        ns3__MultipleTopicsSpecifiedFaultType() { }
        virtual ~ns3__MultipleTopicsSpecifiedFaultType() { }
        /// Friend allocator used by soap_new_ns3__MultipleTopicsSpecifiedFaultType(struct soap*, int)
        friend SOAP_FMAC1 ns3__MultipleTopicsSpecifiedFaultType * SOAP_FMAC2 soap_instantiate_ns3__MultipleTopicsSpecifiedFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:399 */
#ifndef SOAP_TYPE_ns3__InvalidProducerPropertiesExpressionFaultType
#define SOAP_TYPE_ns3__InvalidProducerPropertiesExpressionFaultType (74)
/* Type ns3__InvalidProducerPropertiesExpressionFaultType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns3:InvalidProducerPropertiesExpressionFaultType': */
class SOAP_CMAC ns3__InvalidProducerPropertiesExpressionFaultType : public ns4__BaseFaultType {
      public:
        /// Return unique type id SOAP_TYPE_ns3__InvalidProducerPropertiesExpressionFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_ns3__InvalidProducerPropertiesExpressionFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__InvalidProducerPropertiesExpressionFaultType, default initialized and not managed by a soap context
        virtual ns3__InvalidProducerPropertiesExpressionFaultType *soap_alloc(void) const { return SOAP_NEW(ns3__InvalidProducerPropertiesExpressionFaultType); }
      public:
        /// Constructor with initializations
        ns3__InvalidProducerPropertiesExpressionFaultType() { }
        virtual ~ns3__InvalidProducerPropertiesExpressionFaultType() { }
        /// Friend allocator used by soap_new_ns3__InvalidProducerPropertiesExpressionFaultType(struct soap*, int)
        friend SOAP_FMAC1 ns3__InvalidProducerPropertiesExpressionFaultType * SOAP_FMAC2 soap_instantiate_ns3__InvalidProducerPropertiesExpressionFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:402 */
#ifndef SOAP_TYPE_ns3__InvalidMessageContentExpressionFaultType
#define SOAP_TYPE_ns3__InvalidMessageContentExpressionFaultType (75)
/* Type ns3__InvalidMessageContentExpressionFaultType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns3:InvalidMessageContentExpressionFaultType': */
class SOAP_CMAC ns3__InvalidMessageContentExpressionFaultType : public ns4__BaseFaultType {
      public:
        /// Return unique type id SOAP_TYPE_ns3__InvalidMessageContentExpressionFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_ns3__InvalidMessageContentExpressionFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__InvalidMessageContentExpressionFaultType, default initialized and not managed by a soap context
        virtual ns3__InvalidMessageContentExpressionFaultType *soap_alloc(void) const { return SOAP_NEW(ns3__InvalidMessageContentExpressionFaultType); }
      public:
        /// Constructor with initializations
        ns3__InvalidMessageContentExpressionFaultType() { }
        virtual ~ns3__InvalidMessageContentExpressionFaultType() { }
        /// Friend allocator used by soap_new_ns3__InvalidMessageContentExpressionFaultType(struct soap*, int)
        friend SOAP_FMAC1 ns3__InvalidMessageContentExpressionFaultType * SOAP_FMAC2 soap_instantiate_ns3__InvalidMessageContentExpressionFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:405 */
#ifndef SOAP_TYPE_ns3__UnrecognizedPolicyRequestFaultType
#define SOAP_TYPE_ns3__UnrecognizedPolicyRequestFaultType (76)
/* Type ns3__UnrecognizedPolicyRequestFaultType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns3:UnrecognizedPolicyRequestFaultType': */
class SOAP_CMAC ns3__UnrecognizedPolicyRequestFaultType : public ns4__BaseFaultType {
      public:
        /// Optional element 'ns3:UnrecognizedPolicy' of XSD type 'xsd:QName'
        std::vector<std::string> UnrecognizedPolicy;
      public:
        /// Return unique type id SOAP_TYPE_ns3__UnrecognizedPolicyRequestFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_ns3__UnrecognizedPolicyRequestFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__UnrecognizedPolicyRequestFaultType, default initialized and not managed by a soap context
        virtual ns3__UnrecognizedPolicyRequestFaultType *soap_alloc(void) const { return SOAP_NEW(ns3__UnrecognizedPolicyRequestFaultType); }
      public:
        /// Constructor with initializations
        ns3__UnrecognizedPolicyRequestFaultType() : UnrecognizedPolicy() { }
        virtual ~ns3__UnrecognizedPolicyRequestFaultType() { }
        /// Friend allocator used by soap_new_ns3__UnrecognizedPolicyRequestFaultType(struct soap*, int)
        friend SOAP_FMAC1 ns3__UnrecognizedPolicyRequestFaultType * SOAP_FMAC2 soap_instantiate_ns3__UnrecognizedPolicyRequestFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:408 */
#ifndef SOAP_TYPE_ns3__UnsupportedPolicyRequestFaultType
#define SOAP_TYPE_ns3__UnsupportedPolicyRequestFaultType (77)
/* Type ns3__UnsupportedPolicyRequestFaultType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns3:UnsupportedPolicyRequestFaultType': */
class SOAP_CMAC ns3__UnsupportedPolicyRequestFaultType : public ns4__BaseFaultType {
      public:
        /// Optional element 'ns3:UnsupportedPolicy' of XSD type 'xsd:QName'
        std::vector<std::string> UnsupportedPolicy;
      public:
        /// Return unique type id SOAP_TYPE_ns3__UnsupportedPolicyRequestFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_ns3__UnsupportedPolicyRequestFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__UnsupportedPolicyRequestFaultType, default initialized and not managed by a soap context
        virtual ns3__UnsupportedPolicyRequestFaultType *soap_alloc(void) const { return SOAP_NEW(ns3__UnsupportedPolicyRequestFaultType); }
      public:
        /// Constructor with initializations
        ns3__UnsupportedPolicyRequestFaultType() : UnsupportedPolicy() { }
        virtual ~ns3__UnsupportedPolicyRequestFaultType() { }
        /// Friend allocator used by soap_new_ns3__UnsupportedPolicyRequestFaultType(struct soap*, int)
        friend SOAP_FMAC1 ns3__UnsupportedPolicyRequestFaultType * SOAP_FMAC2 soap_instantiate_ns3__UnsupportedPolicyRequestFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:411 */
#ifndef SOAP_TYPE_ns3__NotifyMessageNotSupportedFaultType
#define SOAP_TYPE_ns3__NotifyMessageNotSupportedFaultType (78)
/* Type ns3__NotifyMessageNotSupportedFaultType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns3:NotifyMessageNotSupportedFaultType': */
class SOAP_CMAC ns3__NotifyMessageNotSupportedFaultType : public ns4__BaseFaultType {
      public:
        /// Return unique type id SOAP_TYPE_ns3__NotifyMessageNotSupportedFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_ns3__NotifyMessageNotSupportedFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__NotifyMessageNotSupportedFaultType, default initialized and not managed by a soap context
        virtual ns3__NotifyMessageNotSupportedFaultType *soap_alloc(void) const { return SOAP_NEW(ns3__NotifyMessageNotSupportedFaultType); }
      public:
        /// Constructor with initializations
        ns3__NotifyMessageNotSupportedFaultType() { }
        virtual ~ns3__NotifyMessageNotSupportedFaultType() { }
        /// Friend allocator used by soap_new_ns3__NotifyMessageNotSupportedFaultType(struct soap*, int)
        friend SOAP_FMAC1 ns3__NotifyMessageNotSupportedFaultType * SOAP_FMAC2 soap_instantiate_ns3__NotifyMessageNotSupportedFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:414 */
#ifndef SOAP_TYPE_ns3__UnacceptableInitialTerminationTimeFaultType
#define SOAP_TYPE_ns3__UnacceptableInitialTerminationTimeFaultType (79)
/* Type ns3__UnacceptableInitialTerminationTimeFaultType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns3:UnacceptableInitialTerminationTimeFaultType': */
class SOAP_CMAC ns3__UnacceptableInitialTerminationTimeFaultType : public ns4__BaseFaultType {
      public:
        /// Required element 'ns3:MinimumTime' of XSD type 'xsd:dateTime'
        time_t MinimumTime;
        /// Optional element 'ns3:MaximumTime' of XSD type 'xsd:dateTime'
        time_t *MaximumTime;
      public:
        /// Return unique type id SOAP_TYPE_ns3__UnacceptableInitialTerminationTimeFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_ns3__UnacceptableInitialTerminationTimeFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__UnacceptableInitialTerminationTimeFaultType, default initialized and not managed by a soap context
        virtual ns3__UnacceptableInitialTerminationTimeFaultType *soap_alloc(void) const { return SOAP_NEW(ns3__UnacceptableInitialTerminationTimeFaultType); }
      public:
        /// Constructor with initializations
        ns3__UnacceptableInitialTerminationTimeFaultType() : MinimumTime(), MaximumTime() { }
        virtual ~ns3__UnacceptableInitialTerminationTimeFaultType() { }
        /// Friend allocator used by soap_new_ns3__UnacceptableInitialTerminationTimeFaultType(struct soap*, int)
        friend SOAP_FMAC1 ns3__UnacceptableInitialTerminationTimeFaultType * SOAP_FMAC2 soap_instantiate_ns3__UnacceptableInitialTerminationTimeFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:417 */
#ifndef SOAP_TYPE_ns3__NoCurrentMessageOnTopicFaultType
#define SOAP_TYPE_ns3__NoCurrentMessageOnTopicFaultType (80)
/* Type ns3__NoCurrentMessageOnTopicFaultType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns3:NoCurrentMessageOnTopicFaultType': */
class SOAP_CMAC ns3__NoCurrentMessageOnTopicFaultType : public ns4__BaseFaultType {
      public:
        /// Return unique type id SOAP_TYPE_ns3__NoCurrentMessageOnTopicFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_ns3__NoCurrentMessageOnTopicFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__NoCurrentMessageOnTopicFaultType, default initialized and not managed by a soap context
        virtual ns3__NoCurrentMessageOnTopicFaultType *soap_alloc(void) const { return SOAP_NEW(ns3__NoCurrentMessageOnTopicFaultType); }
      public:
        /// Constructor with initializations
        ns3__NoCurrentMessageOnTopicFaultType() { }
        virtual ~ns3__NoCurrentMessageOnTopicFaultType() { }
        /// Friend allocator used by soap_new_ns3__NoCurrentMessageOnTopicFaultType(struct soap*, int)
        friend SOAP_FMAC1 ns3__NoCurrentMessageOnTopicFaultType * SOAP_FMAC2 soap_instantiate_ns3__NoCurrentMessageOnTopicFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:420 */
#ifndef SOAP_TYPE_ns3__UnableToGetMessagesFaultType
#define SOAP_TYPE_ns3__UnableToGetMessagesFaultType (81)
/* Type ns3__UnableToGetMessagesFaultType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns3:UnableToGetMessagesFaultType': */
class SOAP_CMAC ns3__UnableToGetMessagesFaultType : public ns4__BaseFaultType {
      public:
        /// Return unique type id SOAP_TYPE_ns3__UnableToGetMessagesFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_ns3__UnableToGetMessagesFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__UnableToGetMessagesFaultType, default initialized and not managed by a soap context
        virtual ns3__UnableToGetMessagesFaultType *soap_alloc(void) const { return SOAP_NEW(ns3__UnableToGetMessagesFaultType); }
      public:
        /// Constructor with initializations
        ns3__UnableToGetMessagesFaultType() { }
        virtual ~ns3__UnableToGetMessagesFaultType() { }
        /// Friend allocator used by soap_new_ns3__UnableToGetMessagesFaultType(struct soap*, int)
        friend SOAP_FMAC1 ns3__UnableToGetMessagesFaultType * SOAP_FMAC2 soap_instantiate_ns3__UnableToGetMessagesFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:423 */
#ifndef SOAP_TYPE_ns3__UnableToDestroyPullPointFaultType
#define SOAP_TYPE_ns3__UnableToDestroyPullPointFaultType (82)
/* Type ns3__UnableToDestroyPullPointFaultType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns3:UnableToDestroyPullPointFaultType': */
class SOAP_CMAC ns3__UnableToDestroyPullPointFaultType : public ns4__BaseFaultType {
      public:
        /// Return unique type id SOAP_TYPE_ns3__UnableToDestroyPullPointFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_ns3__UnableToDestroyPullPointFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__UnableToDestroyPullPointFaultType, default initialized and not managed by a soap context
        virtual ns3__UnableToDestroyPullPointFaultType *soap_alloc(void) const { return SOAP_NEW(ns3__UnableToDestroyPullPointFaultType); }
      public:
        /// Constructor with initializations
        ns3__UnableToDestroyPullPointFaultType() { }
        virtual ~ns3__UnableToDestroyPullPointFaultType() { }
        /// Friend allocator used by soap_new_ns3__UnableToDestroyPullPointFaultType(struct soap*, int)
        friend SOAP_FMAC1 ns3__UnableToDestroyPullPointFaultType * SOAP_FMAC2 soap_instantiate_ns3__UnableToDestroyPullPointFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:426 */
#ifndef SOAP_TYPE_ns3__UnableToCreatePullPointFaultType
#define SOAP_TYPE_ns3__UnableToCreatePullPointFaultType (83)
/* Type ns3__UnableToCreatePullPointFaultType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns3:UnableToCreatePullPointFaultType': */
class SOAP_CMAC ns3__UnableToCreatePullPointFaultType : public ns4__BaseFaultType {
      public:
        /// Return unique type id SOAP_TYPE_ns3__UnableToCreatePullPointFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_ns3__UnableToCreatePullPointFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__UnableToCreatePullPointFaultType, default initialized and not managed by a soap context
        virtual ns3__UnableToCreatePullPointFaultType *soap_alloc(void) const { return SOAP_NEW(ns3__UnableToCreatePullPointFaultType); }
      public:
        /// Constructor with initializations
        ns3__UnableToCreatePullPointFaultType() { }
        virtual ~ns3__UnableToCreatePullPointFaultType() { }
        /// Friend allocator used by soap_new_ns3__UnableToCreatePullPointFaultType(struct soap*, int)
        friend SOAP_FMAC1 ns3__UnableToCreatePullPointFaultType * SOAP_FMAC2 soap_instantiate_ns3__UnableToCreatePullPointFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:429 */
#ifndef SOAP_TYPE_ns3__UnacceptableTerminationTimeFaultType
#define SOAP_TYPE_ns3__UnacceptableTerminationTimeFaultType (84)
/* Type ns3__UnacceptableTerminationTimeFaultType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns3:UnacceptableTerminationTimeFaultType': */
class SOAP_CMAC ns3__UnacceptableTerminationTimeFaultType : public ns4__BaseFaultType {
      public:
        /// Required element 'ns3:MinimumTime' of XSD type 'xsd:dateTime'
        time_t MinimumTime;
        /// Optional element 'ns3:MaximumTime' of XSD type 'xsd:dateTime'
        time_t *MaximumTime;
      public:
        /// Return unique type id SOAP_TYPE_ns3__UnacceptableTerminationTimeFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_ns3__UnacceptableTerminationTimeFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__UnacceptableTerminationTimeFaultType, default initialized and not managed by a soap context
        virtual ns3__UnacceptableTerminationTimeFaultType *soap_alloc(void) const { return SOAP_NEW(ns3__UnacceptableTerminationTimeFaultType); }
      public:
        /// Constructor with initializations
        ns3__UnacceptableTerminationTimeFaultType() : MinimumTime(), MaximumTime() { }
        virtual ~ns3__UnacceptableTerminationTimeFaultType() { }
        /// Friend allocator used by soap_new_ns3__UnacceptableTerminationTimeFaultType(struct soap*, int)
        friend SOAP_FMAC1 ns3__UnacceptableTerminationTimeFaultType * SOAP_FMAC2 soap_instantiate_ns3__UnacceptableTerminationTimeFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:432 */
#ifndef SOAP_TYPE_ns3__UnableToDestroySubscriptionFaultType
#define SOAP_TYPE_ns3__UnableToDestroySubscriptionFaultType (85)
/* Type ns3__UnableToDestroySubscriptionFaultType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns3:UnableToDestroySubscriptionFaultType': */
class SOAP_CMAC ns3__UnableToDestroySubscriptionFaultType : public ns4__BaseFaultType {
      public:
        /// Return unique type id SOAP_TYPE_ns3__UnableToDestroySubscriptionFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_ns3__UnableToDestroySubscriptionFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__UnableToDestroySubscriptionFaultType, default initialized and not managed by a soap context
        virtual ns3__UnableToDestroySubscriptionFaultType *soap_alloc(void) const { return SOAP_NEW(ns3__UnableToDestroySubscriptionFaultType); }
      public:
        /// Constructor with initializations
        ns3__UnableToDestroySubscriptionFaultType() { }
        virtual ~ns3__UnableToDestroySubscriptionFaultType() { }
        /// Friend allocator used by soap_new_ns3__UnableToDestroySubscriptionFaultType(struct soap*, int)
        friend SOAP_FMAC1 ns3__UnableToDestroySubscriptionFaultType * SOAP_FMAC2 soap_instantiate_ns3__UnableToDestroySubscriptionFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:435 */
#ifndef SOAP_TYPE_ns3__PauseFailedFaultType
#define SOAP_TYPE_ns3__PauseFailedFaultType (86)
/* Type ns3__PauseFailedFaultType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns3:PauseFailedFaultType': */
class SOAP_CMAC ns3__PauseFailedFaultType : public ns4__BaseFaultType {
      public:
        /// Return unique type id SOAP_TYPE_ns3__PauseFailedFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_ns3__PauseFailedFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__PauseFailedFaultType, default initialized and not managed by a soap context
        virtual ns3__PauseFailedFaultType *soap_alloc(void) const { return SOAP_NEW(ns3__PauseFailedFaultType); }
      public:
        /// Constructor with initializations
        ns3__PauseFailedFaultType() { }
        virtual ~ns3__PauseFailedFaultType() { }
        /// Friend allocator used by soap_new_ns3__PauseFailedFaultType(struct soap*, int)
        friend SOAP_FMAC1 ns3__PauseFailedFaultType * SOAP_FMAC2 soap_instantiate_ns3__PauseFailedFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:438 */
#ifndef SOAP_TYPE_ns3__ResumeFailedFaultType
#define SOAP_TYPE_ns3__ResumeFailedFaultType (87)
/* Type ns3__ResumeFailedFaultType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns3:ResumeFailedFaultType': */
class SOAP_CMAC ns3__ResumeFailedFaultType : public ns4__BaseFaultType {
      public:
        /// Return unique type id SOAP_TYPE_ns3__ResumeFailedFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_ns3__ResumeFailedFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__ResumeFailedFaultType, default initialized and not managed by a soap context
        virtual ns3__ResumeFailedFaultType *soap_alloc(void) const { return SOAP_NEW(ns3__ResumeFailedFaultType); }
      public:
        /// Constructor with initializations
        ns3__ResumeFailedFaultType() { }
        virtual ~ns3__ResumeFailedFaultType() { }
        /// Friend allocator used by soap_new_ns3__ResumeFailedFaultType(struct soap*, int)
        friend SOAP_FMAC1 ns3__ResumeFailedFaultType * SOAP_FMAC2 soap_instantiate_ns3__ResumeFailedFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:684 */
#ifndef SOAP_TYPE_ns6__RelatesToType
#define SOAP_TYPE_ns6__RelatesToType (169)
/* Type ns6__RelatesToType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'ns6:RelatesToType': */
class SOAP_CMAC ns6__RelatesToType : public soap_dom_element {
      public:
        /// Simple content of XSD type 'xsd:anyURI' wrapped by this struct
        std::string __item;
        /// optional attribute 'RelationshipType' of XSD type 'ns6:RelationshipTypeOpenEnum'
        std::string RelationshipType;	///< initialized with default value = "http://www.w3.org/2005/08/addressing/reply"
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_ns6__RelatesToType
        virtual long soap_type(void) const { return SOAP_TYPE_ns6__RelatesToType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns6__RelatesToType, default initialized and not managed by a soap context
        virtual ns6__RelatesToType *soap_alloc(void) const { return SOAP_NEW(ns6__RelatesToType); }
      public:
        /// Constructor with initializations
        ns6__RelatesToType() : __item(), RelationshipType("http://www.w3.org/2005/08/addressing/reply"), __anyAttribute() { }
        virtual ~ns6__RelatesToType() { }
        /// Friend allocator used by soap_new_ns6__RelatesToType(struct soap*, int)
        friend SOAP_FMAC1 ns6__RelatesToType * SOAP_FMAC2 soap_instantiate_ns6__RelatesToType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:687 */
#ifndef SOAP_TYPE_ns6__AttributedURIType
#define SOAP_TYPE_ns6__AttributedURIType (170)
/* Type ns6__AttributedURIType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'ns6:AttributedURIType': */
class SOAP_CMAC ns6__AttributedURIType : public soap_dom_element {
      public:
        /// Simple content of XSD type 'xsd:anyURI' wrapped by this struct
        std::string __item;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_ns6__AttributedURIType
        virtual long soap_type(void) const { return SOAP_TYPE_ns6__AttributedURIType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns6__AttributedURIType, default initialized and not managed by a soap context
        virtual ns6__AttributedURIType *soap_alloc(void) const { return SOAP_NEW(ns6__AttributedURIType); }
      public:
        /// Constructor with initializations
        ns6__AttributedURIType() : __item(), __anyAttribute() { }
        virtual ~ns6__AttributedURIType() { }
        /// Friend allocator used by soap_new_ns6__AttributedURIType(struct soap*, int)
        friend SOAP_FMAC1 ns6__AttributedURIType * SOAP_FMAC2 soap_instantiate_ns6__AttributedURIType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:690 */
#ifndef SOAP_TYPE_ns6__AttributedUnsignedLongType
#define SOAP_TYPE_ns6__AttributedUnsignedLongType (171)
/* Type ns6__AttributedUnsignedLongType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'ns6:AttributedUnsignedLongType': */
class SOAP_CMAC ns6__AttributedUnsignedLongType : public soap_dom_element {
      public:
        /// Simple content of XSD type 'xsd:unsignedLong' wrapped by this struct
        ULONG64 __item;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_ns6__AttributedUnsignedLongType
        virtual long soap_type(void) const { return SOAP_TYPE_ns6__AttributedUnsignedLongType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns6__AttributedUnsignedLongType, default initialized and not managed by a soap context
        virtual ns6__AttributedUnsignedLongType *soap_alloc(void) const { return SOAP_NEW(ns6__AttributedUnsignedLongType); }
      public:
        /// Constructor with initializations
        ns6__AttributedUnsignedLongType() : __item(), __anyAttribute() { }
        virtual ~ns6__AttributedUnsignedLongType() { }
        /// Friend allocator used by soap_new_ns6__AttributedUnsignedLongType(struct soap*, int)
        friend SOAP_FMAC1 ns6__AttributedUnsignedLongType * SOAP_FMAC2 soap_instantiate_ns6__AttributedUnsignedLongType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:693 */
#ifndef SOAP_TYPE_ns6__AttributedQNameType
#define SOAP_TYPE_ns6__AttributedQNameType (172)
/* Type ns6__AttributedQNameType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'ns6:AttributedQNameType': */
class SOAP_CMAC ns6__AttributedQNameType : public soap_dom_element {
      public:
        /// Simple content of XSD type 'xsd:QName' wrapped by this struct
        std::string __item;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_ns6__AttributedQNameType
        virtual long soap_type(void) const { return SOAP_TYPE_ns6__AttributedQNameType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns6__AttributedQNameType, default initialized and not managed by a soap context
        virtual ns6__AttributedQNameType *soap_alloc(void) const { return SOAP_NEW(ns6__AttributedQNameType); }
      public:
        /// Constructor with initializations
        ns6__AttributedQNameType() : __item(), __anyAttribute() { }
        virtual ~ns6__AttributedQNameType() { }
        /// Friend allocator used by soap_new_ns6__AttributedQNameType(struct soap*, int)
        friend SOAP_FMAC1 ns6__AttributedQNameType * SOAP_FMAC2 soap_instantiate_ns6__AttributedQNameType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:6331 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (270)
/* SOAP_ENV__Detail: */
struct SOAP_CMAC SOAP_ENV__Detail {
      public:
        /** XML DOM attribute list */
        struct soap_dom_attribute __anyAttribute;
        /** Optional element 'ns1:InvalidScheduleFault' of XSD type 'ns1:InvalidScheduleFault' */
        _ns1__InvalidScheduleFault *ns1__InvalidScheduleFault;
        /** Optional element 'ns1:InvalidScheduledEventIDFault' of XSD type 'ns1:InvalidScheduledEventIDFault' */
        _ns1__InvalidScheduledEventIDFault *ns1__InvalidScheduledEventIDFault;
        /** Optional element 'ns1:ScheduledEventAlreadyExistsFault' of XSD type 'ns1:ScheduledEventAlreadyExistsFault' */
        _ns1__ScheduledEventAlreadyExistsFault *ns1__ScheduledEventAlreadyExistsFault;
        /** Optional element 'ns1:ScheduledEventNotFoundFault' of XSD type 'ns1:ScheduledEventNotFoundFault' */
        _ns1__ScheduledEventNotFoundFault *ns1__ScheduledEventNotFoundFault;
        /** Optional element 'ns5:ActionConfigurationIsInUseFault' of XSD type 'ns5:ActionConfigurationIsInUseFault' */
        _ns5__ActionConfigurationIsInUseFault *ns5__ActionConfigurationIsInUseFault;
        /** Optional element 'ns5:ActionConfigurationNotFoundFault' of XSD type 'ns5:ActionConfigurationNotFoundFault' */
        _ns5__ActionConfigurationNotFoundFault *ns5__ActionConfigurationNotFoundFault;
        /** Optional element 'ns5:ActionRuleNotFoundFault' of XSD type 'ns5:ActionRuleNotFoundFault' */
        _ns5__ActionRuleNotFoundFault *ns5__ActionRuleNotFoundFault;
        /** Optional element 'ns5:ActionTemplateNotFoundFault' of XSD type 'ns5:ActionTemplateNotFoundFault' */
        _ns5__ActionTemplateNotFoundFault *ns5__ActionTemplateNotFoundFault;
        /** Optional element 'ns5:InsufficientActivationRuleFault' of XSD type 'ns5:InsufficientActivationRuleFault' */
        _ns5__InsufficientActivationRuleFault *ns5__InsufficientActivationRuleFault;
        /** Optional element 'ns5:InvalidActionConfigurationFault' of XSD type 'ns5:InvalidActionConfigurationFault' */
        _ns5__InvalidActionConfigurationFault *ns5__InvalidActionConfigurationFault;
        /** Optional element 'ns5:InvalidActivationTimeoutFault' of XSD type 'ns5:InvalidActivationTimeoutFault' */
        _ns5__InvalidActivationTimeoutFault *ns5__InvalidActivationTimeoutFault;
        /** Optional element 'ns5:InvalidConditionFilterFault' of XSD type 'ns5:InvalidConditionFilterFault' */
        _ns5__InvalidConditionFilterFault *ns5__InvalidConditionFilterFault;
        /** Optional element 'ns3:InvalidFilterFault' of XSD type 'ns3:InvalidFilterFaultType' */
        ns3__InvalidFilterFaultType *ns3__InvalidFilterFault;
        /** Optional element 'ns3:InvalidMessageContentExpressionFault' of XSD type 'ns3:InvalidMessageContentExpressionFaultType' */
        ns3__InvalidMessageContentExpressionFaultType *ns3__InvalidMessageContentExpressionFault;
        /** Optional element 'ns3:InvalidTopicExpressionFault' of XSD type 'ns3:InvalidTopicExpressionFaultType' */
        ns3__InvalidTopicExpressionFaultType *ns3__InvalidTopicExpressionFault;
        /** Optional element 'ns5:ParametersMissmatchFault' of XSD type 'ns5:ParametersMissmatchFault' */
        _ns5__ParametersMissmatchFault *ns5__ParametersMissmatchFault;
        /** Optional element 'ns5:RecipientConfigurationNotFoundFault' of XSD type 'ns5:RecipientConfigurationNotFoundFault' */
        _ns5__RecipientConfigurationNotFoundFault *ns5__RecipientConfigurationNotFoundFault;
        /** Optional element 'ns5:RecipientTemplateNotFoundFault' of XSD type 'ns5:RecipientTemplateNotFoundFault' */
        _ns5__RecipientTemplateNotFoundFault *ns5__RecipientTemplateNotFoundFault;
        /** Optional element 'ns3:TopicExpressionDialectUnknownFault' of XSD type 'ns3:TopicExpressionDialectUnknownFaultType' */
        ns3__TopicExpressionDialectUnknownFaultType *ns3__TopicExpressionDialectUnknownFault;
        /** Any type of element 'fault' assigned to fault with its SOAP_TYPE_T assigned to __type */
        /** Do not create a cyclic data structure throught this member unless SOAP encoding or SOAP_XML_GRAPH are used for id-ref serialization */
        int __type;
        void *fault;
        char *__any;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Detail */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Detail; }
        /** Constructor with member initializations */
        SOAP_ENV__Detail() : __anyAttribute(), ns1__InvalidScheduleFault(), ns1__InvalidScheduledEventIDFault(), ns1__ScheduledEventAlreadyExistsFault(), ns1__ScheduledEventNotFoundFault(), ns5__ActionConfigurationIsInUseFault(), ns5__ActionConfigurationNotFoundFault(), ns5__ActionRuleNotFoundFault(), ns5__ActionTemplateNotFoundFault(), ns5__InsufficientActivationRuleFault(), ns5__InvalidActionConfigurationFault(), ns5__InvalidActivationTimeoutFault(), ns5__InvalidConditionFilterFault(), ns3__InvalidFilterFault(), ns3__InvalidMessageContentExpressionFault(), ns3__InvalidTopicExpressionFault(), ns5__ParametersMissmatchFault(), ns5__RecipientConfigurationNotFoundFault(), ns5__RecipientTemplateNotFoundFault(), ns3__TopicExpressionDialectUnknownFault(), __type(), fault(), __any() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* generated_with_wsdl2h/axis_soap_event_action:6454 */
#ifndef SOAP_TYPE___ns1__GetEventInstances
#define SOAP_TYPE___ns1__GetEventInstances (295)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetEventInstances {
      public:
        /** Optional element 'ns1:GetEventInstances' of XSD type 'ns1:GetEventInstances' */
        _ns1__GetEventInstances *ns1__GetEventInstances;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetEventInstances */
        long soap_type() const { return SOAP_TYPE___ns1__GetEventInstances; }
        /** Constructor with member initializations */
        __ns1__GetEventInstances() : ns1__GetEventInstances() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GetEventInstances * SOAP_FMAC2 soap_instantiate___ns1__GetEventInstances(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:6534 */
#ifndef SOAP_TYPE___ns1__AddScheduledEvent
#define SOAP_TYPE___ns1__AddScheduledEvent (299)
/* Wrapper: */
struct SOAP_CMAC __ns1__AddScheduledEvent {
      public:
        /** Optional element 'ns1:AddScheduledEvent' of XSD type 'ns1:AddScheduledEvent' */
        _ns1__AddScheduledEvent *ns1__AddScheduledEvent;
      public:
        /** Return unique type id SOAP_TYPE___ns1__AddScheduledEvent */
        long soap_type() const { return SOAP_TYPE___ns1__AddScheduledEvent; }
        /** Constructor with member initializations */
        __ns1__AddScheduledEvent() : ns1__AddScheduledEvent() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__AddScheduledEvent * SOAP_FMAC2 soap_instantiate___ns1__AddScheduledEvent(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:6607 */
#ifndef SOAP_TYPE___ns1__RemoveScheduledEvent
#define SOAP_TYPE___ns1__RemoveScheduledEvent (303)
/* Wrapper: */
struct SOAP_CMAC __ns1__RemoveScheduledEvent {
      public:
        /** Optional element 'ns1:RemoveScheduledEvent' of XSD type 'ns1:RemoveScheduledEvent' */
        _ns1__RemoveScheduledEvent *ns1__RemoveScheduledEvent;
      public:
        /** Return unique type id SOAP_TYPE___ns1__RemoveScheduledEvent */
        long soap_type() const { return SOAP_TYPE___ns1__RemoveScheduledEvent; }
        /** Constructor with member initializations */
        __ns1__RemoveScheduledEvent() : ns1__RemoveScheduledEvent() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__RemoveScheduledEvent * SOAP_FMAC2 soap_instantiate___ns1__RemoveScheduledEvent(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:6677 */
#ifndef SOAP_TYPE___ns1__GetScheduledEvents
#define SOAP_TYPE___ns1__GetScheduledEvents (307)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetScheduledEvents {
      public:
        /** Optional element 'ns1:GetScheduledEvents' of XSD type 'ns1:GetScheduledEvents' */
        _ns1__GetScheduledEvents *ns1__GetScheduledEvents;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetScheduledEvents */
        long soap_type() const { return SOAP_TYPE___ns1__GetScheduledEvents; }
        /** Constructor with member initializations */
        __ns1__GetScheduledEvents() : ns1__GetScheduledEvents() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GetScheduledEvents * SOAP_FMAC2 soap_instantiate___ns1__GetScheduledEvents(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:6747 */
#ifndef SOAP_TYPE___ns1__ChangeVirtualInputState
#define SOAP_TYPE___ns1__ChangeVirtualInputState (311)
/* Wrapper: */
struct SOAP_CMAC __ns1__ChangeVirtualInputState {
      public:
        /** Optional element 'ns1:ChangeVirtualInputState' of XSD type 'ns1:ChangeVirtualInputState' */
        _ns1__ChangeVirtualInputState *ns1__ChangeVirtualInputState;
      public:
        /** Return unique type id SOAP_TYPE___ns1__ChangeVirtualInputState */
        long soap_type() const { return SOAP_TYPE___ns1__ChangeVirtualInputState; }
        /** Constructor with member initializations */
        __ns1__ChangeVirtualInputState() : ns1__ChangeVirtualInputState() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__ChangeVirtualInputState * SOAP_FMAC2 soap_instantiate___ns1__ChangeVirtualInputState(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:6835 */
#ifndef SOAP_TYPE___ns5__GetActionTemplates
#define SOAP_TYPE___ns5__GetActionTemplates (315)
/* Wrapper: */
struct SOAP_CMAC __ns5__GetActionTemplates {
      public:
        /** Optional element 'ns5:GetActionTemplates' of XSD type 'ns5:GetActionTemplates' */
        _ns5__GetActionTemplates *ns5__GetActionTemplates;
      public:
        /** Return unique type id SOAP_TYPE___ns5__GetActionTemplates */
        long soap_type() const { return SOAP_TYPE___ns5__GetActionTemplates; }
        /** Constructor with member initializations */
        __ns5__GetActionTemplates() : ns5__GetActionTemplates() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns5__GetActionTemplates * SOAP_FMAC2 soap_instantiate___ns5__GetActionTemplates(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:6914 */
#ifndef SOAP_TYPE___ns5__AddActionConfiguration
#define SOAP_TYPE___ns5__AddActionConfiguration (319)
/* Wrapper: */
struct SOAP_CMAC __ns5__AddActionConfiguration {
      public:
        /** Optional element 'ns5:AddActionConfiguration' of XSD type 'ns5:AddActionConfiguration' */
        _ns5__AddActionConfiguration *ns5__AddActionConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___ns5__AddActionConfiguration */
        long soap_type() const { return SOAP_TYPE___ns5__AddActionConfiguration; }
        /** Constructor with member initializations */
        __ns5__AddActionConfiguration() : ns5__AddActionConfiguration() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns5__AddActionConfiguration * SOAP_FMAC2 soap_instantiate___ns5__AddActionConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:6990 */
#ifndef SOAP_TYPE___ns5__RemoveActionConfiguration
#define SOAP_TYPE___ns5__RemoveActionConfiguration (323)
/* Wrapper: */
struct SOAP_CMAC __ns5__RemoveActionConfiguration {
      public:
        /** Optional element 'ns5:RemoveActionConfiguration' of XSD type 'ns5:RemoveActionConfiguration' */
        _ns5__RemoveActionConfiguration *ns5__RemoveActionConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___ns5__RemoveActionConfiguration */
        long soap_type() const { return SOAP_TYPE___ns5__RemoveActionConfiguration; }
        /** Constructor with member initializations */
        __ns5__RemoveActionConfiguration() : ns5__RemoveActionConfiguration() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns5__RemoveActionConfiguration * SOAP_FMAC2 soap_instantiate___ns5__RemoveActionConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:7060 */
#ifndef SOAP_TYPE___ns5__GetActionConfigurations
#define SOAP_TYPE___ns5__GetActionConfigurations (327)
/* Wrapper: */
struct SOAP_CMAC __ns5__GetActionConfigurations {
      public:
        /** Optional element 'ns5:GetActionConfigurations' of XSD type 'ns5:GetActionConfigurations' */
        _ns5__GetActionConfigurations *ns5__GetActionConfigurations;
      public:
        /** Return unique type id SOAP_TYPE___ns5__GetActionConfigurations */
        long soap_type() const { return SOAP_TYPE___ns5__GetActionConfigurations; }
        /** Constructor with member initializations */
        __ns5__GetActionConfigurations() : ns5__GetActionConfigurations() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns5__GetActionConfigurations * SOAP_FMAC2 soap_instantiate___ns5__GetActionConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:7130 */
#ifndef SOAP_TYPE___ns5__GetRecipientTemplates
#define SOAP_TYPE___ns5__GetRecipientTemplates (331)
/* Wrapper: */
struct SOAP_CMAC __ns5__GetRecipientTemplates {
      public:
        /** Optional element 'ns5:GetRecipientTemplates' of XSD type 'ns5:GetRecipientTemplates' */
        _ns5__GetRecipientTemplates *ns5__GetRecipientTemplates;
      public:
        /** Return unique type id SOAP_TYPE___ns5__GetRecipientTemplates */
        long soap_type() const { return SOAP_TYPE___ns5__GetRecipientTemplates; }
        /** Constructor with member initializations */
        __ns5__GetRecipientTemplates() : ns5__GetRecipientTemplates() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns5__GetRecipientTemplates * SOAP_FMAC2 soap_instantiate___ns5__GetRecipientTemplates(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:7206 */
#ifndef SOAP_TYPE___ns5__AddRecipientConfiguration
#define SOAP_TYPE___ns5__AddRecipientConfiguration (335)
/* Wrapper: */
struct SOAP_CMAC __ns5__AddRecipientConfiguration {
      public:
        /** Optional element 'ns5:AddRecipientConfiguration' of XSD type 'ns5:AddRecipientConfiguration' */
        _ns5__AddRecipientConfiguration *ns5__AddRecipientConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___ns5__AddRecipientConfiguration */
        long soap_type() const { return SOAP_TYPE___ns5__AddRecipientConfiguration; }
        /** Constructor with member initializations */
        __ns5__AddRecipientConfiguration() : ns5__AddRecipientConfiguration() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns5__AddRecipientConfiguration * SOAP_FMAC2 soap_instantiate___ns5__AddRecipientConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:7279 */
#ifndef SOAP_TYPE___ns5__RemoveRecipientConfiguration
#define SOAP_TYPE___ns5__RemoveRecipientConfiguration (339)
/* Wrapper: */
struct SOAP_CMAC __ns5__RemoveRecipientConfiguration {
      public:
        /** Optional element 'ns5:RemoveRecipientConfiguration' of XSD type 'ns5:RemoveRecipientConfiguration' */
        _ns5__RemoveRecipientConfiguration *ns5__RemoveRecipientConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___ns5__RemoveRecipientConfiguration */
        long soap_type() const { return SOAP_TYPE___ns5__RemoveRecipientConfiguration; }
        /** Constructor with member initializations */
        __ns5__RemoveRecipientConfiguration() : ns5__RemoveRecipientConfiguration() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns5__RemoveRecipientConfiguration * SOAP_FMAC2 soap_instantiate___ns5__RemoveRecipientConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:7349 */
#ifndef SOAP_TYPE___ns5__GetRecipientConfigurations
#define SOAP_TYPE___ns5__GetRecipientConfigurations (343)
/* Wrapper: */
struct SOAP_CMAC __ns5__GetRecipientConfigurations {
      public:
        /** Optional element 'ns5:GetRecipientConfigurations' of XSD type 'ns5:GetRecipientConfigurations' */
        _ns5__GetRecipientConfigurations *ns5__GetRecipientConfigurations;
      public:
        /** Return unique type id SOAP_TYPE___ns5__GetRecipientConfigurations */
        long soap_type() const { return SOAP_TYPE___ns5__GetRecipientConfigurations; }
        /** Constructor with member initializations */
        __ns5__GetRecipientConfigurations() : ns5__GetRecipientConfigurations() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns5__GetRecipientConfigurations * SOAP_FMAC2 soap_instantiate___ns5__GetRecipientConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:7443 */
#ifndef SOAP_TYPE___ns5__AddActionRule
#define SOAP_TYPE___ns5__AddActionRule (347)
/* Wrapper: */
struct SOAP_CMAC __ns5__AddActionRule {
      public:
        /** Optional element 'ns5:AddActionRule' of XSD type 'ns5:AddActionRule' */
        _ns5__AddActionRule *ns5__AddActionRule;
      public:
        /** Return unique type id SOAP_TYPE___ns5__AddActionRule */
        long soap_type() const { return SOAP_TYPE___ns5__AddActionRule; }
        /** Constructor with member initializations */
        __ns5__AddActionRule() : ns5__AddActionRule() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns5__AddActionRule * SOAP_FMAC2 soap_instantiate___ns5__AddActionRule(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:7513 */
#ifndef SOAP_TYPE___ns5__GetActionRules
#define SOAP_TYPE___ns5__GetActionRules (351)
/* Wrapper: */
struct SOAP_CMAC __ns5__GetActionRules {
      public:
        /** Optional element 'ns5:GetActionRules' of XSD type 'ns5:GetActionRules' */
        _ns5__GetActionRules *ns5__GetActionRules;
      public:
        /** Return unique type id SOAP_TYPE___ns5__GetActionRules */
        long soap_type() const { return SOAP_TYPE___ns5__GetActionRules; }
        /** Constructor with member initializations */
        __ns5__GetActionRules() : ns5__GetActionRules() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns5__GetActionRules * SOAP_FMAC2 soap_instantiate___ns5__GetActionRules(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:7586 */
#ifndef SOAP_TYPE___ns5__RemoveActionRule
#define SOAP_TYPE___ns5__RemoveActionRule (355)
/* Wrapper: */
struct SOAP_CMAC __ns5__RemoveActionRule {
      public:
        /** Optional element 'ns5:RemoveActionRule' of XSD type 'ns5:RemoveActionRule' */
        _ns5__RemoveActionRule *ns5__RemoveActionRule;
      public:
        /** Return unique type id SOAP_TYPE___ns5__RemoveActionRule */
        long soap_type() const { return SOAP_TYPE___ns5__RemoveActionRule; }
        /** Constructor with member initializations */
        __ns5__RemoveActionRule() : ns5__RemoveActionRule() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns5__RemoveActionRule * SOAP_FMAC2 soap_instantiate___ns5__RemoveActionRule(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated_with_wsdl2h/axis_soap_event_action:8796 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (356)
/* SOAP_ENV__Header: */
struct SOAP_CMAC SOAP_ENV__Header {
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Header */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Header; }
        /** Constructor with member initializations */
        SOAP_ENV__Header() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* generated_with_wsdl2h/axis_soap_event_action:8796 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (357)
/* Type SOAP_ENV__Code is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* SOAP_ENV__Code: */
struct SOAP_CMAC SOAP_ENV__Code {
      public:
        /** Optional element 'SOAP-ENV:Value' of XSD type 'xsd:QName' */
        char *SOAP_ENV__Value;
        /** Optional element 'SOAP-ENV:Subcode' of XSD type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Subcode;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Code */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Code; }
        /** Constructor with member initializations */
        SOAP_ENV__Code() : SOAP_ENV__Value(), SOAP_ENV__Subcode() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* generated_with_wsdl2h/axis_soap_event_action:8796 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (359)
/* SOAP_ENV__Reason: */
struct SOAP_CMAC SOAP_ENV__Reason {
      public:
        /** Optional element 'SOAP-ENV:Text' of XSD type 'xsd:string' */
        char *SOAP_ENV__Text;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Reason */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Reason; }
        /** Constructor with member initializations */
        SOAP_ENV__Reason() : SOAP_ENV__Text() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* generated_with_wsdl2h/axis_soap_event_action:8796 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (360)
/* SOAP_ENV__Fault: */
struct SOAP_CMAC SOAP_ENV__Fault {
      public:
        /** Optional element 'faultcode' of XSD type 'xsd:QName' */
        char *faultcode;
        /** Optional element 'faultstring' of XSD type 'xsd:string' */
        char *faultstring;
        /** Optional element 'faultactor' of XSD type 'xsd:string' */
        char *faultactor;
        /** Optional element 'detail' of XSD type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *detail;
        /** Optional element 'SOAP-ENV:Code' of XSD type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Code;
        /** Optional element 'SOAP-ENV:Reason' of XSD type 'SOAP-ENV:Reason' */
        struct SOAP_ENV__Reason *SOAP_ENV__Reason;
        /** Optional element 'SOAP-ENV:Node' of XSD type 'xsd:string' */
        char *SOAP_ENV__Node;
        /** Optional element 'SOAP-ENV:Role' of XSD type 'xsd:string' */
        char *SOAP_ENV__Role;
        /** Optional element 'SOAP-ENV:Detail' of XSD type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *SOAP_ENV__Detail;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Fault */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Fault; }
        /** Constructor with member initializations */
        SOAP_ENV__Fault() : faultcode(), faultstring(), faultactor(), detail(), SOAP_ENV__Code(), SOAP_ENV__Reason(), SOAP_ENV__Node(), SOAP_ENV__Role(), SOAP_ENV__Detail() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/


/* (built-in):0 */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (5)
typedef char *_XML;
#endif

/* (built-in):0 */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (6)
typedef char *_QName;
#endif

/* generated_with_wsdl2h/axis_soap_event_action:175 */
#ifndef SOAP_TYPE_xsd__NCName
#define SOAP_TYPE_xsd__NCName (15)
typedef std::string xsd__NCName;
#endif

/* generated_with_wsdl2h/axis_soap_event_action:192 */
#ifndef SOAP_TYPE_xsd__anyURI
#define SOAP_TYPE_xsd__anyURI (18)
typedef std::string xsd__anyURI;
#endif

/* generated_with_wsdl2h/axis_soap_event_action:216 */
#ifndef SOAP_TYPE_xsd__duration
#define SOAP_TYPE_xsd__duration (24)
typedef std::string xsd__duration;
#endif

/* generated_with_wsdl2h/axis_soap_event_action:233 */
#ifndef SOAP_TYPE_xsd__integer
#define SOAP_TYPE_xsd__integer (27)
typedef std::string xsd__integer;
#endif

/* generated_with_wsdl2h/axis_soap_event_action:243 */
#ifndef SOAP_TYPE_xsd__nonNegativeInteger
#define SOAP_TYPE_xsd__nonNegativeInteger (29)
typedef std::string xsd__nonNegativeInteger;
#endif

/* generated_with_wsdl2h/axis_soap_event_action:260 */
#ifndef SOAP_TYPE_xsd__token
#define SOAP_TYPE_xsd__token (32)
typedef std::string xsd__token;
#endif

/* generated_with_wsdl2h/axis_soap_event_action:277 */
#ifndef SOAP_TYPE__xml__lang
#define SOAP_TYPE__xml__lang (36)
typedef std::string _xml__lang;
#endif

/* generated_with_wsdl2h/axis_soap_event_action:723 */
#ifndef SOAP_TYPE_ns3__AbsoluteOrRelativeTimeType
#define SOAP_TYPE_ns3__AbsoluteOrRelativeTimeType (174)
typedef std::string ns3__AbsoluteOrRelativeTimeType;
#endif

/* generated_with_wsdl2h/axis_soap_event_action:750 */
#ifndef SOAP_TYPE_ns6__RelationshipTypeOpenEnum
#define SOAP_TYPE_ns6__RelationshipTypeOpenEnum (175)
typedef std::string ns6__RelationshipTypeOpenEnum;
#endif

/* generated_with_wsdl2h/axis_soap_event_action:753 */
#ifndef SOAP_TYPE_ns6__FaultCodesOpenEnumType
#define SOAP_TYPE_ns6__FaultCodesOpenEnumType (176)
typedef std::string ns6__FaultCodesOpenEnumType;
#endif

/* generated_with_wsdl2h/axis_soap_event_action:784 */
#ifndef SOAP_TYPE_ns2__FullTopicExpression
#define SOAP_TYPE_ns2__FullTopicExpression (179)
typedef std::string ns2__FullTopicExpression;
#endif

/* generated_with_wsdl2h/axis_soap_event_action:800 */
#ifndef SOAP_TYPE_ns2__ConcreteTopicExpression
#define SOAP_TYPE_ns2__ConcreteTopicExpression (181)
typedef std::string ns2__ConcreteTopicExpression;
#endif

/* generated_with_wsdl2h/axis_soap_event_action:815 */
#ifndef SOAP_TYPE_ns2__SimpleTopicExpression
#define SOAP_TYPE_ns2__SimpleTopicExpression (183)
typedef xsd__QName ns2__SimpleTopicExpression;
#endif

/******************************************************************************\
 *                                                                            *
 * Serializable Types                                                         *
 *                                                                            *
\******************************************************************************/


/* char has binding name 'byte' for type 'xsd:byte' */
#ifndef SOAP_TYPE_byte
#define SOAP_TYPE_byte (3)
#endif

/* int has binding name 'int' for type 'xsd:int' */
#ifndef SOAP_TYPE_int
#define SOAP_TYPE_int (1)
#endif

/* ULONG64 has binding name 'ULONG64' for type 'xsd:unsignedLong' */
#ifndef SOAP_TYPE_ULONG64
#define SOAP_TYPE_ULONG64 (35)
#endif

/* time_t has binding name 'dateTime' for type 'xsd:dateTime' */
#ifndef SOAP_TYPE_dateTime
#define SOAP_TYPE_dateTime (23)
#endif

/* bool has binding name 'bool' for type 'xsd:boolean' */
#ifndef SOAP_TYPE_bool
#define SOAP_TYPE_bool (21)
#endif

/* ns6__FaultCodesType has binding name 'ns6__FaultCodesType' for type 'ns6:FaultCodesType' */
#ifndef SOAP_TYPE_ns6__FaultCodesType
#define SOAP_TYPE_ns6__FaultCodesType (187)
#endif

/* ns6__RelationshipType has binding name 'ns6__RelationshipType' for type 'ns6:RelationshipType' */
#ifndef SOAP_TYPE_ns6__RelationshipType
#define SOAP_TYPE_ns6__RelationshipType (185)
#endif

/* ns1__ScheduledType has binding name 'ns1__ScheduledType' for type 'ns1:ScheduledType' */
#ifndef SOAP_TYPE_ns1__ScheduledType
#define SOAP_TYPE_ns1__ScheduledType (177)
#endif

/* _ns2__TopicNamespaceType_Topic has binding name '_ns2__TopicNamespaceType_Topic' for type '' */
#ifndef SOAP_TYPE__ns2__TopicNamespaceType_Topic
#define SOAP_TYPE__ns2__TopicNamespaceType_Topic (261)
#endif

/* _ns4__BaseFaultType_FaultCause has binding name '_ns4__BaseFaultType_FaultCause' for type '' */
#ifndef SOAP_TYPE__ns4__BaseFaultType_FaultCause
#define SOAP_TYPE__ns4__BaseFaultType_FaultCause (222)
#endif

/* _ns4__BaseFaultType_Description has binding name '_ns4__BaseFaultType_Description' for type '' */
#ifndef SOAP_TYPE__ns4__BaseFaultType_Description
#define SOAP_TYPE__ns4__BaseFaultType_Description (219)
#endif

/* _ns4__BaseFaultType_ErrorCode has binding name '_ns4__BaseFaultType_ErrorCode' for type '' */
#ifndef SOAP_TYPE__ns4__BaseFaultType_ErrorCode
#define SOAP_TYPE__ns4__BaseFaultType_ErrorCode (217)
#endif

/* _ns3__Subscribe_SubscriptionPolicy has binding name '_ns3__Subscribe_SubscriptionPolicy' for type '' */
#ifndef SOAP_TYPE__ns3__Subscribe_SubscriptionPolicy
#define SOAP_TYPE__ns3__Subscribe_SubscriptionPolicy (214)
#endif

/* _ns3__NotificationMessageHolderType_Message has binding name '_ns3__NotificationMessageHolderType_Message' for type '' */
#ifndef SOAP_TYPE__ns3__NotificationMessageHolderType_Message
#define SOAP_TYPE__ns3__NotificationMessageHolderType_Message (204)
#endif

/* ns6__FaultCodesType__ has binding name 'ns6__FaultCodesType__' for type 'ns6:FaultCodesType' */
#ifndef SOAP_TYPE_ns6__FaultCodesType__
#define SOAP_TYPE_ns6__FaultCodesType__ (188)
#endif

/* ns6__RelationshipType__ has binding name 'ns6__RelationshipType__' for type 'ns6:RelationshipType' */
#ifndef SOAP_TYPE_ns6__RelationshipType__
#define SOAP_TYPE_ns6__RelationshipType__ (186)
#endif

/* ns2__SimpleTopicExpression__ has binding name 'ns2__SimpleTopicExpression__' for type 'ns2:SimpleTopicExpression' */
#ifndef SOAP_TYPE_ns2__SimpleTopicExpression__
#define SOAP_TYPE_ns2__SimpleTopicExpression__ (184)
#endif

/* ns2__SimpleTopicExpression has binding name 'ns2__SimpleTopicExpression' for type 'xsd:QName' */
#ifndef SOAP_TYPE_ns2__SimpleTopicExpression
#define SOAP_TYPE_ns2__SimpleTopicExpression (183)
#endif

/* ns2__ConcreteTopicExpression__ has binding name 'ns2__ConcreteTopicExpression__' for type 'ns2:ConcreteTopicExpression' */
#ifndef SOAP_TYPE_ns2__ConcreteTopicExpression__
#define SOAP_TYPE_ns2__ConcreteTopicExpression__ (182)
#endif

/* ns2__ConcreteTopicExpression has binding name 'ns2__ConcreteTopicExpression' for type 'ns2:ConcreteTopicExpression' */
#ifndef SOAP_TYPE_ns2__ConcreteTopicExpression
#define SOAP_TYPE_ns2__ConcreteTopicExpression (181)
#endif

/* ns2__FullTopicExpression__ has binding name 'ns2__FullTopicExpression__' for type 'ns2:FullTopicExpression' */
#ifndef SOAP_TYPE_ns2__FullTopicExpression__
#define SOAP_TYPE_ns2__FullTopicExpression__ (180)
#endif

/* ns2__FullTopicExpression has binding name 'ns2__FullTopicExpression' for type 'ns2:FullTopicExpression' */
#ifndef SOAP_TYPE_ns2__FullTopicExpression
#define SOAP_TYPE_ns2__FullTopicExpression (179)
#endif

/* ns1__ScheduledType__ has binding name 'ns1__ScheduledType__' for type 'ns1:ScheduledType' */
#ifndef SOAP_TYPE_ns1__ScheduledType__
#define SOAP_TYPE_ns1__ScheduledType__ (178)
#endif

/* ns6__FaultCodesOpenEnumType has binding name 'ns6__FaultCodesOpenEnumType' for type 'ns6:FaultCodesOpenEnumType' */
#ifndef SOAP_TYPE_ns6__FaultCodesOpenEnumType
#define SOAP_TYPE_ns6__FaultCodesOpenEnumType (176)
#endif

/* ns6__RelationshipTypeOpenEnum has binding name 'ns6__RelationshipTypeOpenEnum' for type 'ns6:RelationshipTypeOpenEnum' */
#ifndef SOAP_TYPE_ns6__RelationshipTypeOpenEnum
#define SOAP_TYPE_ns6__RelationshipTypeOpenEnum (175)
#endif

/* ns3__AbsoluteOrRelativeTimeType has binding name 'ns3__AbsoluteOrRelativeTimeType' for type 'ns3:AbsoluteOrRelativeTimeType' */
#ifndef SOAP_TYPE_ns3__AbsoluteOrRelativeTimeType
#define SOAP_TYPE_ns3__AbsoluteOrRelativeTimeType (174)
#endif

/* ns6__ProblemActionType has binding name 'ns6__ProblemActionType' for type 'ns6:ProblemActionType' */
#ifndef SOAP_TYPE_ns6__ProblemActionType
#define SOAP_TYPE_ns6__ProblemActionType (173)
#endif

/* ns6__AttributedQNameType has binding name 'ns6__AttributedQNameType' for type 'ns6:AttributedQNameType' */
#ifndef SOAP_TYPE_ns6__AttributedQNameType
#define SOAP_TYPE_ns6__AttributedQNameType (172)
#endif

/* ns6__AttributedUnsignedLongType has binding name 'ns6__AttributedUnsignedLongType' for type 'ns6:AttributedUnsignedLongType' */
#ifndef SOAP_TYPE_ns6__AttributedUnsignedLongType
#define SOAP_TYPE_ns6__AttributedUnsignedLongType (171)
#endif

/* ns6__AttributedURIType has binding name 'ns6__AttributedURIType' for type 'ns6:AttributedURIType' */
#ifndef SOAP_TYPE_ns6__AttributedURIType
#define SOAP_TYPE_ns6__AttributedURIType (170)
#endif

/* ns6__RelatesToType has binding name 'ns6__RelatesToType' for type 'ns6:RelatesToType' */
#ifndef SOAP_TYPE_ns6__RelatesToType
#define SOAP_TYPE_ns6__RelatesToType (169)
#endif

/* ns6__MetadataType has binding name 'ns6__MetadataType' for type 'ns6:MetadataType' */
#ifndef SOAP_TYPE_ns6__MetadataType
#define SOAP_TYPE_ns6__MetadataType (168)
#endif

/* ns6__ReferenceParametersType has binding name 'ns6__ReferenceParametersType' for type 'ns6:ReferenceParametersType' */
#ifndef SOAP_TYPE_ns6__ReferenceParametersType
#define SOAP_TYPE_ns6__ReferenceParametersType (167)
#endif

/* ns6__EndpointReferenceType has binding name 'ns6__EndpointReferenceType' for type 'ns6:EndpointReferenceType' */
#ifndef SOAP_TYPE_ns6__EndpointReferenceType
#define SOAP_TYPE_ns6__EndpointReferenceType (166)
#endif

/* _ns5__InvalidActivationTimeoutFault has binding name '_ns5__InvalidActivationTimeoutFault' for type '' */
#ifndef SOAP_TYPE__ns5__InvalidActivationTimeoutFault
#define SOAP_TYPE__ns5__InvalidActivationTimeoutFault (165)
#endif

/* _ns5__ActionRuleNotFoundFault has binding name '_ns5__ActionRuleNotFoundFault' for type '' */
#ifndef SOAP_TYPE__ns5__ActionRuleNotFoundFault
#define SOAP_TYPE__ns5__ActionRuleNotFoundFault (164)
#endif

/* _ns5__InsufficientActivationRuleFault has binding name '_ns5__InsufficientActivationRuleFault' for type '' */
#ifndef SOAP_TYPE__ns5__InsufficientActivationRuleFault
#define SOAP_TYPE__ns5__InsufficientActivationRuleFault (163)
#endif

/* _ns5__InvalidConditionFilterFault has binding name '_ns5__InvalidConditionFilterFault' for type '' */
#ifndef SOAP_TYPE__ns5__InvalidConditionFilterFault
#define SOAP_TYPE__ns5__InvalidConditionFilterFault (162)
#endif

/* _ns5__ActionConfigurationIsInUseFault has binding name '_ns5__ActionConfigurationIsInUseFault' for type '' */
#ifndef SOAP_TYPE__ns5__ActionConfigurationIsInUseFault
#define SOAP_TYPE__ns5__ActionConfigurationIsInUseFault (161)
#endif

/* _ns5__RecipientTemplateNotFoundFault has binding name '_ns5__RecipientTemplateNotFoundFault' for type '' */
#ifndef SOAP_TYPE__ns5__RecipientTemplateNotFoundFault
#define SOAP_TYPE__ns5__RecipientTemplateNotFoundFault (160)
#endif

/* _ns5__ActionConfigurationNotFoundFault has binding name '_ns5__ActionConfigurationNotFoundFault' for type '' */
#ifndef SOAP_TYPE__ns5__ActionConfigurationNotFoundFault
#define SOAP_TYPE__ns5__ActionConfigurationNotFoundFault (159)
#endif

/* _ns5__InvalidActionConfigurationFault has binding name '_ns5__InvalidActionConfigurationFault' for type '' */
#ifndef SOAP_TYPE__ns5__InvalidActionConfigurationFault
#define SOAP_TYPE__ns5__InvalidActionConfigurationFault (158)
#endif

/* _ns5__ParametersMissmatchFault has binding name '_ns5__ParametersMissmatchFault' for type '' */
#ifndef SOAP_TYPE__ns5__ParametersMissmatchFault
#define SOAP_TYPE__ns5__ParametersMissmatchFault (157)
#endif

/* _ns5__RecipientConfigurationNotFoundFault has binding name '_ns5__RecipientConfigurationNotFoundFault' for type '' */
#ifndef SOAP_TYPE__ns5__RecipientConfigurationNotFoundFault
#define SOAP_TYPE__ns5__RecipientConfigurationNotFoundFault (156)
#endif

/* _ns5__ActionTemplateNotFoundFault has binding name '_ns5__ActionTemplateNotFoundFault' for type '' */
#ifndef SOAP_TYPE__ns5__ActionTemplateNotFoundFault
#define SOAP_TYPE__ns5__ActionTemplateNotFoundFault (155)
#endif

/* _ns5__RemoveActionRuleResponse has binding name '_ns5__RemoveActionRuleResponse' for type '' */
#ifndef SOAP_TYPE__ns5__RemoveActionRuleResponse
#define SOAP_TYPE__ns5__RemoveActionRuleResponse (154)
#endif

/* _ns5__RemoveActionRule has binding name '_ns5__RemoveActionRule' for type '' */
#ifndef SOAP_TYPE__ns5__RemoveActionRule
#define SOAP_TYPE__ns5__RemoveActionRule (153)
#endif

/* _ns5__GetActionRulesResponse has binding name '_ns5__GetActionRulesResponse' for type '' */
#ifndef SOAP_TYPE__ns5__GetActionRulesResponse
#define SOAP_TYPE__ns5__GetActionRulesResponse (152)
#endif

/* _ns5__GetActionRules has binding name '_ns5__GetActionRules' for type '' */
#ifndef SOAP_TYPE__ns5__GetActionRules
#define SOAP_TYPE__ns5__GetActionRules (151)
#endif

/* _ns5__AddActionRuleResponse has binding name '_ns5__AddActionRuleResponse' for type '' */
#ifndef SOAP_TYPE__ns5__AddActionRuleResponse
#define SOAP_TYPE__ns5__AddActionRuleResponse (150)
#endif

/* _ns5__AddActionRule has binding name '_ns5__AddActionRule' for type '' */
#ifndef SOAP_TYPE__ns5__AddActionRule
#define SOAP_TYPE__ns5__AddActionRule (149)
#endif

/* _ns5__GetRecipientConfigurationsResponse has binding name '_ns5__GetRecipientConfigurationsResponse' for type '' */
#ifndef SOAP_TYPE__ns5__GetRecipientConfigurationsResponse
#define SOAP_TYPE__ns5__GetRecipientConfigurationsResponse (148)
#endif

/* _ns5__GetRecipientConfigurations has binding name '_ns5__GetRecipientConfigurations' for type '' */
#ifndef SOAP_TYPE__ns5__GetRecipientConfigurations
#define SOAP_TYPE__ns5__GetRecipientConfigurations (147)
#endif

/* _ns5__RemoveRecipientConfigurationResponse has binding name '_ns5__RemoveRecipientConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__ns5__RemoveRecipientConfigurationResponse
#define SOAP_TYPE__ns5__RemoveRecipientConfigurationResponse (146)
#endif

/* _ns5__RemoveRecipientConfiguration has binding name '_ns5__RemoveRecipientConfiguration' for type '' */
#ifndef SOAP_TYPE__ns5__RemoveRecipientConfiguration
#define SOAP_TYPE__ns5__RemoveRecipientConfiguration (145)
#endif

/* _ns5__AddRecipientConfigurationResponse has binding name '_ns5__AddRecipientConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__ns5__AddRecipientConfigurationResponse
#define SOAP_TYPE__ns5__AddRecipientConfigurationResponse (144)
#endif

/* _ns5__AddRecipientConfiguration has binding name '_ns5__AddRecipientConfiguration' for type '' */
#ifndef SOAP_TYPE__ns5__AddRecipientConfiguration
#define SOAP_TYPE__ns5__AddRecipientConfiguration (143)
#endif

/* _ns5__GetRecipientTemplatesResponse has binding name '_ns5__GetRecipientTemplatesResponse' for type '' */
#ifndef SOAP_TYPE__ns5__GetRecipientTemplatesResponse
#define SOAP_TYPE__ns5__GetRecipientTemplatesResponse (142)
#endif

/* _ns5__GetRecipientTemplates has binding name '_ns5__GetRecipientTemplates' for type '' */
#ifndef SOAP_TYPE__ns5__GetRecipientTemplates
#define SOAP_TYPE__ns5__GetRecipientTemplates (141)
#endif

/* _ns5__GetActionConfigurationsResponse has binding name '_ns5__GetActionConfigurationsResponse' for type '' */
#ifndef SOAP_TYPE__ns5__GetActionConfigurationsResponse
#define SOAP_TYPE__ns5__GetActionConfigurationsResponse (140)
#endif

/* _ns5__GetActionConfigurations has binding name '_ns5__GetActionConfigurations' for type '' */
#ifndef SOAP_TYPE__ns5__GetActionConfigurations
#define SOAP_TYPE__ns5__GetActionConfigurations (139)
#endif

/* _ns5__RemoveActionConfigurationResponse has binding name '_ns5__RemoveActionConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__ns5__RemoveActionConfigurationResponse
#define SOAP_TYPE__ns5__RemoveActionConfigurationResponse (138)
#endif

/* _ns5__RemoveActionConfiguration has binding name '_ns5__RemoveActionConfiguration' for type '' */
#ifndef SOAP_TYPE__ns5__RemoveActionConfiguration
#define SOAP_TYPE__ns5__RemoveActionConfiguration (137)
#endif

/* _ns5__AddActionConfigurationResponse has binding name '_ns5__AddActionConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__ns5__AddActionConfigurationResponse
#define SOAP_TYPE__ns5__AddActionConfigurationResponse (136)
#endif

/* _ns5__AddActionConfiguration has binding name '_ns5__AddActionConfiguration' for type '' */
#ifndef SOAP_TYPE__ns5__AddActionConfiguration
#define SOAP_TYPE__ns5__AddActionConfiguration (135)
#endif

/* _ns5__GetActionTemplatesResponse has binding name '_ns5__GetActionTemplatesResponse' for type '' */
#ifndef SOAP_TYPE__ns5__GetActionTemplatesResponse
#define SOAP_TYPE__ns5__GetActionTemplatesResponse (134)
#endif

/* _ns5__GetActionTemplates has binding name '_ns5__GetActionTemplates' for type '' */
#ifndef SOAP_TYPE__ns5__GetActionTemplates
#define SOAP_TYPE__ns5__GetActionTemplates (133)
#endif

/* ns5__UsedActionRule has binding name 'ns5__UsedActionRule' for type 'ns5:UsedActionRule' */
#ifndef SOAP_TYPE_ns5__UsedActionRule
#define SOAP_TYPE_ns5__UsedActionRule (132)
#endif

/* ns5__UsedByActionRules has binding name 'ns5__UsedByActionRules' for type 'ns5:UsedByActionRules' */
#ifndef SOAP_TYPE_ns5__UsedByActionRules
#define SOAP_TYPE_ns5__UsedByActionRules (131)
#endif

/* ns5__UsedActionConfiguration has binding name 'ns5__UsedActionConfiguration' for type 'ns5:UsedActionConfiguration' */
#ifndef SOAP_TYPE_ns5__UsedActionConfiguration
#define SOAP_TYPE_ns5__UsedActionConfiguration (130)
#endif

/* ns5__UsedByActionConfigurations has binding name 'ns5__UsedByActionConfigurations' for type 'ns5:UsedByActionConfigurations' */
#ifndef SOAP_TYPE_ns5__UsedByActionConfigurations
#define SOAP_TYPE_ns5__UsedByActionConfigurations (129)
#endif

/* ns5__ActionTemplateParameter has binding name 'ns5__ActionTemplateParameter' for type 'ns5:ActionTemplateParameter' */
#ifndef SOAP_TYPE_ns5__ActionTemplateParameter
#define SOAP_TYPE_ns5__ActionTemplateParameter (128)
#endif

/* ns5__ActionTemplateParameters has binding name 'ns5__ActionTemplateParameters' for type 'ns5:ActionTemplateParameters' */
#ifndef SOAP_TYPE_ns5__ActionTemplateParameters
#define SOAP_TYPE_ns5__ActionTemplateParameters (127)
#endif

/* ns5__ActionTemplate has binding name 'ns5__ActionTemplate' for type 'ns5:ActionTemplate' */
#ifndef SOAP_TYPE_ns5__ActionTemplate
#define SOAP_TYPE_ns5__ActionTemplate (126)
#endif

/* ns5__ActionParameter has binding name 'ns5__ActionParameter' for type 'ns5:ActionParameter' */
#ifndef SOAP_TYPE_ns5__ActionParameter
#define SOAP_TYPE_ns5__ActionParameter (125)
#endif

/* ns5__ActionTemplates has binding name 'ns5__ActionTemplates' for type 'ns5:ActionTemplates' */
#ifndef SOAP_TYPE_ns5__ActionTemplates
#define SOAP_TYPE_ns5__ActionTemplates (124)
#endif

/* ns5__ActionParameters has binding name 'ns5__ActionParameters' for type 'ns5:ActionParameters' */
#ifndef SOAP_TYPE_ns5__ActionParameters
#define SOAP_TYPE_ns5__ActionParameters (123)
#endif

/* ns5__ActionConfiguration has binding name 'ns5__ActionConfiguration' for type 'ns5:ActionConfiguration' */
#ifndef SOAP_TYPE_ns5__ActionConfiguration
#define SOAP_TYPE_ns5__ActionConfiguration (122)
#endif

/* ns5__NewActionConfiguration has binding name 'ns5__NewActionConfiguration' for type 'ns5:NewActionConfiguration' */
#ifndef SOAP_TYPE_ns5__NewActionConfiguration
#define SOAP_TYPE_ns5__NewActionConfiguration (121)
#endif

/* ns5__ActionConfigurations has binding name 'ns5__ActionConfigurations' for type 'ns5:ActionConfigurations' */
#ifndef SOAP_TYPE_ns5__ActionConfigurations
#define SOAP_TYPE_ns5__ActionConfigurations (120)
#endif

/* ns5__RecipientTemplate has binding name 'ns5__RecipientTemplate' for type 'ns5:RecipientTemplate' */
#ifndef SOAP_TYPE_ns5__RecipientTemplate
#define SOAP_TYPE_ns5__RecipientTemplate (119)
#endif

/* ns5__RecipientTemplates has binding name 'ns5__RecipientTemplates' for type 'ns5:RecipientTemplates' */
#ifndef SOAP_TYPE_ns5__RecipientTemplates
#define SOAP_TYPE_ns5__RecipientTemplates (118)
#endif

/* ns5__RecipientConfigurations has binding name 'ns5__RecipientConfigurations' for type 'ns5:RecipientConfigurations' */
#ifndef SOAP_TYPE_ns5__RecipientConfigurations
#define SOAP_TYPE_ns5__RecipientConfigurations (117)
#endif

/* ns5__RecipientConfiguration has binding name 'ns5__RecipientConfiguration' for type 'ns5:RecipientConfiguration' */
#ifndef SOAP_TYPE_ns5__RecipientConfiguration
#define SOAP_TYPE_ns5__RecipientConfiguration (116)
#endif

/* ns5__NewRecipientConfiguration has binding name 'ns5__NewRecipientConfiguration' for type 'ns5:NewRecipientConfiguration' */
#ifndef SOAP_TYPE_ns5__NewRecipientConfiguration
#define SOAP_TYPE_ns5__NewRecipientConfiguration (115)
#endif

/* ns5__ActionRule has binding name 'ns5__ActionRule' for type 'ns5:ActionRule' */
#ifndef SOAP_TYPE_ns5__ActionRule
#define SOAP_TYPE_ns5__ActionRule (114)
#endif

/* ns5__ActionRules has binding name 'ns5__ActionRules' for type 'ns5:ActionRules' */
#ifndef SOAP_TYPE_ns5__ActionRules
#define SOAP_TYPE_ns5__ActionRules (113)
#endif

/* ns5__Conditions has binding name 'ns5__Conditions' for type 'ns5:Conditions' */
#ifndef SOAP_TYPE_ns5__Conditions
#define SOAP_TYPE_ns5__Conditions (112)
#endif

/* ns5__NewActionRule has binding name 'ns5__NewActionRule' for type 'ns5:NewActionRule' */
#ifndef SOAP_TYPE_ns5__NewActionRule
#define SOAP_TYPE_ns5__NewActionRule (111)
#endif

/* ns4__BaseFaultType has binding name 'ns4__BaseFaultType' for type 'ns4:BaseFaultType' */
#ifndef SOAP_TYPE_ns4__BaseFaultType
#define SOAP_TYPE_ns4__BaseFaultType (110)
#endif

/* _ns3__ResumeSubscriptionResponse has binding name '_ns3__ResumeSubscriptionResponse' for type '' */
#ifndef SOAP_TYPE__ns3__ResumeSubscriptionResponse
#define SOAP_TYPE__ns3__ResumeSubscriptionResponse (109)
#endif

/* _ns3__ResumeSubscription has binding name '_ns3__ResumeSubscription' for type '' */
#ifndef SOAP_TYPE__ns3__ResumeSubscription
#define SOAP_TYPE__ns3__ResumeSubscription (108)
#endif

/* _ns3__PauseSubscriptionResponse has binding name '_ns3__PauseSubscriptionResponse' for type '' */
#ifndef SOAP_TYPE__ns3__PauseSubscriptionResponse
#define SOAP_TYPE__ns3__PauseSubscriptionResponse (107)
#endif

/* _ns3__PauseSubscription has binding name '_ns3__PauseSubscription' for type '' */
#ifndef SOAP_TYPE__ns3__PauseSubscription
#define SOAP_TYPE__ns3__PauseSubscription (106)
#endif

/* _ns3__UnsubscribeResponse has binding name '_ns3__UnsubscribeResponse' for type '' */
#ifndef SOAP_TYPE__ns3__UnsubscribeResponse
#define SOAP_TYPE__ns3__UnsubscribeResponse (105)
#endif

/* _ns3__Unsubscribe has binding name '_ns3__Unsubscribe' for type '' */
#ifndef SOAP_TYPE__ns3__Unsubscribe
#define SOAP_TYPE__ns3__Unsubscribe (104)
#endif

/* _ns3__RenewResponse has binding name '_ns3__RenewResponse' for type '' */
#ifndef SOAP_TYPE__ns3__RenewResponse
#define SOAP_TYPE__ns3__RenewResponse (103)
#endif

/* _ns3__Renew has binding name '_ns3__Renew' for type '' */
#ifndef SOAP_TYPE__ns3__Renew
#define SOAP_TYPE__ns3__Renew (102)
#endif

/* _ns3__CreatePullPointResponse has binding name '_ns3__CreatePullPointResponse' for type '' */
#ifndef SOAP_TYPE__ns3__CreatePullPointResponse
#define SOAP_TYPE__ns3__CreatePullPointResponse (101)
#endif

/* _ns3__CreatePullPoint has binding name '_ns3__CreatePullPoint' for type '' */
#ifndef SOAP_TYPE__ns3__CreatePullPoint
#define SOAP_TYPE__ns3__CreatePullPoint (100)
#endif

/* _ns3__DestroyPullPointResponse has binding name '_ns3__DestroyPullPointResponse' for type '' */
#ifndef SOAP_TYPE__ns3__DestroyPullPointResponse
#define SOAP_TYPE__ns3__DestroyPullPointResponse (99)
#endif

/* _ns3__DestroyPullPoint has binding name '_ns3__DestroyPullPoint' for type '' */
#ifndef SOAP_TYPE__ns3__DestroyPullPoint
#define SOAP_TYPE__ns3__DestroyPullPoint (98)
#endif

/* _ns3__GetMessagesResponse has binding name '_ns3__GetMessagesResponse' for type '' */
#ifndef SOAP_TYPE__ns3__GetMessagesResponse
#define SOAP_TYPE__ns3__GetMessagesResponse (97)
#endif

/* _ns3__GetMessages has binding name '_ns3__GetMessages' for type '' */
#ifndef SOAP_TYPE__ns3__GetMessages
#define SOAP_TYPE__ns3__GetMessages (96)
#endif

/* _ns3__GetCurrentMessageResponse has binding name '_ns3__GetCurrentMessageResponse' for type '' */
#ifndef SOAP_TYPE__ns3__GetCurrentMessageResponse
#define SOAP_TYPE__ns3__GetCurrentMessageResponse (95)
#endif

/* _ns3__GetCurrentMessage has binding name '_ns3__GetCurrentMessage' for type '' */
#ifndef SOAP_TYPE__ns3__GetCurrentMessage
#define SOAP_TYPE__ns3__GetCurrentMessage (94)
#endif

/* _ns3__SubscribeResponse has binding name '_ns3__SubscribeResponse' for type '' */
#ifndef SOAP_TYPE__ns3__SubscribeResponse
#define SOAP_TYPE__ns3__SubscribeResponse (93)
#endif

/* _ns3__Subscribe has binding name '_ns3__Subscribe' for type '' */
#ifndef SOAP_TYPE__ns3__Subscribe
#define SOAP_TYPE__ns3__Subscribe (92)
#endif

/* _ns3__UseRaw has binding name '_ns3__UseRaw' for type '' */
#ifndef SOAP_TYPE__ns3__UseRaw
#define SOAP_TYPE__ns3__UseRaw (91)
#endif

/* _ns3__Notify has binding name '_ns3__Notify' for type '' */
#ifndef SOAP_TYPE__ns3__Notify
#define SOAP_TYPE__ns3__Notify (90)
#endif

/* _ns3__SubscriptionManagerRP has binding name '_ns3__SubscriptionManagerRP' for type '' */
#ifndef SOAP_TYPE__ns3__SubscriptionManagerRP
#define SOAP_TYPE__ns3__SubscriptionManagerRP (89)
#endif

/* _ns3__NotificationProducerRP has binding name '_ns3__NotificationProducerRP' for type '' */
#ifndef SOAP_TYPE__ns3__NotificationProducerRP
#define SOAP_TYPE__ns3__NotificationProducerRP (88)
#endif

/* ns3__ResumeFailedFaultType has binding name 'ns3__ResumeFailedFaultType' for type 'ns3:ResumeFailedFaultType' */
#ifndef SOAP_TYPE_ns3__ResumeFailedFaultType
#define SOAP_TYPE_ns3__ResumeFailedFaultType (87)
#endif

/* ns3__PauseFailedFaultType has binding name 'ns3__PauseFailedFaultType' for type 'ns3:PauseFailedFaultType' */
#ifndef SOAP_TYPE_ns3__PauseFailedFaultType
#define SOAP_TYPE_ns3__PauseFailedFaultType (86)
#endif

/* ns3__UnableToDestroySubscriptionFaultType has binding name 'ns3__UnableToDestroySubscriptionFaultType' for type 'ns3:UnableToDestroySubscriptionFaultType' */
#ifndef SOAP_TYPE_ns3__UnableToDestroySubscriptionFaultType
#define SOAP_TYPE_ns3__UnableToDestroySubscriptionFaultType (85)
#endif

/* ns3__UnacceptableTerminationTimeFaultType has binding name 'ns3__UnacceptableTerminationTimeFaultType' for type 'ns3:UnacceptableTerminationTimeFaultType' */
#ifndef SOAP_TYPE_ns3__UnacceptableTerminationTimeFaultType
#define SOAP_TYPE_ns3__UnacceptableTerminationTimeFaultType (84)
#endif

/* ns3__UnableToCreatePullPointFaultType has binding name 'ns3__UnableToCreatePullPointFaultType' for type 'ns3:UnableToCreatePullPointFaultType' */
#ifndef SOAP_TYPE_ns3__UnableToCreatePullPointFaultType
#define SOAP_TYPE_ns3__UnableToCreatePullPointFaultType (83)
#endif

/* ns3__UnableToDestroyPullPointFaultType has binding name 'ns3__UnableToDestroyPullPointFaultType' for type 'ns3:UnableToDestroyPullPointFaultType' */
#ifndef SOAP_TYPE_ns3__UnableToDestroyPullPointFaultType
#define SOAP_TYPE_ns3__UnableToDestroyPullPointFaultType (82)
#endif

/* ns3__UnableToGetMessagesFaultType has binding name 'ns3__UnableToGetMessagesFaultType' for type 'ns3:UnableToGetMessagesFaultType' */
#ifndef SOAP_TYPE_ns3__UnableToGetMessagesFaultType
#define SOAP_TYPE_ns3__UnableToGetMessagesFaultType (81)
#endif

/* ns3__NoCurrentMessageOnTopicFaultType has binding name 'ns3__NoCurrentMessageOnTopicFaultType' for type 'ns3:NoCurrentMessageOnTopicFaultType' */
#ifndef SOAP_TYPE_ns3__NoCurrentMessageOnTopicFaultType
#define SOAP_TYPE_ns3__NoCurrentMessageOnTopicFaultType (80)
#endif

/* ns3__UnacceptableInitialTerminationTimeFaultType has binding name 'ns3__UnacceptableInitialTerminationTimeFaultType' for type 'ns3:UnacceptableInitialTerminationTimeFaultType' */
#ifndef SOAP_TYPE_ns3__UnacceptableInitialTerminationTimeFaultType
#define SOAP_TYPE_ns3__UnacceptableInitialTerminationTimeFaultType (79)
#endif

/* ns3__NotifyMessageNotSupportedFaultType has binding name 'ns3__NotifyMessageNotSupportedFaultType' for type 'ns3:NotifyMessageNotSupportedFaultType' */
#ifndef SOAP_TYPE_ns3__NotifyMessageNotSupportedFaultType
#define SOAP_TYPE_ns3__NotifyMessageNotSupportedFaultType (78)
#endif

/* ns3__UnsupportedPolicyRequestFaultType has binding name 'ns3__UnsupportedPolicyRequestFaultType' for type 'ns3:UnsupportedPolicyRequestFaultType' */
#ifndef SOAP_TYPE_ns3__UnsupportedPolicyRequestFaultType
#define SOAP_TYPE_ns3__UnsupportedPolicyRequestFaultType (77)
#endif

/* ns3__UnrecognizedPolicyRequestFaultType has binding name 'ns3__UnrecognizedPolicyRequestFaultType' for type 'ns3:UnrecognizedPolicyRequestFaultType' */
#ifndef SOAP_TYPE_ns3__UnrecognizedPolicyRequestFaultType
#define SOAP_TYPE_ns3__UnrecognizedPolicyRequestFaultType (76)
#endif

/* ns3__InvalidMessageContentExpressionFaultType has binding name 'ns3__InvalidMessageContentExpressionFaultType' for type 'ns3:InvalidMessageContentExpressionFaultType' */
#ifndef SOAP_TYPE_ns3__InvalidMessageContentExpressionFaultType
#define SOAP_TYPE_ns3__InvalidMessageContentExpressionFaultType (75)
#endif

/* ns3__InvalidProducerPropertiesExpressionFaultType has binding name 'ns3__InvalidProducerPropertiesExpressionFaultType' for type 'ns3:InvalidProducerPropertiesExpressionFaultType' */
#ifndef SOAP_TYPE_ns3__InvalidProducerPropertiesExpressionFaultType
#define SOAP_TYPE_ns3__InvalidProducerPropertiesExpressionFaultType (74)
#endif

/* ns3__MultipleTopicsSpecifiedFaultType has binding name 'ns3__MultipleTopicsSpecifiedFaultType' for type 'ns3:MultipleTopicsSpecifiedFaultType' */
#ifndef SOAP_TYPE_ns3__MultipleTopicsSpecifiedFaultType
#define SOAP_TYPE_ns3__MultipleTopicsSpecifiedFaultType (73)
#endif

/* ns3__TopicNotSupportedFaultType has binding name 'ns3__TopicNotSupportedFaultType' for type 'ns3:TopicNotSupportedFaultType' */
#ifndef SOAP_TYPE_ns3__TopicNotSupportedFaultType
#define SOAP_TYPE_ns3__TopicNotSupportedFaultType (72)
#endif

/* ns3__InvalidTopicExpressionFaultType has binding name 'ns3__InvalidTopicExpressionFaultType' for type 'ns3:InvalidTopicExpressionFaultType' */
#ifndef SOAP_TYPE_ns3__InvalidTopicExpressionFaultType
#define SOAP_TYPE_ns3__InvalidTopicExpressionFaultType (71)
#endif

/* ns3__TopicExpressionDialectUnknownFaultType has binding name 'ns3__TopicExpressionDialectUnknownFaultType' for type 'ns3:TopicExpressionDialectUnknownFaultType' */
#ifndef SOAP_TYPE_ns3__TopicExpressionDialectUnknownFaultType
#define SOAP_TYPE_ns3__TopicExpressionDialectUnknownFaultType (70)
#endif

/* ns3__InvalidFilterFaultType has binding name 'ns3__InvalidFilterFaultType' for type 'ns3:InvalidFilterFaultType' */
#ifndef SOAP_TYPE_ns3__InvalidFilterFaultType
#define SOAP_TYPE_ns3__InvalidFilterFaultType (69)
#endif

/* ns3__SubscribeCreationFailedFaultType has binding name 'ns3__SubscribeCreationFailedFaultType' for type 'ns3:SubscribeCreationFailedFaultType' */
#ifndef SOAP_TYPE_ns3__SubscribeCreationFailedFaultType
#define SOAP_TYPE_ns3__SubscribeCreationFailedFaultType (68)
#endif

/* ns3__NotificationMessageHolderType has binding name 'ns3__NotificationMessageHolderType' for type 'ns3:NotificationMessageHolderType' */
#ifndef SOAP_TYPE_ns3__NotificationMessageHolderType
#define SOAP_TYPE_ns3__NotificationMessageHolderType (67)
#endif

/* ns3__SubscriptionPolicyType has binding name 'ns3__SubscriptionPolicyType' for type 'ns3:SubscriptionPolicyType' */
#ifndef SOAP_TYPE_ns3__SubscriptionPolicyType
#define SOAP_TYPE_ns3__SubscriptionPolicyType (66)
#endif

/* ns3__FilterType has binding name 'ns3__FilterType' for type 'ns3:FilterType' */
#ifndef SOAP_TYPE_ns3__FilterType
#define SOAP_TYPE_ns3__FilterType (65)
#endif

/* ns3__TopicExpressionType has binding name 'ns3__TopicExpressionType' for type 'ns3:TopicExpressionType' */
#ifndef SOAP_TYPE_ns3__TopicExpressionType
#define SOAP_TYPE_ns3__TopicExpressionType (64)
#endif

/* ns3__QueryExpressionType has binding name 'ns3__QueryExpressionType' for type 'ns3:QueryExpressionType' */
#ifndef SOAP_TYPE_ns3__QueryExpressionType
#define SOAP_TYPE_ns3__QueryExpressionType (63)
#endif

/* ns2__TopicSetType has binding name 'ns2__TopicSetType' for type 'ns2:TopicSetType' */
#ifndef SOAP_TYPE_ns2__TopicSetType
#define SOAP_TYPE_ns2__TopicSetType (62)
#endif

/* ns2__TopicType has binding name 'ns2__TopicType' for type 'ns2:TopicType' */
#ifndef SOAP_TYPE_ns2__TopicType
#define SOAP_TYPE_ns2__TopicType (61)
#endif

/* ns2__TopicNamespaceType has binding name 'ns2__TopicNamespaceType' for type 'ns2:TopicNamespaceType' */
#ifndef SOAP_TYPE_ns2__TopicNamespaceType
#define SOAP_TYPE_ns2__TopicNamespaceType (60)
#endif

/* ns2__QueryExpressionType has binding name 'ns2__QueryExpressionType' for type 'ns2:QueryExpressionType' */
#ifndef SOAP_TYPE_ns2__QueryExpressionType
#define SOAP_TYPE_ns2__QueryExpressionType (59)
#endif

/* ns2__ExtensibleDocumented has binding name 'ns2__ExtensibleDocumented' for type 'ns2:ExtensibleDocumented' */
#ifndef SOAP_TYPE_ns2__ExtensibleDocumented
#define SOAP_TYPE_ns2__ExtensibleDocumented (58)
#endif

/* ns2__Documentation has binding name 'ns2__Documentation' for type 'ns2:Documentation' */
#ifndef SOAP_TYPE_ns2__Documentation
#define SOAP_TYPE_ns2__Documentation (57)
#endif

/* _ns1__ChangeVirtualInputStateResponse has binding name '_ns1__ChangeVirtualInputStateResponse' for type '' */
#ifndef SOAP_TYPE__ns1__ChangeVirtualInputStateResponse
#define SOAP_TYPE__ns1__ChangeVirtualInputStateResponse (56)
#endif

/* _ns1__ChangeVirtualInputState has binding name '_ns1__ChangeVirtualInputState' for type '' */
#ifndef SOAP_TYPE__ns1__ChangeVirtualInputState
#define SOAP_TYPE__ns1__ChangeVirtualInputState (55)
#endif

/* _ns1__ScheduledEventAlreadyExistsFault has binding name '_ns1__ScheduledEventAlreadyExistsFault' for type '' */
#ifndef SOAP_TYPE__ns1__ScheduledEventAlreadyExistsFault
#define SOAP_TYPE__ns1__ScheduledEventAlreadyExistsFault (54)
#endif

/* _ns1__InvalidScheduledEventIDFault has binding name '_ns1__InvalidScheduledEventIDFault' for type '' */
#ifndef SOAP_TYPE__ns1__InvalidScheduledEventIDFault
#define SOAP_TYPE__ns1__InvalidScheduledEventIDFault (53)
#endif

/* _ns1__InvalidScheduleFault has binding name '_ns1__InvalidScheduleFault' for type '' */
#ifndef SOAP_TYPE__ns1__InvalidScheduleFault
#define SOAP_TYPE__ns1__InvalidScheduleFault (52)
#endif

/* _ns1__ScheduledEventNotFoundFault has binding name '_ns1__ScheduledEventNotFoundFault' for type '' */
#ifndef SOAP_TYPE__ns1__ScheduledEventNotFoundFault
#define SOAP_TYPE__ns1__ScheduledEventNotFoundFault (51)
#endif

/* _ns1__GetScheduledEventsResponse has binding name '_ns1__GetScheduledEventsResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetScheduledEventsResponse
#define SOAP_TYPE__ns1__GetScheduledEventsResponse (50)
#endif

/* _ns1__GetScheduledEvents has binding name '_ns1__GetScheduledEvents' for type '' */
#ifndef SOAP_TYPE__ns1__GetScheduledEvents
#define SOAP_TYPE__ns1__GetScheduledEvents (49)
#endif

/* _ns1__RemoveScheduledEventResponse has binding name '_ns1__RemoveScheduledEventResponse' for type '' */
#ifndef SOAP_TYPE__ns1__RemoveScheduledEventResponse
#define SOAP_TYPE__ns1__RemoveScheduledEventResponse (48)
#endif

/* _ns1__RemoveScheduledEvent has binding name '_ns1__RemoveScheduledEvent' for type '' */
#ifndef SOAP_TYPE__ns1__RemoveScheduledEvent
#define SOAP_TYPE__ns1__RemoveScheduledEvent (47)
#endif

/* _ns1__AddScheduledEventResponse has binding name '_ns1__AddScheduledEventResponse' for type '' */
#ifndef SOAP_TYPE__ns1__AddScheduledEventResponse
#define SOAP_TYPE__ns1__AddScheduledEventResponse (46)
#endif

/* _ns1__AddScheduledEvent has binding name '_ns1__AddScheduledEvent' for type '' */
#ifndef SOAP_TYPE__ns1__AddScheduledEvent
#define SOAP_TYPE__ns1__AddScheduledEvent (45)
#endif

/* _ns1__GetEventInstancesResponse has binding name '_ns1__GetEventInstancesResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetEventInstancesResponse
#define SOAP_TYPE__ns1__GetEventInstancesResponse (44)
#endif

/* _ns1__GetEventInstances has binding name '_ns1__GetEventInstances' for type '' */
#ifndef SOAP_TYPE__ns1__GetEventInstances
#define SOAP_TYPE__ns1__GetEventInstances (43)
#endif

/* ns1__ScheduleFilter has binding name 'ns1__ScheduleFilter' for type 'ns1:ScheduleFilter' */
#ifndef SOAP_TYPE_ns1__ScheduleFilter
#define SOAP_TYPE_ns1__ScheduleFilter (42)
#endif

/* ns1__ICalendar has binding name 'ns1__ICalendar' for type 'ns1:ICalendar' */
#ifndef SOAP_TYPE_ns1__ICalendar
#define SOAP_TYPE_ns1__ICalendar (41)
#endif

/* ns1__Schedule has binding name 'ns1__Schedule' for type 'ns1:Schedule' */
#ifndef SOAP_TYPE_ns1__Schedule
#define SOAP_TYPE_ns1__Schedule (40)
#endif

/* ns1__ScheduledEvent has binding name 'ns1__ScheduledEvent' for type 'ns1:ScheduledEvent' */
#ifndef SOAP_TYPE_ns1__ScheduledEvent
#define SOAP_TYPE_ns1__ScheduledEvent (39)
#endif

/* ns1__ScheduledEvents has binding name 'ns1__ScheduledEvents' for type 'ns1:ScheduledEvents' */
#ifndef SOAP_TYPE_ns1__ScheduledEvents
#define SOAP_TYPE_ns1__ScheduledEvents (38)
#endif

/* ns1__NewScheduledEvent has binding name 'ns1__NewScheduledEvent' for type 'ns1:NewScheduledEvent' */
#ifndef SOAP_TYPE_ns1__NewScheduledEvent
#define SOAP_TYPE_ns1__NewScheduledEvent (37)
#endif

/* _xml__lang has binding name '_xml__lang' for type '' */
#ifndef SOAP_TYPE__xml__lang
#define SOAP_TYPE__xml__lang (36)
#endif

/* xsd__unsignedLong has binding name 'xsd__unsignedLong' for type 'xsd:unsignedLong' */
#ifndef SOAP_TYPE_xsd__unsignedLong
#define SOAP_TYPE_xsd__unsignedLong (34)
#endif

/* xsd__token_ has binding name 'xsd__token_' for type 'xsd:token' */
#ifndef SOAP_TYPE_xsd__token_
#define SOAP_TYPE_xsd__token_ (33)
#endif

/* xsd__token has binding name 'xsd__token' for type 'xsd:token' */
#ifndef SOAP_TYPE_xsd__token
#define SOAP_TYPE_xsd__token (32)
#endif

/* xsd__string has binding name 'xsd__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_xsd__string
#define SOAP_TYPE_xsd__string (31)
#endif

/* xsd__nonNegativeInteger_ has binding name 'xsd__nonNegativeInteger_' for type 'xsd:nonNegativeInteger' */
#ifndef SOAP_TYPE_xsd__nonNegativeInteger_
#define SOAP_TYPE_xsd__nonNegativeInteger_ (30)
#endif

/* xsd__nonNegativeInteger has binding name 'xsd__nonNegativeInteger' for type 'xsd:nonNegativeInteger' */
#ifndef SOAP_TYPE_xsd__nonNegativeInteger
#define SOAP_TYPE_xsd__nonNegativeInteger (29)
#endif

/* xsd__integer_ has binding name 'xsd__integer_' for type 'xsd:integer' */
#ifndef SOAP_TYPE_xsd__integer_
#define SOAP_TYPE_xsd__integer_ (28)
#endif

/* xsd__integer has binding name 'xsd__integer' for type 'xsd:integer' */
#ifndef SOAP_TYPE_xsd__integer
#define SOAP_TYPE_xsd__integer (27)
#endif

/* xsd__int has binding name 'xsd__int' for type 'xsd:int' */
#ifndef SOAP_TYPE_xsd__int
#define SOAP_TYPE_xsd__int (26)
#endif

/* xsd__duration_ has binding name 'xsd__duration_' for type 'xsd:duration' */
#ifndef SOAP_TYPE_xsd__duration_
#define SOAP_TYPE_xsd__duration_ (25)
#endif

/* xsd__duration has binding name 'xsd__duration' for type 'xsd:duration' */
#ifndef SOAP_TYPE_xsd__duration
#define SOAP_TYPE_xsd__duration (24)
#endif

/* xsd__dateTime has binding name 'xsd__dateTime' for type 'xsd:dateTime' */
#ifndef SOAP_TYPE_xsd__dateTime
#define SOAP_TYPE_xsd__dateTime (22)
#endif

/* xsd__boolean has binding name 'xsd__boolean' for type 'xsd:boolean' */
#ifndef SOAP_TYPE_xsd__boolean
#define SOAP_TYPE_xsd__boolean (20)
#endif

/* xsd__anyURI_ has binding name 'xsd__anyURI_' for type 'xsd:anyURI' */
#ifndef SOAP_TYPE_xsd__anyURI_
#define SOAP_TYPE_xsd__anyURI_ (19)
#endif

/* xsd__anyURI has binding name 'xsd__anyURI' for type 'xsd:anyURI' */
#ifndef SOAP_TYPE_xsd__anyURI
#define SOAP_TYPE_xsd__anyURI (18)
#endif

/* xsd__QName_ has binding name 'xsd__QName_' for type 'xsd:QName' */
#ifndef SOAP_TYPE_xsd__QName_
#define SOAP_TYPE_xsd__QName_ (17)
#endif

/* xsd__NCName_ has binding name 'xsd__NCName_' for type 'xsd:NCName' */
#ifndef SOAP_TYPE_xsd__NCName_
#define SOAP_TYPE_xsd__NCName_ (16)
#endif

/* xsd__NCName has binding name 'xsd__NCName' for type 'xsd:NCName' */
#ifndef SOAP_TYPE_xsd__NCName
#define SOAP_TYPE_xsd__NCName (15)
#endif

/* xsd__QName has binding name 'xsd__QName' for type 'xsd:QName' */
#ifndef SOAP_TYPE_xsd__QName
#define SOAP_TYPE_xsd__QName (14)
#endif

/* std::string has binding name 'std__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_std__string
#define SOAP_TYPE_std__string (13)
#endif

/* struct SOAP_ENV__Fault has binding name 'SOAP_ENV__Fault' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (360)
#endif

/* struct SOAP_ENV__Reason has binding name 'SOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (359)
#endif

/* struct SOAP_ENV__Code has binding name 'SOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (357)
#endif

/* struct SOAP_ENV__Header has binding name 'SOAP_ENV__Header' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (356)
#endif

/* struct SOAP_ENV__Detail has binding name 'SOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (270)
#endif

/* xsd__anyAttribute has binding name 'xsd__anyAttribute' for type 'xsd:anyAttribute' */
#ifndef SOAP_TYPE_xsd__anyAttribute
#define SOAP_TYPE_xsd__anyAttribute (12)
#endif

/* xsd__anyType has binding name 'xsd__anyType' for type 'xsd:anyType' */
#ifndef SOAP_TYPE_xsd__anyType
#define SOAP_TYPE_xsd__anyType (10)
#endif

/* struct SOAP_ENV__Reason * has binding name 'PointerToSOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Reason
#define SOAP_TYPE_PointerToSOAP_ENV__Reason (362)
#endif

/* struct SOAP_ENV__Detail * has binding name 'PointerToSOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Detail
#define SOAP_TYPE_PointerToSOAP_ENV__Detail (361)
#endif

/* struct SOAP_ENV__Code * has binding name 'PointerToSOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Code
#define SOAP_TYPE_PointerToSOAP_ENV__Code (358)
#endif

/* _ns5__RemoveActionRule * has binding name 'PointerTo_ns5__RemoveActionRule' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns5__RemoveActionRule
#define SOAP_TYPE_PointerTo_ns5__RemoveActionRule (352)
#endif

/* _ns5__GetActionRules * has binding name 'PointerTo_ns5__GetActionRules' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns5__GetActionRules
#define SOAP_TYPE_PointerTo_ns5__GetActionRules (348)
#endif

/* _ns5__AddActionRule * has binding name 'PointerTo_ns5__AddActionRule' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns5__AddActionRule
#define SOAP_TYPE_PointerTo_ns5__AddActionRule (344)
#endif

/* _ns5__GetRecipientConfigurations * has binding name 'PointerTo_ns5__GetRecipientConfigurations' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns5__GetRecipientConfigurations
#define SOAP_TYPE_PointerTo_ns5__GetRecipientConfigurations (340)
#endif

/* _ns5__RemoveRecipientConfiguration * has binding name 'PointerTo_ns5__RemoveRecipientConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns5__RemoveRecipientConfiguration
#define SOAP_TYPE_PointerTo_ns5__RemoveRecipientConfiguration (336)
#endif

/* _ns5__AddRecipientConfiguration * has binding name 'PointerTo_ns5__AddRecipientConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns5__AddRecipientConfiguration
#define SOAP_TYPE_PointerTo_ns5__AddRecipientConfiguration (332)
#endif

/* _ns5__GetRecipientTemplates * has binding name 'PointerTo_ns5__GetRecipientTemplates' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns5__GetRecipientTemplates
#define SOAP_TYPE_PointerTo_ns5__GetRecipientTemplates (328)
#endif

/* _ns5__GetActionConfigurations * has binding name 'PointerTo_ns5__GetActionConfigurations' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns5__GetActionConfigurations
#define SOAP_TYPE_PointerTo_ns5__GetActionConfigurations (324)
#endif

/* _ns5__RemoveActionConfiguration * has binding name 'PointerTo_ns5__RemoveActionConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns5__RemoveActionConfiguration
#define SOAP_TYPE_PointerTo_ns5__RemoveActionConfiguration (320)
#endif

/* _ns5__AddActionConfiguration * has binding name 'PointerTo_ns5__AddActionConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns5__AddActionConfiguration
#define SOAP_TYPE_PointerTo_ns5__AddActionConfiguration (316)
#endif

/* _ns5__GetActionTemplates * has binding name 'PointerTo_ns5__GetActionTemplates' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns5__GetActionTemplates
#define SOAP_TYPE_PointerTo_ns5__GetActionTemplates (312)
#endif

/* _ns1__ChangeVirtualInputState * has binding name 'PointerTo_ns1__ChangeVirtualInputState' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__ChangeVirtualInputState
#define SOAP_TYPE_PointerTo_ns1__ChangeVirtualInputState (308)
#endif

/* _ns1__GetScheduledEvents * has binding name 'PointerTo_ns1__GetScheduledEvents' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetScheduledEvents
#define SOAP_TYPE_PointerTo_ns1__GetScheduledEvents (304)
#endif

/* _ns1__RemoveScheduledEvent * has binding name 'PointerTo_ns1__RemoveScheduledEvent' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__RemoveScheduledEvent
#define SOAP_TYPE_PointerTo_ns1__RemoveScheduledEvent (300)
#endif

/* _ns1__AddScheduledEvent * has binding name 'PointerTo_ns1__AddScheduledEvent' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__AddScheduledEvent
#define SOAP_TYPE_PointerTo_ns1__AddScheduledEvent (296)
#endif

/* _ns1__GetEventInstances * has binding name 'PointerTo_ns1__GetEventInstances' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetEventInstances
#define SOAP_TYPE_PointerTo_ns1__GetEventInstances (292)
#endif

/* ns3__TopicExpressionDialectUnknownFaultType * has binding name 'PointerTons3__TopicExpressionDialectUnknownFaultType' for type 'ns3:TopicExpressionDialectUnknownFaultType' */
#ifndef SOAP_TYPE_PointerTons3__TopicExpressionDialectUnknownFaultType
#define SOAP_TYPE_PointerTons3__TopicExpressionDialectUnknownFaultType (289)
#endif

/* _ns5__RecipientTemplateNotFoundFault * has binding name 'PointerTo_ns5__RecipientTemplateNotFoundFault' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns5__RecipientTemplateNotFoundFault
#define SOAP_TYPE_PointerTo_ns5__RecipientTemplateNotFoundFault (288)
#endif

/* _ns5__RecipientConfigurationNotFoundFault * has binding name 'PointerTo_ns5__RecipientConfigurationNotFoundFault' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns5__RecipientConfigurationNotFoundFault
#define SOAP_TYPE_PointerTo_ns5__RecipientConfigurationNotFoundFault (287)
#endif

/* _ns5__ParametersMissmatchFault * has binding name 'PointerTo_ns5__ParametersMissmatchFault' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns5__ParametersMissmatchFault
#define SOAP_TYPE_PointerTo_ns5__ParametersMissmatchFault (286)
#endif

/* ns3__InvalidTopicExpressionFaultType * has binding name 'PointerTons3__InvalidTopicExpressionFaultType' for type 'ns3:InvalidTopicExpressionFaultType' */
#ifndef SOAP_TYPE_PointerTons3__InvalidTopicExpressionFaultType
#define SOAP_TYPE_PointerTons3__InvalidTopicExpressionFaultType (285)
#endif

/* ns3__InvalidMessageContentExpressionFaultType * has binding name 'PointerTons3__InvalidMessageContentExpressionFaultType' for type 'ns3:InvalidMessageContentExpressionFaultType' */
#ifndef SOAP_TYPE_PointerTons3__InvalidMessageContentExpressionFaultType
#define SOAP_TYPE_PointerTons3__InvalidMessageContentExpressionFaultType (284)
#endif

/* ns3__InvalidFilterFaultType * has binding name 'PointerTons3__InvalidFilterFaultType' for type 'ns3:InvalidFilterFaultType' */
#ifndef SOAP_TYPE_PointerTons3__InvalidFilterFaultType
#define SOAP_TYPE_PointerTons3__InvalidFilterFaultType (283)
#endif

/* _ns5__InvalidConditionFilterFault * has binding name 'PointerTo_ns5__InvalidConditionFilterFault' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns5__InvalidConditionFilterFault
#define SOAP_TYPE_PointerTo_ns5__InvalidConditionFilterFault (282)
#endif

/* _ns5__InvalidActivationTimeoutFault * has binding name 'PointerTo_ns5__InvalidActivationTimeoutFault' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns5__InvalidActivationTimeoutFault
#define SOAP_TYPE_PointerTo_ns5__InvalidActivationTimeoutFault (281)
#endif

/* _ns5__InvalidActionConfigurationFault * has binding name 'PointerTo_ns5__InvalidActionConfigurationFault' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns5__InvalidActionConfigurationFault
#define SOAP_TYPE_PointerTo_ns5__InvalidActionConfigurationFault (280)
#endif

/* _ns5__InsufficientActivationRuleFault * has binding name 'PointerTo_ns5__InsufficientActivationRuleFault' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns5__InsufficientActivationRuleFault
#define SOAP_TYPE_PointerTo_ns5__InsufficientActivationRuleFault (279)
#endif

/* _ns5__ActionTemplateNotFoundFault * has binding name 'PointerTo_ns5__ActionTemplateNotFoundFault' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns5__ActionTemplateNotFoundFault
#define SOAP_TYPE_PointerTo_ns5__ActionTemplateNotFoundFault (278)
#endif

/* _ns5__ActionRuleNotFoundFault * has binding name 'PointerTo_ns5__ActionRuleNotFoundFault' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns5__ActionRuleNotFoundFault
#define SOAP_TYPE_PointerTo_ns5__ActionRuleNotFoundFault (277)
#endif

/* _ns5__ActionConfigurationNotFoundFault * has binding name 'PointerTo_ns5__ActionConfigurationNotFoundFault' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns5__ActionConfigurationNotFoundFault
#define SOAP_TYPE_PointerTo_ns5__ActionConfigurationNotFoundFault (276)
#endif

/* _ns5__ActionConfigurationIsInUseFault * has binding name 'PointerTo_ns5__ActionConfigurationIsInUseFault' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns5__ActionConfigurationIsInUseFault
#define SOAP_TYPE_PointerTo_ns5__ActionConfigurationIsInUseFault (275)
#endif

/* _ns1__ScheduledEventNotFoundFault * has binding name 'PointerTo_ns1__ScheduledEventNotFoundFault' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__ScheduledEventNotFoundFault
#define SOAP_TYPE_PointerTo_ns1__ScheduledEventNotFoundFault (274)
#endif

/* _ns1__ScheduledEventAlreadyExistsFault * has binding name 'PointerTo_ns1__ScheduledEventAlreadyExistsFault' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__ScheduledEventAlreadyExistsFault
#define SOAP_TYPE_PointerTo_ns1__ScheduledEventAlreadyExistsFault (273)
#endif

/* _ns1__InvalidScheduledEventIDFault * has binding name 'PointerTo_ns1__InvalidScheduledEventIDFault' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__InvalidScheduledEventIDFault
#define SOAP_TYPE_PointerTo_ns1__InvalidScheduledEventIDFault (272)
#endif

/* _ns1__InvalidScheduleFault * has binding name 'PointerTo_ns1__InvalidScheduleFault' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__InvalidScheduleFault
#define SOAP_TYPE_PointerTo_ns1__InvalidScheduleFault (271)
#endif

/* std::string * has binding name 'PointerToxsd__NCName' for type 'xsd:NCName' */
#ifndef SOAP_TYPE_PointerToxsd__NCName
#define SOAP_TYPE_PointerToxsd__NCName (268)
#endif

/* std::string * has binding name 'PointerTons2__ConcreteTopicExpression' for type 'ns2:ConcreteTopicExpression' */
#ifndef SOAP_TYPE_PointerTons2__ConcreteTopicExpression
#define SOAP_TYPE_PointerTons2__ConcreteTopicExpression (266)
#endif

/* std::string * has binding name 'PointerToxsd__QName' for type 'xsd:QName' */
#ifndef SOAP_TYPE_PointerToxsd__QName
#define SOAP_TYPE_PointerToxsd__QName (265)
#endif

/* ns2__TopicType * has binding name 'PointerTons2__TopicType' for type 'ns2:TopicType' */
#ifndef SOAP_TYPE_PointerTons2__TopicType
#define SOAP_TYPE_PointerTons2__TopicType (263)
#endif

/* ns2__QueryExpressionType * has binding name 'PointerTons2__QueryExpressionType' for type 'ns2:QueryExpressionType' */
#ifndef SOAP_TYPE_PointerTons2__QueryExpressionType
#define SOAP_TYPE_PointerTons2__QueryExpressionType (262)
#endif

/* std::string * has binding name 'PointerToxsd__anyURI' for type 'xsd:anyURI' */
#ifndef SOAP_TYPE_PointerToxsd__anyURI
#define SOAP_TYPE_PointerToxsd__anyURI (260)
#endif

/* ns6__MetadataType * has binding name 'PointerTons6__MetadataType' for type 'ns6:MetadataType' */
#ifndef SOAP_TYPE_PointerTons6__MetadataType
#define SOAP_TYPE_PointerTons6__MetadataType (259)
#endif

/* ns6__ReferenceParametersType * has binding name 'PointerTons6__ReferenceParametersType' for type 'ns6:ReferenceParametersType' */
#ifndef SOAP_TYPE_PointerTons6__ReferenceParametersType
#define SOAP_TYPE_PointerTons6__ReferenceParametersType (258)
#endif

/* ns6__AttributedURIType * has binding name 'PointerTons6__AttributedURIType' for type 'ns6:AttributedURIType' */
#ifndef SOAP_TYPE_PointerTons6__AttributedURIType
#define SOAP_TYPE_PointerTons6__AttributedURIType (257)
#endif

/* ns5__UsedByActionRules * has binding name 'PointerTons5__UsedByActionRules' for type 'ns5:UsedByActionRules' */
#ifndef SOAP_TYPE_PointerTons5__UsedByActionRules
#define SOAP_TYPE_PointerTons5__UsedByActionRules (256)
#endif

/* ns5__ActionRules * has binding name 'PointerTons5__ActionRules' for type 'ns5:ActionRules' */
#ifndef SOAP_TYPE_PointerTons5__ActionRules
#define SOAP_TYPE_PointerTons5__ActionRules (255)
#endif

/* ns5__NewActionRule * has binding name 'PointerTons5__NewActionRule' for type 'ns5:NewActionRule' */
#ifndef SOAP_TYPE_PointerTons5__NewActionRule
#define SOAP_TYPE_PointerTons5__NewActionRule (254)
#endif

/* ns5__RecipientConfigurations * has binding name 'PointerTons5__RecipientConfigurations' for type 'ns5:RecipientConfigurations' */
#ifndef SOAP_TYPE_PointerTons5__RecipientConfigurations
#define SOAP_TYPE_PointerTons5__RecipientConfigurations (253)
#endif

/* ns5__NewRecipientConfiguration * has binding name 'PointerTons5__NewRecipientConfiguration' for type 'ns5:NewRecipientConfiguration' */
#ifndef SOAP_TYPE_PointerTons5__NewRecipientConfiguration
#define SOAP_TYPE_PointerTons5__NewRecipientConfiguration (252)
#endif

/* ns5__RecipientTemplates * has binding name 'PointerTons5__RecipientTemplates' for type 'ns5:RecipientTemplates' */
#ifndef SOAP_TYPE_PointerTons5__RecipientTemplates
#define SOAP_TYPE_PointerTons5__RecipientTemplates (251)
#endif

/* ns5__ActionConfigurations * has binding name 'PointerTons5__ActionConfigurations' for type 'ns5:ActionConfigurations' */
#ifndef SOAP_TYPE_PointerTons5__ActionConfigurations
#define SOAP_TYPE_PointerTons5__ActionConfigurations (250)
#endif

/* ns5__NewActionConfiguration * has binding name 'PointerTons5__NewActionConfiguration' for type 'ns5:NewActionConfiguration' */
#ifndef SOAP_TYPE_PointerTons5__NewActionConfiguration
#define SOAP_TYPE_PointerTons5__NewActionConfiguration (249)
#endif

/* ns5__ActionTemplates * has binding name 'PointerTons5__ActionTemplates' for type 'ns5:ActionTemplates' */
#ifndef SOAP_TYPE_PointerTons5__ActionTemplates
#define SOAP_TYPE_PointerTons5__ActionTemplates (248)
#endif

/* ns5__UsedActionRule * has binding name 'PointerTons5__UsedActionRule' for type 'ns5:UsedActionRule' */
#ifndef SOAP_TYPE_PointerTons5__UsedActionRule
#define SOAP_TYPE_PointerTons5__UsedActionRule (246)
#endif

/* ns5__UsedActionConfiguration * has binding name 'PointerTons5__UsedActionConfiguration' for type 'ns5:UsedActionConfiguration' */
#ifndef SOAP_TYPE_PointerTons5__UsedActionConfiguration
#define SOAP_TYPE_PointerTons5__UsedActionConfiguration (244)
#endif

/* ns5__ActionTemplateParameter * has binding name 'PointerTons5__ActionTemplateParameter' for type 'ns5:ActionTemplateParameter' */
#ifndef SOAP_TYPE_PointerTons5__ActionTemplateParameter
#define SOAP_TYPE_PointerTons5__ActionTemplateParameter (242)
#endif

/* ns5__ActionTemplate * has binding name 'PointerTons5__ActionTemplate' for type 'ns5:ActionTemplate' */
#ifndef SOAP_TYPE_PointerTons5__ActionTemplate
#define SOAP_TYPE_PointerTons5__ActionTemplate (240)
#endif

/* ns5__ActionParameter * has binding name 'PointerTons5__ActionParameter' for type 'ns5:ActionParameter' */
#ifndef SOAP_TYPE_PointerTons5__ActionParameter
#define SOAP_TYPE_PointerTons5__ActionParameter (238)
#endif

/* ns5__ActionConfiguration * has binding name 'PointerTons5__ActionConfiguration' for type 'ns5:ActionConfiguration' */
#ifndef SOAP_TYPE_PointerTons5__ActionConfiguration
#define SOAP_TYPE_PointerTons5__ActionConfiguration (236)
#endif

/* ns5__ActionTemplateParameters * has binding name 'PointerTons5__ActionTemplateParameters' for type 'ns5:ActionTemplateParameters' */
#ifndef SOAP_TYPE_PointerTons5__ActionTemplateParameters
#define SOAP_TYPE_PointerTons5__ActionTemplateParameters (235)
#endif

/* ns5__RecipientTemplate * has binding name 'PointerTons5__RecipientTemplate' for type 'ns5:RecipientTemplate' */
#ifndef SOAP_TYPE_PointerTons5__RecipientTemplate
#define SOAP_TYPE_PointerTons5__RecipientTemplate (233)
#endif

/* ns5__RecipientConfiguration * has binding name 'PointerTons5__RecipientConfiguration' for type 'ns5:RecipientConfiguration' */
#ifndef SOAP_TYPE_PointerTons5__RecipientConfiguration
#define SOAP_TYPE_PointerTons5__RecipientConfiguration (231)
#endif

/* ns5__ActionParameters * has binding name 'PointerTons5__ActionParameters' for type 'ns5:ActionParameters' */
#ifndef SOAP_TYPE_PointerTons5__ActionParameters
#define SOAP_TYPE_PointerTons5__ActionParameters (230)
#endif

/* ns5__ActionRule * has binding name 'PointerTons5__ActionRule' for type 'ns5:ActionRule' */
#ifndef SOAP_TYPE_PointerTons5__ActionRule
#define SOAP_TYPE_PointerTons5__ActionRule (228)
#endif

/* std::string * has binding name 'PointerToxsd__integer' for type 'xsd:integer' */
#ifndef SOAP_TYPE_PointerToxsd__integer
#define SOAP_TYPE_PointerToxsd__integer (226)
#endif

/* std::string * has binding name 'PointerToxsd__duration' for type 'xsd:duration' */
#ifndef SOAP_TYPE_PointerToxsd__duration
#define SOAP_TYPE_PointerToxsd__duration (225)
#endif

/* ns5__Conditions * has binding name 'PointerTons5__Conditions' for type 'ns5:Conditions' */
#ifndef SOAP_TYPE_PointerTons5__Conditions
#define SOAP_TYPE_PointerTons5__Conditions (224)
#endif

/* _ns4__BaseFaultType_FaultCause * has binding name 'PointerTo_ns4__BaseFaultType_FaultCause' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns4__BaseFaultType_FaultCause
#define SOAP_TYPE_PointerTo_ns4__BaseFaultType_FaultCause (223)
#endif

/* std::string * has binding name 'PointerTo_xml__lang' for type '' */
#ifndef SOAP_TYPE_PointerTo_xml__lang
#define SOAP_TYPE_PointerTo_xml__lang (220)
#endif

/* _ns4__BaseFaultType_ErrorCode * has binding name 'PointerTo_ns4__BaseFaultType_ErrorCode' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns4__BaseFaultType_ErrorCode
#define SOAP_TYPE_PointerTo_ns4__BaseFaultType_ErrorCode (218)
#endif

/* std::string * has binding name 'PointerToxsd__nonNegativeInteger' for type 'xsd:nonNegativeInteger' */
#ifndef SOAP_TYPE_PointerToxsd__nonNegativeInteger
#define SOAP_TYPE_PointerToxsd__nonNegativeInteger (216)
#endif

/* _ns3__Subscribe_SubscriptionPolicy * has binding name 'PointerTo_ns3__Subscribe_SubscriptionPolicy' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns3__Subscribe_SubscriptionPolicy
#define SOAP_TYPE_PointerTo_ns3__Subscribe_SubscriptionPolicy (215)
#endif

/* std::string * has binding name 'PointerTons3__AbsoluteOrRelativeTimeType' for type 'ns3:AbsoluteOrRelativeTimeType' */
#ifndef SOAP_TYPE_PointerTons3__AbsoluteOrRelativeTimeType
#define SOAP_TYPE_PointerTons3__AbsoluteOrRelativeTimeType (213)
#endif

/* ns3__NotificationMessageHolderType * has binding name 'PointerTons3__NotificationMessageHolderType' for type 'ns3:NotificationMessageHolderType' */
#ifndef SOAP_TYPE_PointerTons3__NotificationMessageHolderType
#define SOAP_TYPE_PointerTons3__NotificationMessageHolderType (211)
#endif

/* time_t * has binding name 'PointerTodateTime' for type 'xsd:dateTime' */
#ifndef SOAP_TYPE_PointerTodateTime
#define SOAP_TYPE_PointerTodateTime (210)
#endif

/* ns3__SubscriptionPolicyType * has binding name 'PointerTons3__SubscriptionPolicyType' for type 'ns3:SubscriptionPolicyType' */
#ifndef SOAP_TYPE_PointerTons3__SubscriptionPolicyType
#define SOAP_TYPE_PointerTons3__SubscriptionPolicyType (209)
#endif

/* ns3__FilterType * has binding name 'PointerTons3__FilterType' for type 'ns3:FilterType' */
#ifndef SOAP_TYPE_PointerTons3__FilterType
#define SOAP_TYPE_PointerTons3__FilterType (208)
#endif

/* bool * has binding name 'PointerTobool' for type 'xsd:boolean' */
#ifndef SOAP_TYPE_PointerTobool
#define SOAP_TYPE_PointerTobool (206)
#endif

/* ns3__TopicExpressionType * has binding name 'PointerTons3__TopicExpressionType' for type 'ns3:TopicExpressionType' */
#ifndef SOAP_TYPE_PointerTons3__TopicExpressionType
#define SOAP_TYPE_PointerTons3__TopicExpressionType (203)
#endif

/* ns6__EndpointReferenceType * has binding name 'PointerTons6__EndpointReferenceType' for type 'ns6:EndpointReferenceType' */
#ifndef SOAP_TYPE_PointerTons6__EndpointReferenceType
#define SOAP_TYPE_PointerTons6__EndpointReferenceType (202)
#endif

/* ns2__Documentation * has binding name 'PointerTons2__Documentation' for type 'ns2:Documentation' */
#ifndef SOAP_TYPE_PointerTons2__Documentation
#define SOAP_TYPE_PointerTons2__Documentation (201)
#endif

/* ns1__ScheduledEvents * has binding name 'PointerTons1__ScheduledEvents' for type 'ns1:ScheduledEvents' */
#ifndef SOAP_TYPE_PointerTons1__ScheduledEvents
#define SOAP_TYPE_PointerTons1__ScheduledEvents (199)
#endif

/* ns1__ScheduleFilter * has binding name 'PointerTons1__ScheduleFilter' for type 'ns1:ScheduleFilter' */
#ifndef SOAP_TYPE_PointerTons1__ScheduleFilter
#define SOAP_TYPE_PointerTons1__ScheduleFilter (198)
#endif

/* ns1__NewScheduledEvent * has binding name 'PointerTons1__NewScheduledEvent' for type 'ns1:NewScheduledEvent' */
#ifndef SOAP_TYPE_PointerTons1__NewScheduledEvent
#define SOAP_TYPE_PointerTons1__NewScheduledEvent (197)
#endif

/* ns2__TopicSetType * has binding name 'PointerTons2__TopicSetType' for type 'ns2:TopicSetType' */
#ifndef SOAP_TYPE_PointerTons2__TopicSetType
#define SOAP_TYPE_PointerTons2__TopicSetType (196)
#endif

/* ns1__ScheduledType * has binding name 'PointerTons1__ScheduledType' for type 'ns1:ScheduledType' */
#ifndef SOAP_TYPE_PointerTons1__ScheduledType
#define SOAP_TYPE_PointerTons1__ScheduledType (194)
#endif

/* ns1__ICalendar * has binding name 'PointerTons1__ICalendar' for type 'ns1:ICalendar' */
#ifndef SOAP_TYPE_PointerTons1__ICalendar
#define SOAP_TYPE_PointerTons1__ICalendar (193)
#endif

/* ns1__ScheduledEvent * has binding name 'PointerTons1__ScheduledEvent' for type 'ns1:ScheduledEvent' */
#ifndef SOAP_TYPE_PointerTons1__ScheduledEvent
#define SOAP_TYPE_PointerTons1__ScheduledEvent (191)
#endif

/* ns1__Schedule * has binding name 'PointerTons1__Schedule' for type 'ns1:Schedule' */
#ifndef SOAP_TYPE_PointerTons1__Schedule
#define SOAP_TYPE_PointerTons1__Schedule (190)
#endif

/* std::string * has binding name 'PointerTostd__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_PointerTostd__string
#define SOAP_TYPE_PointerTostd__string (189)
#endif

/* _QName has binding name '_QName' for type 'xsd:QName' */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (6)
#endif

/* _XML has binding name '_XML' for type '' */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (5)
#endif

/* char * has binding name 'string' for type 'xsd:string' */
#ifndef SOAP_TYPE_string
#define SOAP_TYPE_string (4)
#endif

/* std::vector<std::string>  has binding name 'std__vectorTemplateOfxsd__QName' for type 'xsd:QName' */
#ifndef SOAP_TYPE_std__vectorTemplateOfxsd__QName
#define SOAP_TYPE_std__vectorTemplateOfxsd__QName (269)
#endif

/* std::vector<_ns2__TopicNamespaceType_Topic>  has binding name 'std__vectorTemplateOf_ns2__TopicNamespaceType_Topic' for type '' */
#ifndef SOAP_TYPE_std__vectorTemplateOf_ns2__TopicNamespaceType_Topic
#define SOAP_TYPE_std__vectorTemplateOf_ns2__TopicNamespaceType_Topic (267)
#endif

/* std::vector<ns2__TopicType *>  has binding name 'std__vectorTemplateOfPointerTons2__TopicType' for type 'ns2:TopicType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__TopicType
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__TopicType (264)
#endif

/* std::vector<ns5__UsedActionRule *>  has binding name 'std__vectorTemplateOfPointerTons5__UsedActionRule' for type 'ns5:UsedActionRule' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons5__UsedActionRule
#define SOAP_TYPE_std__vectorTemplateOfPointerTons5__UsedActionRule (247)
#endif

/* std::vector<ns5__UsedActionConfiguration *>  has binding name 'std__vectorTemplateOfPointerTons5__UsedActionConfiguration' for type 'ns5:UsedActionConfiguration' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons5__UsedActionConfiguration
#define SOAP_TYPE_std__vectorTemplateOfPointerTons5__UsedActionConfiguration (245)
#endif

/* std::vector<ns5__ActionTemplateParameter *>  has binding name 'std__vectorTemplateOfPointerTons5__ActionTemplateParameter' for type 'ns5:ActionTemplateParameter' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons5__ActionTemplateParameter
#define SOAP_TYPE_std__vectorTemplateOfPointerTons5__ActionTemplateParameter (243)
#endif

/* std::vector<ns5__ActionTemplate *>  has binding name 'std__vectorTemplateOfPointerTons5__ActionTemplate' for type 'ns5:ActionTemplate' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons5__ActionTemplate
#define SOAP_TYPE_std__vectorTemplateOfPointerTons5__ActionTemplate (241)
#endif

/* std::vector<ns5__ActionParameter *>  has binding name 'std__vectorTemplateOfPointerTons5__ActionParameter' for type 'ns5:ActionParameter' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons5__ActionParameter
#define SOAP_TYPE_std__vectorTemplateOfPointerTons5__ActionParameter (239)
#endif

/* std::vector<ns5__ActionConfiguration *>  has binding name 'std__vectorTemplateOfPointerTons5__ActionConfiguration' for type 'ns5:ActionConfiguration' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons5__ActionConfiguration
#define SOAP_TYPE_std__vectorTemplateOfPointerTons5__ActionConfiguration (237)
#endif

/* std::vector<ns5__RecipientTemplate *>  has binding name 'std__vectorTemplateOfPointerTons5__RecipientTemplate' for type 'ns5:RecipientTemplate' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons5__RecipientTemplate
#define SOAP_TYPE_std__vectorTemplateOfPointerTons5__RecipientTemplate (234)
#endif

/* std::vector<ns5__RecipientConfiguration *>  has binding name 'std__vectorTemplateOfPointerTons5__RecipientConfiguration' for type 'ns5:RecipientConfiguration' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons5__RecipientConfiguration
#define SOAP_TYPE_std__vectorTemplateOfPointerTons5__RecipientConfiguration (232)
#endif

/* std::vector<ns5__ActionRule *>  has binding name 'std__vectorTemplateOfPointerTons5__ActionRule' for type 'ns5:ActionRule' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons5__ActionRule
#define SOAP_TYPE_std__vectorTemplateOfPointerTons5__ActionRule (229)
#endif

/* std::vector<ns3__FilterType *>  has binding name 'std__vectorTemplateOfPointerTons3__FilterType' for type 'ns3:FilterType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons3__FilterType
#define SOAP_TYPE_std__vectorTemplateOfPointerTons3__FilterType (227)
#endif

/* std::vector<_ns4__BaseFaultType_Description>  has binding name 'std__vectorTemplateOf_ns4__BaseFaultType_Description' for type '' */
#ifndef SOAP_TYPE_std__vectorTemplateOf_ns4__BaseFaultType_Description
#define SOAP_TYPE_std__vectorTemplateOf_ns4__BaseFaultType_Description (221)
#endif

/* std::vector<ns3__NotificationMessageHolderType *>  has binding name 'std__vectorTemplateOfPointerTons3__NotificationMessageHolderType' for type 'ns3:NotificationMessageHolderType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons3__NotificationMessageHolderType
#define SOAP_TYPE_std__vectorTemplateOfPointerTons3__NotificationMessageHolderType (212)
#endif

/* std::vector<std::string>  has binding name 'std__vectorTemplateOfxsd__anyURI' for type 'xsd:anyURI' */
#ifndef SOAP_TYPE_std__vectorTemplateOfxsd__anyURI
#define SOAP_TYPE_std__vectorTemplateOfxsd__anyURI (207)
#endif

/* std::vector<ns3__TopicExpressionType *>  has binding name 'std__vectorTemplateOfPointerTons3__TopicExpressionType' for type 'ns3:TopicExpressionType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons3__TopicExpressionType
#define SOAP_TYPE_std__vectorTemplateOfPointerTons3__TopicExpressionType (205)
#endif

/* std::vector<struct soap_dom_element>  has binding name 'std__vectorTemplateOfxsd__anyType' for type 'xsd:anyType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfxsd__anyType
#define SOAP_TYPE_std__vectorTemplateOfxsd__anyType (200)
#endif

/* std::vector<ns1__ScheduledEvent *>  has binding name 'std__vectorTemplateOfPointerTons1__ScheduledEvent' for type 'ns1:ScheduledEvent' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__ScheduledEvent
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__ScheduledEvent (192)
#endif

/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


#endif

/* End of soapStub.h */
