#!/bin/sh -e

COMPANY_NAME="@deb.customization.company.name@"
CLOUD_HOST="@cloudHost@"
CLOUD_NAME="@customization.cloudName@"
LICENSE_VERSION="@customization.eulaVersion@"

. /usr/share/debconf/confmodule

if [ -n "$DEBIAN_SCRIPT_DEBUG" ]; then set -v -x; DEBIAN_SCRIPT_TRACE=1; fi
${DEBIAN_SCRIPT_TRACE:+ echo "#42#DEBUG# RUNNING $0 $*" 1>&2 }

license=mediaserver-eula

BASE_DIR="/opt/$COMPANY_NAME/mediaserver"
ETC_DIR="$BASE_DIR/etc"
CONFIG_FILE="$ETC_DIR/mediaserver.conf"

MEDIA_SERVER_STARTUP_SCRIPT="/etc/init.d/${COMPANY_NAME}-mediaserver"

errmsg()
{
    echo >&2 ''
    echo >&2 "$@"
    echo >&2 "try 'dpkg-reconfigure debconf' to select a frontend other than noninteractive"
    echo >&2 ''
}

check_cloud_host()
{
    # At this stage we don't have the config helper.
    [ -f "$CONFIG_FILE" ] || return 0

    echo "Checking @customization.cloudName@ compatibility..." >&2

    INSTALLED_CLOUD_HOST=$(awk -F= '/^cloudHost/ {print $2}' "$CONFIG_FILE")
    IS_CONNECTED_TO_CLOUD=$(awk -F= '/^isConnectedToCloud/ {print $2}' "$CONFIG_FILE")

    if [ "$IS_CONNECTED_TO_CLOUD" = "yes" -a -n "$INSTALLED_CLOUD_HOST" \
        -a "$INSTALLED_CLOUD_HOST" != "$CLOUD_HOST" ]
    then
        echo >&2
        echo "This package is for another instance of $CLOUD_NAME!"
        echo "Please unlink the system from $CLOUD_NAME first."
        echo "Exiting..." >&2
        echo >&2
        exit 1
    fi
}

if [ "$1" = "upgrade" ]
then
    check_cloud_host
elif [ "$1" = "install" ]
then
    if [ -f "$MEDIA_SERVER_STARTUP_SCRIPT" ]
    then
        "$MEDIA_SERVER_STARTUP_SCRIPT" stop
    fi

    # Clean up potentially unwanted files from previous installations.
    for dir in \
        "$BASE_DIR/lib" \
        "$BASE_DIR/bin" \
        "$BASE_DIR/var/scripts" \
        "/opt/$COMPANY_NAME/lib"
    do
        rm -rf "$dir" || true
    done
fi

SHOW_LICENSE=0
db_get $COMPANY_NAME-mediaserver/accepted-$license
if [ "$RET" = "true" ]
then
    db_get $COMPANY_NAME-mediaserver/accepted-$license-version
    if [ "$LICENSE_VERSION" -gt 1 ] && ([ -z "$RET" ] || [ "$RET" -lt "$LICENSE_VERSION" ])
    then
        SHOW_LICENSE=1
    fi
else
    SHOW_LICENSE=1
fi

if [ $SHOW_LICENSE = 0 ]
then
    echo "$license license has already been accepted" >&2
    exit 0
else
    # show license again
    db_fset $COMPANY_NAME-mediaserver/present-$license seen false
fi

# facilitate backup capability per debconf-devel(7)
STATE=1
while true; do
    case "$STATE" in
    0)  # ensure going back from license presentment is harmless
        STATE=1
        continue
        ;;
    1)  # present license
        db_fset $COMPANY_NAME-mediaserver/present-$license seen false
        if ! db_input critical $COMPANY_NAME-mediaserver/present-$license ; then
            errmsg "$license license could not be presented"
            exit 0
        fi
        db_fset $COMPANY_NAME-mediaserver/accepted-$license seen false
        if ! db_input critical $COMPANY_NAME-mediaserver/accepted-$license ; then
            errmsg "$license agree question could not be asked"
            exit 0
        fi
        ;;
    2)  # determine users' choice
        db_get $COMPANY_NAME-mediaserver/accepted-$license
        if [ "$RET" = "true" ]; then
            db_set $COMPANY_NAME-mediaserver/accepted-$license-version "$LICENSE_VERSION"
            # license accepted
            exit 0
        fi
        # error on decline license (give user chance to back up)
        db_input critical $COMPANY_NAME-mediaserver/error-$license
        ;;
    3)  # user has confirmed declining license
        echo "user did not accept the $license license" >&2
        exit 1
        ;;
    *)  # unknown state
        echo "$license license state unknown: $STATE" >&2
        exit 2
        ;;
    esac
    if db_go; then
        STATE=$(($STATE + 1))
    else
        STATE=$(($STATE - 1))
    fi
done

# proper exit (0 or 1) above
errmsg "$license license could not be presented / was not accepted"
exit 2
