#!/bin/bash -e

COMPANY_NAME=@customization.companyId@

. /usr/share/debconf/confmodule

if [ -n "$DEBIAN_SCRIPT_DEBUG" ]; then set -v -x; DEBIAN_SCRIPT_TRACE=1; fi
${DEBIAN_SCRIPT_TRACE:+ echo "#42#DEBUG# RUNNING $0 $*" 1>&2 }

export PATH=$PATH:/sbin:/usr/sbin:/bin:/usr/bin

BASE_DIR="/opt/$COMPANY_NAME/mediaserver"

ETC_DIR="$BASE_DIR/etc"
BIN_DIR="$BASE_DIR/bin"

CONFIG_FILE="$ETC_DIR/mediaserver.conf"
RUNTIME_CONFIG_FILE="$ETC_DIR/running_time.conf"
DB_PATH="$BASE_DIR/var/ecs.sqlite"

CFG_HELPER="$BIN_DIR/config_helper.sh $CONFIG_FILE"

if [[ -f $CONFIG_FILE ]]
then
    declare -i -r UPGRADING=1
else
    declare -i -r UPGRADING=0
fi

# Default MS parameters
PORT_DEFAULT="7001"
TRANSPORT_DEAULT="auto"
PUBLIC_IP_ENABLED_DEFAULT="auto"
CAMERA_SETTINGS_OPTIMIZATION_DEFAULT=true
STATISTICS_REPORT_ALLOWED_DEFAULT=true
SYSTEM_USER=$COMPANY_NAME

declare RUNTIME #< The assignment is placed hereinafter.

TARGET_DEVICE='@targetDevice@'
WITH_ROOT_TOOL='@withRootTool@'

# Acquire the runtime type (real, docker, chroot and so on) and store its name to the variable
# named outputVariableName.
getRuntimeType() # outputVariableName
{
    local -r outputVariableName="$1"; shift
    local -r runtime=$(systemd-detect-virt)

    if [[ $runtime == "" ]]
    then
        echo "Error detecting type of runtime." >&2
        return 1
    fi

    if [[ $runtime != "none" ]]
    then
        echo "Detected runtime type: $runtime." >&2
        eval "${outputVariableName}=$runtime"
    else
        eval "${outputVariableName}=real"
    fi

    return 0
}

getRuntimeType RUNTIME

isRpi()
{
    if [[ $TARGET_DEVICE == "linux_arm32" ]]
    then
        grep '^Hardware.*:.*BCM2835[[:space:]]*$' /proc/cpuinfo &>/dev/null
    else
        false
    fi
}

isLocalAddr()
{
    local -r hostname="$1"
    local addr=$(gethostip "$hostname" -d)

    if (( $? != 0 ))
    then
        addr="$hostname"
    fi

    [[ "$addr" =~ ^127.[0-9]+.[0-9]+.[0-9]+$ ]] && return 0

    ip -4 -o addr | awk '{gsub("/", " "); print $4;}' | grep "^$addr$" > /dev/null 2>&1
}

findFreePort()
{
    local -i port="$1"

    while true
    do
        netstat -nl4t | awk '{print $4;}' | grep ":$port" > /dev/null 2>&1
        if (( $? != 0 ))
        then
            echo "$port"
            return
        else
            port=$((port+10))
        fi
    done
}

checkNewSystem()
{
    local -r -i RETRY_COUNT=20
    local -i port="$1"
    local response

    for ((i = 1; i <= $RETRY_COUNT; i++))
    do
        echo "Checking if the server is running (attempt #$i)." >&2
        response=$(wget --quiet "http://localhost:$port/api/moduleInformation" -O-) && break
        sleep 1
    done

    if (( i > $RETRY_COUNT ))
    then
        echo "ERROR: Request GET /api/moduleInformation has failed." >&2
        return 1
    fi

    local -r c="[0-9a-z]"
    local -r localSystemIdRegex="\\{$c{8}-$c{4}-$c{4}-$c{4}-$c{12}\\}"
    # Find `"localSystemId": "{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}"` pattern in the JSON
    # response and assign the match to the variable. If no match was found, assign an empty string
    # to it.
    local -r localSystemIdDefinition=$(
        echo "$response" \
            |grep --extended-regexp --only-matching "\"localSystemId\":\s*\"$localSystemIdRegex\""
    )

    if [[ -z $localSystemIdDefinition ]]
    then
        echo "ERROR: Request GET /api/moduleInformation returned unexpected result." >&2
        return 1
    fi

    # Extract the value from `"localSystemId": "..."` and assign it to the variable.
    local -r localSystemIdValue=$(
        echo "$localSystemIdDefinition" \
            |grep --extended-regexp --only-matching "$localSystemIdRegex"
    )

    if [[ $localSystemIdValue != "{00000000-0000-0000-0000-000000000000}" ]]
    then
        return 1
    fi

    return 0
}

displayCompleteSetupHintIfNeeded()
{
    local -i port="$1"

    [[ $UPGRADING == 1 ]] && return

    if checkNewSystem $port
    then
        db_fset @customization.companyId@-mediaserver/complete-setup-hint seen false
        db_input critical @customization.companyId@-mediaserver/complete-setup-hint || true
        db_go
    fi
}

installModificationSpecificConfig()
{
    local -r config_file_path="${BASE_DIR}/share/configs/mediaserver.conf.$TARGET_DEVICE.template"

    if [[ -f ${config_file_path} ]] && [[ ! -f "${BASE_DIR}/etc/mediaserver.conf" ]]
    then
        cp  "${config_file_path}" "${BASE_DIR}/etc/mediaserver.conf"
    fi
}

# This is necessary because changed configuration options should take effect
# immediately.

systemctl stop $COMPANY_NAME-mediaserver || true

if [[ $WITH_ROOT_TOOL == 'true' ]]
then
    systemctl stop $COMPANY_NAME-root-tool || true
fi

case "$1" in
    configure)
        SYSTEM_NAME_DEFAULT=System_$RANDOM

        ECS_HOST="$($CFG_HELPER appserverHost)"
        if [ -n "$ECS_HOST" ]; then
            if isLocalAddr "$ECS_HOST"; then
                $CFG_HELPER appserverHost -d
                $CFG_HELPER appserverPort -d
                $CFG_HELPER appserverLogin -d
                $CFG_HELPER appserverPassword -d
            else
                $CFG_HELPER pendingSwitchToClusterMode "yes"
                $CFG_HELPER appserverPassword -d
            fi
        fi

        [ ! -d "$BASE_DIR/var" ] && mkdir -p "$BASE_DIR/var"

        if [[ $UPGRADING == 0 ]]
        then
            PORT="$($CFG_HELPER port)"
            [ -z "$PORT" ] && PORT=$(findFreePort $PORT_DEFAULT)
            $CFG_HELPER port "$PORT"

            if [ ! -f $DB_PATH ]
            then
                APPSERVER_PASSWORD="admin"
                $CFG_HELPER appserverPassword "$APPSERVER_PASSWORD"
                $CFG_HELPER lowPriorityPassword 1
            fi

            TRANSPORT="$($CFG_HELPER rtspTransport)"
            [ -z "$TRANSPORT" ] && TRANSPORT=$TRANSPORT_DEFAULT
            $CFG_HELPER rtspTransport "$TRANSPORT"

            $CFG_HELPER systemName ""

            CAMERA_SETTINGS_OPTIMIZATION="$($CFG_HELPER cameraSettingsOptimization)"
            [ -z "$CAMERA_SETTINGS_OPTIMIZATION" ] && CAMERA_SETTINGS_OPTIMIZATION=$CAMERA_SETTINGS_OPTIMIZATION_DEFAULT
            $CFG_HELPER cameraSettingsOptimization "$CAMERA_SETTINGS_OPTIMIZATION"

            STATISTICS_REPORT_ALLOWED="$($CFG_HELPER statisticsReportAllowed)"
            [ -z "$STATISTICS_REPORT_ALLOWED" ] && STATISTICS_REPORT_ALLOWED=$STATISTICS_REPORT_ALLOWED_DEFAULT
            $CFG_HELPER statisticsReportAllowed "$STATISTICS_REPORT_ALLOWED"
        else
            PORT="$($CFG_HELPER port)"
            [ -z "$PORT" ] && PORT=$(findFreePort $PORT_DEFAULT)
            $CFG_HELPER port "$PORT"

            SYSTEM_NAME="$($CFG_HELPER systemName)"
            [ -z "$SYSTEM_NAME" ] && $CFG_HELPER systemName "$SYSTEM_NAME_DEFAULT"
        fi

        groupadd --system "$SYSTEM_USER" 2>/dev/null || true
        useradd --no-user-group --system --gid "$SYSTEM_USER" "$SYSTEM_USER" 2>/dev/null || true
        usermod --groups video "$SYSTEM_USER" 2>/dev/null || true

        # Allow core dumps creation.
        chown "$SYSTEM_USER:$SYSTEM_USER" "$BIN_DIR"

        if [[ $WITH_ROOT_TOOL == 'true' ]]
        then
            chown "root:${SYSTEM_USER}" "${BIN_DIR}/root-tool-bin"
            chmod u+s "${BIN_DIR}/root-tool-bin"

            setcap CAP_NET_BIND_SERVICE=+eip "$BIN_DIR/mediaserver-bin"

            mkdir -p "${BASE_DIR}/var/log"
            chown -R "${SYSTEM_USER}:${SYSTEM_USER}" "${BASE_DIR}/var/log"
        fi

        touch "$RUNTIME_CONFIG_FILE"

  ;;

  abort-upgrade|abort-remove|abort-deconfigure)
  ;;

  *)
    echo "postinst called with unknown argument '$1'" 1>&2
    exit 1
  ;;
esac

# Dirty hack to prevent apport from catching our crash dumps.
systemctl disable apport &>/dev/null || true

systemctl stop apport &>/dev/null || true

[[ -L "${BASE_DIR}/lib/ffmpeg" ]] && unlink "${BASE_DIR}/lib/ffmpeg"

if isRpi
then
    # RPi requires specially compiled ffmpeg with mmal support - for RPi camera.
    ( cd "${BASE_DIR}/lib"; ln -s ffmpeg-rpi ffmpeg )

    bash "${BASE_DIR}/var/scripts/rpi/cam_setup.sh"

    # Plan a reboot after the package installation. This mark will be processed in install.sh.
    touch "/var/run/reboot-required"
else
    ( cd "${BASE_DIR}/lib"; ln -s ffmpeg-arm32 ffmpeg )
fi

installModificationSpecificConfig

# Systemd requires explicit enabling of the service to start it on boot.
if [[ $WITH_ROOT_TOOL == 'true' ]]
then
    systemctl enable $COMPANY_NAME-root-tool || exit $?
fi

systemctl enable $COMPANY_NAME-mediaserver || exit $?

# [out] SERVER_PID
# [out] SERVER_UID
getServerProcessInfo()
{
    if ! SERVER_PID=$(pidof mediaserver-bin)
    then
        return 1
    fi

    # Get UID of proccess with $SERVER_PID.
    if ! SERVER_UID=$(ps -h -eo uid -q $SERVER_PID | grep -o '[[:digit:]]\+')
    then
        return 1
    fi

    return 0
}

startServer()
{
    local SERVER_PID
    local SERVER_UID

    if [[ $WITH_ROOT_TOOL == 'true' ]]
    then
        systemctl start $COMPANY_NAME-root-tool || return $?
    fi

    systemctl start $COMPANY_NAME-mediaserver

    sleep 1
    if getServerProcessInfo
    then
        echo "Started service with PID=$SERVER_PID, UID=$SERVER_UID."
    else
        echo "WARNING: Server process not found" \
            "despite 'systemctl start ...' finished with zero exit status." \
            "This could be caused by the server crash or slow starting. " \
            "See Server logs: journalctl -u $COMPANY_NAME-mediaserver" \
            >&2
    fi
}

if [[ $RUNTIME != "docker" ]]
then
    if ! startServer
    then
        echo "ERROR: Unable to start Server." >&2
        exit 1
    fi

    displayCompleteSetupHintIfNeeded $PORT
fi
