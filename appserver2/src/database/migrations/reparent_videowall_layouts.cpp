#include "reparent_videowall_layouts.h"

#include <QtSql/QSqlQuery>

#include <database/api/db_layout_api.h>

#include <nx_ec/data/api_layout_data.h>

#include <nx/utils/uuid.h>
#include <nx/utils/log/log.h>

#include <utils/db/db_helper.h>

namespace ec2 {
namespace database {
namespace migrations {

namespace {

static const QString kLogPrefix("db::migration::");

void log(const QString& message)
{
    NX_LOG(kLogPrefix + message, cl_logINFO);
}

struct LayoutOnVideoWall
{
    QnUuid itemId;
    QnUuid layoutId;
    QnUuid videoWallId;
};

bool getLayoutsOnVideoWalls(const QSqlDatabase& database, QList<LayoutOnVideoWall>& data)
{
    QSqlQuery query(database);
    query.setForwardOnly(true);

    const QString queryStr = R"sql(
        SELECT
            item.guid as itemId,
            item.layout_guid as layoutId,
            item.videowall_guid as videoWallId
        FROM vms_videowall_item item
    )sql";

    if (!QnDbHelper::prepareSQLQuery(&query, queryStr, Q_FUNC_INFO))
        return false;

    if (!QnDbHelper::execSQLQuery(&query, Q_FUNC_INFO))
        return false;

    while (query.next())
    {
        LayoutOnVideoWall item;
        item.layoutId = QnUuid::fromRfc4122(query.value("layoutId").toByteArray());
        if (item.layoutId.isNull())
            continue;

        item.itemId = QnUuid::fromRfc4122(query.value("itemId").toByteArray());
        item.videoWallId = QnUuid::fromRfc4122(query.value("videoWallId").toByteArray());
        NX_ASSERT(!item.videoWallId.isNull());
        if (item.videoWallId.isNull())
            continue;

        data.push_back(item);
    }

    return true;
}

bool updateVideowallItem(const QSqlDatabase& database, const LayoutOnVideoWall& item)
{
    QSqlQuery query(database);

    const QString queryStr(R"sql(
        UPDATE vms_videowall_item
        SET layout_guid = :layoutId
        WHERE guid = :itemId;
    )sql");

    if (!QnDbHelper::prepareSQLQuery(&query, queryStr, Q_FUNC_INFO))
        return false;

    query.bindValue(":layoutId", item.layoutId.toRfc4122());
    query.bindValue(":itemId", item.itemId.toRfc4122());
    return QnDbHelper::execSQLQuery(&query, Q_FUNC_INFO);
}

bool getAutoGeneratedLayouts(const QSqlDatabase& database, QList<QnUuid>& ids)
{
    QSqlQuery query(database);
    query.setForwardOnly(true);

    const QString queryStr = R"sql(
        SELECT value, resource_guid
        FROM vms_kvpair
        WHERE name = "autoGenerated"
    )sql";
    if (!QnDbHelper::prepareSQLQuery(&query, queryStr, Q_FUNC_INFO))
        return false;

    if (!QnDbHelper::execSQLQuery(&query, Q_FUNC_INFO))
        return false;

    while (query.next())
    {
        const bool autogenerated = query.value("value").toBool();
        if (autogenerated)
            ids.push_back(QnUuid::fromRfc4122(query.value("resource_guid").toByteArray()));
    }

    return true;
}

bool markLayoutAsAutoGenerated(const QSqlDatabase& database, const QnUuid& layoutId)
{
    QSqlQuery query(database);

    const QString queryStr = R"sql(
        INSERT OR REPLACE INTO vms_kvpair
        (resource_guid, name, value)
        VALUES
        (?, "autoGenerated", "true")
    )sql";
    if (!QnDbHelper::prepareSQLQuery(&query, queryStr, Q_FUNC_INFO))
        return false;

    query.addBindValue(layoutId.toRfc4122());
    return QnDbHelper::execSQLQuery(&query, Q_FUNC_INFO);
}

bool reparentLayout(const QSqlDatabase& database, const LayoutOnVideoWall& item)
{
    ApiLayoutDataList layouts;
    if (!api::fetchLayouts(database, item.layoutId, layouts))
        return false;
    NX_ASSERT(layouts.size() == 1);

    for (auto& layout: layouts)
    {
        log(lit("Layout %1 (%2) parent id changed from %3 to %4")
            .arg(item.layoutId.toSimpleString())
            .arg(layout.name)
            .arg(layout.parentId.toSimpleString())
            .arg(item.videoWallId.toSimpleString())
        );
        layout.parentId = item.videoWallId;
        if (!api::saveLayout(database, layout))
            return false;
    }

    return true;
}

bool cloneLayout(const QSqlDatabase& database, const LayoutOnVideoWall& item)
{
    ApiLayoutDataList layouts;
    if (!api::fetchLayouts(database, item.layoutId, layouts))
        return false;
    NX_ASSERT(layouts.size() == 1);

    for (auto& layout: layouts)
    {
        log(lit("Clone layout %1 (%2)")
            .arg(layout.id.toSimpleString())
            .arg(layout.name)
        );

        // Create new layout as copy of existing.
        layout.id = QnUuid::createUuid();
        layout.parentId = item.videoWallId;

        // All item uuids must be generated as new
        for (auto& item: layout.items)
            item.id = QnUuid::createUuid();

        if (!api::saveLayout(database, layout))
            return false;

        LayoutOnVideoWall updatedItem(item);
        updatedItem.itemId = QnUuid::createUuid();

        if (!updateVideowallItem(database, updatedItem))
            return false;

        if (!markLayoutAsAutoGenerated(database, layout.id))
            return false;
    }

    return true;
}

} // namespace

bool reparentVideoWallLayouts(const QSqlDatabase& database)
{
    log(lit("Applying DB migration: reparent videowall layouts"));

    // Get all layouts on the videowall
    QList<LayoutOnVideoWall> videoWallItems;
    if (!getLayoutsOnVideoWalls(database, videoWallItems))
        return false;

    log(lit("Found %1 layouts on videowalls").arg(videoWallItems.size()));

    // Get all layouts in the database
    QList<QnUuid> autogenerated;
    if (!getAutoGeneratedLayouts(database, autogenerated))
        return false;

    log(lit("Found %1 auto-generated layouts").arg(autogenerated.size()));

    QSet<QnUuid> processed;
    for (const auto& item: videoWallItems)
    {
        log(lit("Processing layout %1").arg(item.layoutId.toSimpleString()));
        if (processed.contains(item.layoutId))
        {
            log(lit("Layout %1 is already processed").arg(item.layoutId.toSimpleString()));
            continue;
        }

        if (autogenerated.contains(item.layoutId))
        {
            log(lit("Layout %1 is auto-generated").arg(item.layoutId.toSimpleString()));

            // Autogenerated layouts must simply be reparented once
            if (!reparentLayout(database, item))
                return false;
            processed.insert(item.layoutId);
        }
        else
        {
            // Otherwise we clone each layout copy to a new layout
            if (!cloneLayout(database, item))
                return false;
        }
    }

    QSet<QnUuid> unused = autogenerated.toSet().subtract(processed);
    log(lit("Found %1 unused layouts").arg(unused.size()));

    for (const QnUuid& id: unused)
    {
        log(lit("Layout %1 is unused and will be removed").arg(id.toSimpleString()));
        if (!api::removeLayout(database, id))
            return false;
    }

    NX_LOG(lit("End of DB migration: reparent videowall layouts"), cl_logINFO);
    return true;
}

} // namespace migrations
} // namespace database
} // namespace ec2
