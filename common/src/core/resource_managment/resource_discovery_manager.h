#ifndef QN_RESOURCE_DISCOVERY_MANAGER_H
#define QN_RESOURCE_DISCOVERY_MANAGER_H

#include <memory> // for auto_ptr

#include <QtCore/QThread>
#include <QtCore/QTimer>
#include <QtNetwork/QAuthenticator>

#include <api/media_server_cameras_data.h>

#include <core/resource/resource.h>

#include <utils/common/long_runnable.h>
#include <utils/network/netstate.h>
#include <utils/network/nettools.h>

class QnAbstractResourceSearcher;
class QnAbstractDTSSearcher;

struct QnManualCameraInfo
{
    QnManualCameraInfo(const QUrl& url, const QAuthenticator& auth, const QString& resType);
    QList<QnResourcePtr> checkHostAddr() const;

    QUrl url;
    QnResourceTypePtr resType;
    QAuthenticator auth;
    QnAbstractResourceSearcher* searcher;
};
typedef QMap<QString, QnManualCameraInfo> QnManualCamerasMap;

class QnAbstractResourceSearcher;

class QnResourceDiscoveryManager;
/*!
    This class instance only calls QnResourceDiscoveryManager::doResourceDiscoverIteration from QnResourceDiscoveryManager thread, 
    since we cannot move QnResourceDiscoveryManager object to QnResourceDiscoveryManager thread (weird...)
*/
class QnResourceDiscoveryManagerTimeoutDelegate
:
    public QObject
{
    Q_OBJECT

public:
    QnResourceDiscoveryManagerTimeoutDelegate( QnResourceDiscoveryManager* discoveryManager );

public slots:
    void onTimeout();

private:
    QnResourceDiscoveryManager* m_discoveryManager;
};

class CameraDriverRestrictionList;

// this class just searches for new resources
// it uses others plugins
// it puts result into resource pool
class QnResourceDiscoveryManager : public QnLongRunnable, public QnResourceFactory
{
    Q_OBJECT;

public:
    enum State
    {
        initialSearch,
        periodicSearch
    };


    typedef QList<QnAbstractResourceSearcher*> ResourceSearcherList;

    QnResourceDiscoveryManager( const CameraDriverRestrictionList* cameraDriverRestrictionList = NULL );
    ~QnResourceDiscoveryManager();

    static QnResourceDiscoveryManager* instance();

    // this function returns only new devices( not in all_devices list);
    //QnResourceList result();
    void addDeviceServer(QnAbstractResourceSearcher* serv);
    void addDTSServer(QnAbstractDTSSearcher* serv);
    void setResourceProcessor(QnResourceProcessor* processor);

    QnResourcePtr createResource(QnId resourceTypeId, const QnResourceParameters &parameters);

    virtual void pleaseStop();

    void setReady(bool ready);

    bool registerManualCameras(const QnManualCamerasMap& cameras);
    void setDisabledVendors(const QStringList& vendors);
    bool containManualCamera(const QString& uniqId);

    /**
     * @brief searchResources               Start manual camera search process. Status of the process will be regularly saved to
     *                                      m_searchProcessStatuses, results will be incrementally added to m_searchProcessResults.
     * @param processUuid                   Unique id of the process. Generated by the process owner.
     * @param startAddr                     Start address. Can be IPv4 address, url, rstp link.
     * @param endAddr                       End address. Can be IPv4 address or empty.
     * @param auth                          Login and password to http authentication.
     * @param port                          Queried port. Can be 0 - in this case default http port (80) will be used.
     * @param threadCount                   Number of threads that will be used for searching.
     */
    void searchResources(const QUuid &processUuid, const QString &startAddr, const QString &endAddr, const QAuthenticator& auth, int port, int threadCount);

    /**
     * @brief getSearchStatus               Get status of the manual camera search process. Thread-safe.
     * @param searchProcessUuid             Uuid of the process.
     * @return                              Status of the process.
     */
    QnManualCameraSearchStatus getSearchStatus(const QUuid &searchProcessUuid);

    /**
     * @brief setSearchStatus               Set or update status of the manual camera search process. Thread-safe.
     * @param searchProcessUuid             Uuid of the process.
     * @param status                        New status value.
     * @param mustExist                     Check existence of the process before updating.
     * @return                              True if value was set, false otherwise (e.g. if process was stopped in the meantime).
     */
    bool setSearchStatus(const QUuid &searchProcessUuid, const QnManualCameraSearchStatus &status, bool mustExist = true);

    /**
     * @brief getSearchResults              Get results of the manual camera search process. Thread-safe.
     * @param searchProcessUuid             Uuid of the process.
     * @return                              Results of the process.
     */
    QnManualCameraSearchCameraList getSearchResults(const QUuid &searchProcessUuid);

    /**
     * @brief setSearchResults              Set or update results of the manual camera search process. Thread-safe.
     * @param searchProcessUuid             Uuid of the process.
     * @param status                        New results value.
     * @param mustExist                     Check existence of the process before updating.
     * @return                              True if value was set, false otherwise (e.g. if process was stopped in the meantime).
     */
    bool setSearchResults(const QUuid &searchProcessUuid, const QnManualCameraSearchCameraList &results, bool mustExist = true);

    /**
     * @brief isSearchActive                Check if there is running manual camera search process with the uuid provided.
     * @param searchProcessUuid             Uuid of the process.
     * @return                              True if process is running, false otherwise.
     */
    bool isSearchActive(const QUuid &searchProcessUuid);

    /**
     * @brief clearSearch                   Clear search status and results for the running manual camera search process.
     *                                      Running process (if any) will be stopped as soon as check its own status.
     * @param searchProcessUuid             Uuid of the process.
     */
    void clearSearch(const QUuid &searchProcessUuid);

    /**
     * @brief resourceExistsInPool          Check if found camera is already exists in pool by its unique ID. For onvif cameras host is also checked.
     * @param resource                      Camera resource.
     * @return                              True if resource is already in resource pool, false otherwise.
     */
    bool resourceExistsInPool(const QnResourcePtr &resource) const;

    //!This method MUST be called from non-GUI thread, since it can block for some time
    void doResourceDiscoverIteration();

    static void init(QnResourceDiscoveryManager* instance);
    State state() const;
public slots:
    virtual void start( Priority priority = InheritPriority ) override;

protected:
    QMutex m_discoveryMutex;

    /** Mutex that is used to synchronize access to manual camera addition progress. */
    QMutex m_searchProcessMutex;

    unsigned int m_runNumber;

    virtual void run();
    virtual bool processDiscoveredResources(QnResourceList& resources);

signals:
    void localSearchDone();
    void localInterfacesChanged();
    void CameraIPConflict(QHostAddress addr, QStringList macAddrList);

private slots:
    void onInitAsyncFinished(QnResourcePtr res, bool initialized);
    void at_resourceDeleted(const QnResourcePtr& resource);

private:
    void updateLocalNetworkInterfaces();

    // returns new resources( not from pool) or updates some in resource pool
    QnResourceList findNewResources();

    void appendManualDiscoveredResources(QnResourceList& resources);
    void dtsAssignment();

    QMutex m_searchersListMutex;
    ResourceSearcherList m_searchersList;
    QnResourceProcessor* m_resourceProcessor;
    QnManualCamerasMap m_manualCameraMap;

    bool m_server;
    volatile bool m_ready;

    QList<QHostAddress> m_allLocalAddresses;


    QVector<QnAbstractDTSSearcher*> m_dstList;
    QSet<QString> m_disabledVendorsForAutoSearch;
    static QnResourceDiscoveryManager* m_instance;

    std::auto_ptr<QTimer> m_timer;
    State m_state;
    QSet<QString> m_recentlyDeleted;
    const CameraDriverRestrictionList* m_cameraDriverRestrictionList;

    QHash<QUuid, QnManualCameraSearchStatus> m_searchProcessStatuses;
    QHash<QUuid, QnManualCameraSearchCameraList> m_searchProcessResults;
};

#endif //QN_RESOURCE_DISCOVERY_MANAGER_H
