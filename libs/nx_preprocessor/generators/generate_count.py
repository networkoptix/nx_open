#!/usr/bin/env python3

## Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/

import argparse
import os
import sys


MACRO_NAME = "NX_PP_ARGS_COUNT"
HELPER_MACRO_NAME = "_NX_PP_ARGS_COUNT_MATCH"
NUMBERS_PER_LINE = 10
INDENT = " " * 4


def generate(n: int):
    yield f"// This file is generated by {os.path.basename(__file__)}. DO NOT EDIT BY HAND!\n"
    yield "#pragma once\n\n"

    yield "#include \"misc.h\"\n\n"

    yield f"// Get number of arguments. Supports up to {n} items (MaxN).\n"
    yield f"#define {MACRO_NAME}(...) \\\n"
    yield f"{INDENT}NX_PP_EXPAND({HELPER_MACRO_NAME}(__VA_ARGS__, \\\n"

    i = n
    numbers_in_line = n % NUMBERS_PER_LINE
    if numbers_in_line == 0:
        numbers_in_line = NUMBERS_PER_LINE

    while i > 0:
        line = INDENT * 2
        for _ in range(numbers_in_line):
            line += f"{i}, "
            i -= 1

        if i > 0:
            line += "\\\n"
        else:
            line = line[:-2] + "))\n"
        yield line
        numbers_in_line = 10

    yield "\n"

    # The helper macro gets N + MaxN arguments from the main macro. It skips MaxN arguments and
    # returns the next one. Since the main macro passes test args first and then a number sequence
    # from MaxN to N, MaxN + 1 argument matches to exact number ot test arguments.
    yield f"#define {HELPER_MACRO_NAME}( \\\n"
    i = 1
    while i <= n:
        line = INDENT
        for _ in range(NUMBERS_PER_LINE if (n - i + 1) > NUMBERS_PER_LINE else (n - i + 1)):
            line += f"_{i}, "
            i += 1
        line += "\\\n"
        yield line
    yield f"{INDENT}N, ...) N\n"


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("n", type=int, help="Maximum number of items")
    parser.add_argument(
        "--output", "-o", type=argparse.FileType("w"), default=sys.stdout, help="Output file name")
    args = parser.parse_args()
    args.output.writelines(generate(args.n))


if __name__ == "__main__":
    main()
