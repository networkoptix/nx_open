// -* mode: groovy -*-
// Continuous integration main jenkinsfile

import org.codehaus.groovy.runtime.StackTraceUtils

@Library('jenkins')
import org.nx.jenkins.SlaveRunner


NX_REPOSITORY_CREDENTIALS_ID = 'nx-repository-readonly'
PROJECT_NAME = 'ci'
config = null


def main() {
	try {
		unsafe_main()
	} catch (Exception|Error x) {
		echo "Error running test: $x"
		echo "---- sanitized stack: ----"
		org.codehaus.groovy.runtime.StackTraceUtils.sanitize(x).printStackTrace()
		echo "---- full stack: ----"
		x.printStackTrace()
		echo "---------------------"
		if (config) {
			echo "Emailing $config.jenkins_developers"
			def email_body = [
				"Jenkins CI project for branch $env.BRANCH_NAME is failed:",
				"$x",
				"${env.BUILD_URL}console",
			]
			emailext(
				body: email_body.join('\n'),
				subject: "Jenkins CI $env.BRANCH_NAME project is failed",
				to: config.jenkins_developers.join(' '),
			)
			currentBuild.result = 'ABORTED'  // FAILED is used to indicate build failure
		}
		throw x
	}

	pragprog displayLanguageCode: 'en', indicateBuildResult: true
}

def unsafe_main() {
	def action = params?.action ?: 'update_parameters'
	def dry_run = params?.dry_run ?: true
	def clean_build = params?.clean_build ?: false
	def clean_only = params?.clean_only ?: false
	def slave_runner
	def requested_platform_names

	echo "Action: $action"

	stage('Checkout master') {
		node ('master') {
			def config_text = libraryResource 'config.yaml'
			config = readYaml text: config_text
			echo "config = $config"

			update_job_parameters(config)
			if (action == 'update_parameters') return

			requested_platform_names = config.platforms.keySet().findAll{ params.get(it) }
			echo "Will run $requested_platform_names"
			
			slave_runner = new SlaveRunner(this, config)
			slave_runner.run_master_node_preparations()
		}
	}

	if (action != 'update_parameters') {
		increment_build_number()

		def branch = env.BRANCH_NAME
		def run_params = [
			project_name: PROJECT_NAME,
			jenkins_build_url: env.BUILD_URL,
			requested_platform_names: requested_platform_names,
			branch: branch,
			build_num: env.BUILD_NUMBER.toInteger(),
			configuration: config.ci.configuration,
			customization: config.ci.customization,
			cloud_group: config.ci.cloud_group,
			dry_run: dry_run,
			clean_build: clean_build,
			clean_only: clean_only,
		]
		slave_runner.run_slaves_stage(run_params)
		echo "revision_info: $slave_runner.revision_info"
	}
}

// Change parameters for currently running jenkins task; next run will require and use these parameters.
def update_job_parameters(config) {
	def job_params = [
		choice(name: 'action', choices: ['build', 'update_parameters'].join('\n'), description: 'Action to run'),
		booleanParam(name: 'dry_run', defaultValue: false,
			description: 'Do dry run: do not build nor test anything, just test this Jenkinsfile'),
		booleanParam(name: 'clean_build', defaultValue: false, description: 'Do clean build (clean workspaces before builds)'),
		booleanParam(name: 'clean_only', defaultValue: false, description: 'Clean workspaces only, do not do anything else'),
	]
	def platform_params = config.platforms.collect {
		booleanParam(name: it.key, defaultValue: it.key in config.ci.default_platforms, description: "Build $it.key platform")
	}
	properties([
		parameters(job_params + platform_params),
		disableConcurrentBuilds(),
		buildDiscarder(logRotator(daysToKeepStr: config.ci.days_to_keep_old_build.toString())),
	])
}

def increment_build_number() {
	build job: 'buildnumber', propagate: false
}

// ==============================================================================
main()
// ==============================================================================
