/* soapC.cpp
   Generated by gSOAP 2.8.55 for generated_with_wsdl2h/axis_soap_event_action

gSOAP XML Web services tools
Copyright (C) 2000-2017, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.8.55 2017-12-13 21:38:37 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", soap->header, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->version && soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, ""))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->version && soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (soap->header == NULL)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (soap->fault == NULL)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap);
		if (soap->fault == NULL)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", "");
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
			return soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
		return NULL;
	}
	return soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)(void*)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Detail == NULL)
		{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap);
			soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Detail->__any;
	}
	if (soap->fault->detail == NULL)
	{	soap->fault->detail = soap_new_SOAP_ENV__Detail(soap);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
	}
	return (const char**)(void*)&soap->fault->detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Detail)
		return soap->fault->SOAP_ENV__Detail->__any;
	if (soap->fault->detail)
		return soap->fault->detail->__any;
	return NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if ((soap->error && soap->error != SOAP_TAG_MISMATCH) || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
#ifndef WITH_NOIDREF
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_ULONG64:
		return soap_in_ULONG64(soap, NULL, NULL, "xsd:unsignedLong");
	case SOAP_TYPE_dateTime:
		return soap_in_dateTime(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_bool:
		return soap_in_bool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_ns6__FaultCodesType:
		return soap_in_ns6__FaultCodesType(soap, NULL, NULL, "ns6:FaultCodesType");
	case SOAP_TYPE_ns6__RelationshipType:
		return soap_in_ns6__RelationshipType(soap, NULL, NULL, "ns6:RelationshipType");
	case SOAP_TYPE_ns1__ScheduledType:
		return soap_in_ns1__ScheduledType(soap, NULL, NULL, "ns1:ScheduledType");
	case SOAP_TYPE_ns6__FaultCodesType__:
		return soap_in_ns6__FaultCodesType__(soap, NULL, NULL, "ns6:FaultCodesType");
	case SOAP_TYPE_ns6__RelationshipType__:
		return soap_in_ns6__RelationshipType__(soap, NULL, NULL, "ns6:RelationshipType");
	case SOAP_TYPE_ns2__SimpleTopicExpression__:
		return soap_in_ns2__SimpleTopicExpression__(soap, NULL, NULL, "ns2:SimpleTopicExpression");
	case SOAP_TYPE_ns2__SimpleTopicExpression:
		return soap_in_ns2__SimpleTopicExpression(soap, NULL, NULL, "xsd:QName");
	case SOAP_TYPE_ns2__ConcreteTopicExpression__:
		return soap_in_ns2__ConcreteTopicExpression__(soap, NULL, NULL, "ns2:ConcreteTopicExpression");
	case SOAP_TYPE_ns2__ConcreteTopicExpression:
		return soap_in_ns2__ConcreteTopicExpression(soap, NULL, NULL, "ns2:ConcreteTopicExpression");
	case SOAP_TYPE_ns2__FullTopicExpression__:
		return soap_in_ns2__FullTopicExpression__(soap, NULL, NULL, "ns2:FullTopicExpression");
	case SOAP_TYPE_ns2__FullTopicExpression:
		return soap_in_ns2__FullTopicExpression(soap, NULL, NULL, "ns2:FullTopicExpression");
	case SOAP_TYPE_ns1__ScheduledType__:
		return soap_in_ns1__ScheduledType__(soap, NULL, NULL, "ns1:ScheduledType");
	case SOAP_TYPE_ns6__FaultCodesOpenEnumType:
		return soap_in_ns6__FaultCodesOpenEnumType(soap, NULL, NULL, "ns6:FaultCodesOpenEnumType");
	case SOAP_TYPE_ns6__RelationshipTypeOpenEnum:
		return soap_in_ns6__RelationshipTypeOpenEnum(soap, NULL, NULL, "ns6:RelationshipTypeOpenEnum");
	case SOAP_TYPE_ns3__AbsoluteOrRelativeTimeType:
		return soap_in_ns3__AbsoluteOrRelativeTimeType(soap, NULL, NULL, "ns3:AbsoluteOrRelativeTimeType");
	case SOAP_TYPE_ns6__ProblemActionType:
		return soap_in_ns6__ProblemActionType(soap, NULL, NULL, "ns6:ProblemActionType");
	case SOAP_TYPE_ns6__AttributedQNameType:
		return soap_in_ns6__AttributedQNameType(soap, NULL, NULL, "ns6:AttributedQNameType");
	case SOAP_TYPE_ns6__AttributedUnsignedLongType:
		return soap_in_ns6__AttributedUnsignedLongType(soap, NULL, NULL, "ns6:AttributedUnsignedLongType");
	case SOAP_TYPE_ns6__AttributedURIType:
		return soap_in_ns6__AttributedURIType(soap, NULL, NULL, "ns6:AttributedURIType");
	case SOAP_TYPE_ns6__RelatesToType:
		return soap_in_ns6__RelatesToType(soap, NULL, NULL, "ns6:RelatesToType");
	case SOAP_TYPE_ns6__MetadataType:
		return soap_in_ns6__MetadataType(soap, NULL, NULL, "ns6:MetadataType");
	case SOAP_TYPE_ns6__ReferenceParametersType:
		return soap_in_ns6__ReferenceParametersType(soap, NULL, NULL, "ns6:ReferenceParametersType");
	case SOAP_TYPE_ns6__EndpointReferenceType:
		return soap_in_ns6__EndpointReferenceType(soap, NULL, NULL, "ns6:EndpointReferenceType");
	case SOAP_TYPE_ns5__UsedActionRule:
		return soap_in_ns5__UsedActionRule(soap, NULL, NULL, "ns5:UsedActionRule");
	case SOAP_TYPE_ns5__UsedByActionRules:
		return soap_in_ns5__UsedByActionRules(soap, NULL, NULL, "ns5:UsedByActionRules");
	case SOAP_TYPE_ns5__UsedActionConfiguration:
		return soap_in_ns5__UsedActionConfiguration(soap, NULL, NULL, "ns5:UsedActionConfiguration");
	case SOAP_TYPE_ns5__UsedByActionConfigurations:
		return soap_in_ns5__UsedByActionConfigurations(soap, NULL, NULL, "ns5:UsedByActionConfigurations");
	case SOAP_TYPE_ns5__ActionTemplateParameter:
		return soap_in_ns5__ActionTemplateParameter(soap, NULL, NULL, "ns5:ActionTemplateParameter");
	case SOAP_TYPE_ns5__ActionTemplateParameters:
		return soap_in_ns5__ActionTemplateParameters(soap, NULL, NULL, "ns5:ActionTemplateParameters");
	case SOAP_TYPE_ns5__ActionTemplate:
		return soap_in_ns5__ActionTemplate(soap, NULL, NULL, "ns5:ActionTemplate");
	case SOAP_TYPE_ns5__ActionParameter:
		return soap_in_ns5__ActionParameter(soap, NULL, NULL, "ns5:ActionParameter");
	case SOAP_TYPE_ns5__ActionTemplates:
		return soap_in_ns5__ActionTemplates(soap, NULL, NULL, "ns5:ActionTemplates");
	case SOAP_TYPE_ns5__ActionParameters:
		return soap_in_ns5__ActionParameters(soap, NULL, NULL, "ns5:ActionParameters");
	case SOAP_TYPE_ns5__ActionConfiguration:
		return soap_in_ns5__ActionConfiguration(soap, NULL, NULL, "ns5:ActionConfiguration");
	case SOAP_TYPE_ns5__NewActionConfiguration:
		return soap_in_ns5__NewActionConfiguration(soap, NULL, NULL, "ns5:NewActionConfiguration");
	case SOAP_TYPE_ns5__ActionConfigurations:
		return soap_in_ns5__ActionConfigurations(soap, NULL, NULL, "ns5:ActionConfigurations");
	case SOAP_TYPE_ns5__RecipientTemplate:
		return soap_in_ns5__RecipientTemplate(soap, NULL, NULL, "ns5:RecipientTemplate");
	case SOAP_TYPE_ns5__RecipientTemplates:
		return soap_in_ns5__RecipientTemplates(soap, NULL, NULL, "ns5:RecipientTemplates");
	case SOAP_TYPE_ns5__RecipientConfigurations:
		return soap_in_ns5__RecipientConfigurations(soap, NULL, NULL, "ns5:RecipientConfigurations");
	case SOAP_TYPE_ns5__RecipientConfiguration:
		return soap_in_ns5__RecipientConfiguration(soap, NULL, NULL, "ns5:RecipientConfiguration");
	case SOAP_TYPE_ns5__NewRecipientConfiguration:
		return soap_in_ns5__NewRecipientConfiguration(soap, NULL, NULL, "ns5:NewRecipientConfiguration");
	case SOAP_TYPE_ns5__ActionRule:
		return soap_in_ns5__ActionRule(soap, NULL, NULL, "ns5:ActionRule");
	case SOAP_TYPE_ns5__ActionRules:
		return soap_in_ns5__ActionRules(soap, NULL, NULL, "ns5:ActionRules");
	case SOAP_TYPE_ns5__Conditions:
		return soap_in_ns5__Conditions(soap, NULL, NULL, "ns5:Conditions");
	case SOAP_TYPE_ns5__NewActionRule:
		return soap_in_ns5__NewActionRule(soap, NULL, NULL, "ns5:NewActionRule");
	case SOAP_TYPE_ns4__BaseFaultType:
		return soap_in_ns4__BaseFaultType(soap, NULL, NULL, "ns4:BaseFaultType");
	case SOAP_TYPE_ns3__ResumeFailedFaultType:
		return soap_in_ns3__ResumeFailedFaultType(soap, NULL, NULL, "ns3:ResumeFailedFaultType");
	case SOAP_TYPE_ns3__PauseFailedFaultType:
		return soap_in_ns3__PauseFailedFaultType(soap, NULL, NULL, "ns3:PauseFailedFaultType");
	case SOAP_TYPE_ns3__UnableToDestroySubscriptionFaultType:
		return soap_in_ns3__UnableToDestroySubscriptionFaultType(soap, NULL, NULL, "ns3:UnableToDestroySubscriptionFaultType");
	case SOAP_TYPE_ns3__UnacceptableTerminationTimeFaultType:
		return soap_in_ns3__UnacceptableTerminationTimeFaultType(soap, NULL, NULL, "ns3:UnacceptableTerminationTimeFaultType");
	case SOAP_TYPE_ns3__UnableToCreatePullPointFaultType:
		return soap_in_ns3__UnableToCreatePullPointFaultType(soap, NULL, NULL, "ns3:UnableToCreatePullPointFaultType");
	case SOAP_TYPE_ns3__UnableToDestroyPullPointFaultType:
		return soap_in_ns3__UnableToDestroyPullPointFaultType(soap, NULL, NULL, "ns3:UnableToDestroyPullPointFaultType");
	case SOAP_TYPE_ns3__UnableToGetMessagesFaultType:
		return soap_in_ns3__UnableToGetMessagesFaultType(soap, NULL, NULL, "ns3:UnableToGetMessagesFaultType");
	case SOAP_TYPE_ns3__NoCurrentMessageOnTopicFaultType:
		return soap_in_ns3__NoCurrentMessageOnTopicFaultType(soap, NULL, NULL, "ns3:NoCurrentMessageOnTopicFaultType");
	case SOAP_TYPE_ns3__UnacceptableInitialTerminationTimeFaultType:
		return soap_in_ns3__UnacceptableInitialTerminationTimeFaultType(soap, NULL, NULL, "ns3:UnacceptableInitialTerminationTimeFaultType");
	case SOAP_TYPE_ns3__NotifyMessageNotSupportedFaultType:
		return soap_in_ns3__NotifyMessageNotSupportedFaultType(soap, NULL, NULL, "ns3:NotifyMessageNotSupportedFaultType");
	case SOAP_TYPE_ns3__UnsupportedPolicyRequestFaultType:
		return soap_in_ns3__UnsupportedPolicyRequestFaultType(soap, NULL, NULL, "ns3:UnsupportedPolicyRequestFaultType");
	case SOAP_TYPE_ns3__UnrecognizedPolicyRequestFaultType:
		return soap_in_ns3__UnrecognizedPolicyRequestFaultType(soap, NULL, NULL, "ns3:UnrecognizedPolicyRequestFaultType");
	case SOAP_TYPE_ns3__InvalidMessageContentExpressionFaultType:
		return soap_in_ns3__InvalidMessageContentExpressionFaultType(soap, NULL, NULL, "ns3:InvalidMessageContentExpressionFaultType");
	case SOAP_TYPE_ns3__InvalidProducerPropertiesExpressionFaultType:
		return soap_in_ns3__InvalidProducerPropertiesExpressionFaultType(soap, NULL, NULL, "ns3:InvalidProducerPropertiesExpressionFaultType");
	case SOAP_TYPE_ns3__MultipleTopicsSpecifiedFaultType:
		return soap_in_ns3__MultipleTopicsSpecifiedFaultType(soap, NULL, NULL, "ns3:MultipleTopicsSpecifiedFaultType");
	case SOAP_TYPE_ns3__TopicNotSupportedFaultType:
		return soap_in_ns3__TopicNotSupportedFaultType(soap, NULL, NULL, "ns3:TopicNotSupportedFaultType");
	case SOAP_TYPE_ns3__InvalidTopicExpressionFaultType:
		return soap_in_ns3__InvalidTopicExpressionFaultType(soap, NULL, NULL, "ns3:InvalidTopicExpressionFaultType");
	case SOAP_TYPE_ns3__TopicExpressionDialectUnknownFaultType:
		return soap_in_ns3__TopicExpressionDialectUnknownFaultType(soap, NULL, NULL, "ns3:TopicExpressionDialectUnknownFaultType");
	case SOAP_TYPE_ns3__InvalidFilterFaultType:
		return soap_in_ns3__InvalidFilterFaultType(soap, NULL, NULL, "ns3:InvalidFilterFaultType");
	case SOAP_TYPE_ns3__SubscribeCreationFailedFaultType:
		return soap_in_ns3__SubscribeCreationFailedFaultType(soap, NULL, NULL, "ns3:SubscribeCreationFailedFaultType");
	case SOAP_TYPE_ns3__NotificationMessageHolderType:
		return soap_in_ns3__NotificationMessageHolderType(soap, NULL, NULL, "ns3:NotificationMessageHolderType");
	case SOAP_TYPE_ns3__SubscriptionPolicyType:
		return soap_in_ns3__SubscriptionPolicyType(soap, NULL, NULL, "ns3:SubscriptionPolicyType");
	case SOAP_TYPE_ns3__FilterType:
		return soap_in_ns3__FilterType(soap, NULL, NULL, "ns3:FilterType");
	case SOAP_TYPE_ns3__TopicExpressionType:
		return soap_in_ns3__TopicExpressionType(soap, NULL, NULL, "ns3:TopicExpressionType");
	case SOAP_TYPE_ns3__QueryExpressionType:
		return soap_in_ns3__QueryExpressionType(soap, NULL, NULL, "ns3:QueryExpressionType");
	case SOAP_TYPE_ns2__TopicSetType:
		return soap_in_ns2__TopicSetType(soap, NULL, NULL, "ns2:TopicSetType");
	case SOAP_TYPE_ns2__TopicType:
		return soap_in_ns2__TopicType(soap, NULL, NULL, "ns2:TopicType");
	case SOAP_TYPE_ns2__TopicNamespaceType:
		return soap_in_ns2__TopicNamespaceType(soap, NULL, NULL, "ns2:TopicNamespaceType");
	case SOAP_TYPE_ns2__QueryExpressionType:
		return soap_in_ns2__QueryExpressionType(soap, NULL, NULL, "ns2:QueryExpressionType");
	case SOAP_TYPE_ns2__ExtensibleDocumented:
		return soap_in_ns2__ExtensibleDocumented(soap, NULL, NULL, "ns2:ExtensibleDocumented");
	case SOAP_TYPE_ns2__Documentation:
		return soap_in_ns2__Documentation(soap, NULL, NULL, "ns2:Documentation");
	case SOAP_TYPE_ns1__ScheduleFilter:
		return soap_in_ns1__ScheduleFilter(soap, NULL, NULL, "ns1:ScheduleFilter");
	case SOAP_TYPE_ns1__ICalendar:
		return soap_in_ns1__ICalendar(soap, NULL, NULL, "ns1:ICalendar");
	case SOAP_TYPE_ns1__Schedule:
		return soap_in_ns1__Schedule(soap, NULL, NULL, "ns1:Schedule");
	case SOAP_TYPE_ns1__ScheduledEvent:
		return soap_in_ns1__ScheduledEvent(soap, NULL, NULL, "ns1:ScheduledEvent");
	case SOAP_TYPE_ns1__ScheduledEvents:
		return soap_in_ns1__ScheduledEvents(soap, NULL, NULL, "ns1:ScheduledEvents");
	case SOAP_TYPE_ns1__NewScheduledEvent:
		return soap_in_ns1__NewScheduledEvent(soap, NULL, NULL, "ns1:NewScheduledEvent");
	case SOAP_TYPE_xsd__unsignedLong:
		return soap_in_xsd__unsignedLong(soap, NULL, NULL, "xsd:unsignedLong");
	case SOAP_TYPE_xsd__token_:
		return soap_in_xsd__token_(soap, NULL, NULL, "xsd:token");
	case SOAP_TYPE_xsd__token:
		return soap_in_xsd__token(soap, NULL, NULL, "xsd:token");
	case SOAP_TYPE_xsd__string:
		return soap_in_xsd__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_xsd__nonNegativeInteger_:
		return soap_in_xsd__nonNegativeInteger_(soap, NULL, NULL, "xsd:nonNegativeInteger");
	case SOAP_TYPE_xsd__nonNegativeInteger:
		return soap_in_xsd__nonNegativeInteger(soap, NULL, NULL, "xsd:nonNegativeInteger");
	case SOAP_TYPE_xsd__integer_:
		return soap_in_xsd__integer_(soap, NULL, NULL, "xsd:integer");
	case SOAP_TYPE_xsd__integer:
		return soap_in_xsd__integer(soap, NULL, NULL, "xsd:integer");
	case SOAP_TYPE_xsd__int:
		return soap_in_xsd__int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_xsd__duration_:
		return soap_in_xsd__duration_(soap, NULL, NULL, "xsd:duration");
	case SOAP_TYPE_xsd__duration:
		return soap_in_xsd__duration(soap, NULL, NULL, "xsd:duration");
	case SOAP_TYPE_xsd__dateTime:
		return soap_in_xsd__dateTime(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_xsd__boolean:
		return soap_in_xsd__boolean(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_xsd__anyURI_:
		return soap_in_xsd__anyURI_(soap, NULL, NULL, "xsd:anyURI");
	case SOAP_TYPE_xsd__anyURI:
		return soap_in_xsd__anyURI(soap, NULL, NULL, "xsd:anyURI");
	case SOAP_TYPE_xsd__QName_:
		return soap_in_xsd__QName_(soap, NULL, NULL, "xsd:QName");
	case SOAP_TYPE_xsd__NCName_:
		return soap_in_xsd__NCName_(soap, NULL, NULL, "xsd:NCName");
	case SOAP_TYPE_xsd__NCName:
		return soap_in_xsd__NCName(soap, NULL, NULL, "xsd:NCName");
	case SOAP_TYPE_xsd__QName:
		return soap_in_xsd__QName(soap, NULL, NULL, "xsd:QName");
	case SOAP_TYPE_std__string:
		return soap_in_std__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_xsd__anyAttribute:
		return soap_in_xsd__anyAttribute(soap, NULL, NULL, "xsd:anyAttribute");
	case SOAP_TYPE_xsd__anyType:
		return soap_in_xsd__anyType(soap, NULL, NULL, "xsd:anyType");
	case SOAP_TYPE_PointerTo_ns5__RemoveActionRule:
		return soap_in_PointerTo_ns5__RemoveActionRule(soap, NULL, NULL, "ns5:RemoveActionRule");
	case SOAP_TYPE_PointerTo_ns5__GetActionRules:
		return soap_in_PointerTo_ns5__GetActionRules(soap, NULL, NULL, "ns5:GetActionRules");
	case SOAP_TYPE_PointerTo_ns5__AddActionRule:
		return soap_in_PointerTo_ns5__AddActionRule(soap, NULL, NULL, "ns5:AddActionRule");
	case SOAP_TYPE_PointerTo_ns5__GetRecipientConfigurations:
		return soap_in_PointerTo_ns5__GetRecipientConfigurations(soap, NULL, NULL, "ns5:GetRecipientConfigurations");
	case SOAP_TYPE_PointerTo_ns5__RemoveRecipientConfiguration:
		return soap_in_PointerTo_ns5__RemoveRecipientConfiguration(soap, NULL, NULL, "ns5:RemoveRecipientConfiguration");
	case SOAP_TYPE_PointerTo_ns5__AddRecipientConfiguration:
		return soap_in_PointerTo_ns5__AddRecipientConfiguration(soap, NULL, NULL, "ns5:AddRecipientConfiguration");
	case SOAP_TYPE_PointerTo_ns5__GetRecipientTemplates:
		return soap_in_PointerTo_ns5__GetRecipientTemplates(soap, NULL, NULL, "ns5:GetRecipientTemplates");
	case SOAP_TYPE_PointerTo_ns5__GetActionConfigurations:
		return soap_in_PointerTo_ns5__GetActionConfigurations(soap, NULL, NULL, "ns5:GetActionConfigurations");
	case SOAP_TYPE_PointerTo_ns5__RemoveActionConfiguration:
		return soap_in_PointerTo_ns5__RemoveActionConfiguration(soap, NULL, NULL, "ns5:RemoveActionConfiguration");
	case SOAP_TYPE_PointerTo_ns5__AddActionConfiguration:
		return soap_in_PointerTo_ns5__AddActionConfiguration(soap, NULL, NULL, "ns5:AddActionConfiguration");
	case SOAP_TYPE_PointerTo_ns5__GetActionTemplates:
		return soap_in_PointerTo_ns5__GetActionTemplates(soap, NULL, NULL, "ns5:GetActionTemplates");
	case SOAP_TYPE_PointerTo_ns1__ChangeVirtualInputState:
		return soap_in_PointerTo_ns1__ChangeVirtualInputState(soap, NULL, NULL, "ns1:ChangeVirtualInputState");
	case SOAP_TYPE_PointerTo_ns1__GetScheduledEvents:
		return soap_in_PointerTo_ns1__GetScheduledEvents(soap, NULL, NULL, "ns1:GetScheduledEvents");
	case SOAP_TYPE_PointerTo_ns1__RemoveScheduledEvent:
		return soap_in_PointerTo_ns1__RemoveScheduledEvent(soap, NULL, NULL, "ns1:RemoveScheduledEvent");
	case SOAP_TYPE_PointerTo_ns1__AddScheduledEvent:
		return soap_in_PointerTo_ns1__AddScheduledEvent(soap, NULL, NULL, "ns1:AddScheduledEvent");
	case SOAP_TYPE_PointerTo_ns1__GetEventInstances:
		return soap_in_PointerTo_ns1__GetEventInstances(soap, NULL, NULL, "ns1:GetEventInstances");
	case SOAP_TYPE_PointerTons3__TopicExpressionDialectUnknownFaultType:
		return soap_in_PointerTons3__TopicExpressionDialectUnknownFaultType(soap, NULL, NULL, "ns3:TopicExpressionDialectUnknownFaultType");
	case SOAP_TYPE_PointerTo_ns5__RecipientTemplateNotFoundFault:
		return soap_in_PointerTo_ns5__RecipientTemplateNotFoundFault(soap, NULL, NULL, "ns5:RecipientTemplateNotFoundFault");
	case SOAP_TYPE_PointerTo_ns5__RecipientConfigurationNotFoundFault:
		return soap_in_PointerTo_ns5__RecipientConfigurationNotFoundFault(soap, NULL, NULL, "ns5:RecipientConfigurationNotFoundFault");
	case SOAP_TYPE_PointerTo_ns5__ParametersMissmatchFault:
		return soap_in_PointerTo_ns5__ParametersMissmatchFault(soap, NULL, NULL, "ns5:ParametersMissmatchFault");
	case SOAP_TYPE_PointerTons3__InvalidTopicExpressionFaultType:
		return soap_in_PointerTons3__InvalidTopicExpressionFaultType(soap, NULL, NULL, "ns3:InvalidTopicExpressionFaultType");
	case SOAP_TYPE_PointerTons3__InvalidMessageContentExpressionFaultType:
		return soap_in_PointerTons3__InvalidMessageContentExpressionFaultType(soap, NULL, NULL, "ns3:InvalidMessageContentExpressionFaultType");
	case SOAP_TYPE_PointerTons3__InvalidFilterFaultType:
		return soap_in_PointerTons3__InvalidFilterFaultType(soap, NULL, NULL, "ns3:InvalidFilterFaultType");
	case SOAP_TYPE_PointerTo_ns5__InvalidConditionFilterFault:
		return soap_in_PointerTo_ns5__InvalidConditionFilterFault(soap, NULL, NULL, "ns5:InvalidConditionFilterFault");
	case SOAP_TYPE_PointerTo_ns5__InvalidActivationTimeoutFault:
		return soap_in_PointerTo_ns5__InvalidActivationTimeoutFault(soap, NULL, NULL, "ns5:InvalidActivationTimeoutFault");
	case SOAP_TYPE_PointerTo_ns5__InvalidActionConfigurationFault:
		return soap_in_PointerTo_ns5__InvalidActionConfigurationFault(soap, NULL, NULL, "ns5:InvalidActionConfigurationFault");
	case SOAP_TYPE_PointerTo_ns5__InsufficientActivationRuleFault:
		return soap_in_PointerTo_ns5__InsufficientActivationRuleFault(soap, NULL, NULL, "ns5:InsufficientActivationRuleFault");
	case SOAP_TYPE_PointerTo_ns5__ActionTemplateNotFoundFault:
		return soap_in_PointerTo_ns5__ActionTemplateNotFoundFault(soap, NULL, NULL, "ns5:ActionTemplateNotFoundFault");
	case SOAP_TYPE_PointerTo_ns5__ActionRuleNotFoundFault:
		return soap_in_PointerTo_ns5__ActionRuleNotFoundFault(soap, NULL, NULL, "ns5:ActionRuleNotFoundFault");
	case SOAP_TYPE_PointerTo_ns5__ActionConfigurationNotFoundFault:
		return soap_in_PointerTo_ns5__ActionConfigurationNotFoundFault(soap, NULL, NULL, "ns5:ActionConfigurationNotFoundFault");
	case SOAP_TYPE_PointerTo_ns5__ActionConfigurationIsInUseFault:
		return soap_in_PointerTo_ns5__ActionConfigurationIsInUseFault(soap, NULL, NULL, "ns5:ActionConfigurationIsInUseFault");
	case SOAP_TYPE_PointerTo_ns1__ScheduledEventNotFoundFault:
		return soap_in_PointerTo_ns1__ScheduledEventNotFoundFault(soap, NULL, NULL, "ns1:ScheduledEventNotFoundFault");
	case SOAP_TYPE_PointerTo_ns1__ScheduledEventAlreadyExistsFault:
		return soap_in_PointerTo_ns1__ScheduledEventAlreadyExistsFault(soap, NULL, NULL, "ns1:ScheduledEventAlreadyExistsFault");
	case SOAP_TYPE_PointerTo_ns1__InvalidScheduledEventIDFault:
		return soap_in_PointerTo_ns1__InvalidScheduledEventIDFault(soap, NULL, NULL, "ns1:InvalidScheduledEventIDFault");
	case SOAP_TYPE_PointerTo_ns1__InvalidScheduleFault:
		return soap_in_PointerTo_ns1__InvalidScheduleFault(soap, NULL, NULL, "ns1:InvalidScheduleFault");
	case SOAP_TYPE_PointerToxsd__NCName:
		return soap_in_PointerToxsd__NCName(soap, NULL, NULL, "xsd:NCName");
	case SOAP_TYPE_PointerTons2__ConcreteTopicExpression:
		return soap_in_PointerTons2__ConcreteTopicExpression(soap, NULL, NULL, "ns2:ConcreteTopicExpression");
	case SOAP_TYPE_PointerToxsd__QName:
		return soap_in_PointerToxsd__QName(soap, NULL, NULL, "xsd:QName");
	case SOAP_TYPE_PointerTons2__TopicType:
		return soap_in_PointerTons2__TopicType(soap, NULL, NULL, "ns2:TopicType");
	case SOAP_TYPE_PointerTons2__QueryExpressionType:
		return soap_in_PointerTons2__QueryExpressionType(soap, NULL, NULL, "ns2:QueryExpressionType");
	case SOAP_TYPE_PointerToxsd__anyURI:
		return soap_in_PointerToxsd__anyURI(soap, NULL, NULL, "xsd:anyURI");
	case SOAP_TYPE_PointerTons6__MetadataType:
		return soap_in_PointerTons6__MetadataType(soap, NULL, NULL, "ns6:MetadataType");
	case SOAP_TYPE_PointerTons6__ReferenceParametersType:
		return soap_in_PointerTons6__ReferenceParametersType(soap, NULL, NULL, "ns6:ReferenceParametersType");
	case SOAP_TYPE_PointerTons6__AttributedURIType:
		return soap_in_PointerTons6__AttributedURIType(soap, NULL, NULL, "ns6:AttributedURIType");
	case SOAP_TYPE_PointerTons5__UsedByActionRules:
		return soap_in_PointerTons5__UsedByActionRules(soap, NULL, NULL, "ns5:UsedByActionRules");
	case SOAP_TYPE_PointerTons5__ActionRules:
		return soap_in_PointerTons5__ActionRules(soap, NULL, NULL, "ns5:ActionRules");
	case SOAP_TYPE_PointerTons5__NewActionRule:
		return soap_in_PointerTons5__NewActionRule(soap, NULL, NULL, "ns5:NewActionRule");
	case SOAP_TYPE_PointerTons5__RecipientConfigurations:
		return soap_in_PointerTons5__RecipientConfigurations(soap, NULL, NULL, "ns5:RecipientConfigurations");
	case SOAP_TYPE_PointerTons5__NewRecipientConfiguration:
		return soap_in_PointerTons5__NewRecipientConfiguration(soap, NULL, NULL, "ns5:NewRecipientConfiguration");
	case SOAP_TYPE_PointerTons5__RecipientTemplates:
		return soap_in_PointerTons5__RecipientTemplates(soap, NULL, NULL, "ns5:RecipientTemplates");
	case SOAP_TYPE_PointerTons5__ActionConfigurations:
		return soap_in_PointerTons5__ActionConfigurations(soap, NULL, NULL, "ns5:ActionConfigurations");
	case SOAP_TYPE_PointerTons5__NewActionConfiguration:
		return soap_in_PointerTons5__NewActionConfiguration(soap, NULL, NULL, "ns5:NewActionConfiguration");
	case SOAP_TYPE_PointerTons5__ActionTemplates:
		return soap_in_PointerTons5__ActionTemplates(soap, NULL, NULL, "ns5:ActionTemplates");
	case SOAP_TYPE_PointerTons5__UsedActionRule:
		return soap_in_PointerTons5__UsedActionRule(soap, NULL, NULL, "ns5:UsedActionRule");
	case SOAP_TYPE_PointerTons5__UsedActionConfiguration:
		return soap_in_PointerTons5__UsedActionConfiguration(soap, NULL, NULL, "ns5:UsedActionConfiguration");
	case SOAP_TYPE_PointerTons5__ActionTemplateParameter:
		return soap_in_PointerTons5__ActionTemplateParameter(soap, NULL, NULL, "ns5:ActionTemplateParameter");
	case SOAP_TYPE_PointerTons5__ActionTemplate:
		return soap_in_PointerTons5__ActionTemplate(soap, NULL, NULL, "ns5:ActionTemplate");
	case SOAP_TYPE_PointerTons5__ActionParameter:
		return soap_in_PointerTons5__ActionParameter(soap, NULL, NULL, "ns5:ActionParameter");
	case SOAP_TYPE_PointerTons5__ActionConfiguration:
		return soap_in_PointerTons5__ActionConfiguration(soap, NULL, NULL, "ns5:ActionConfiguration");
	case SOAP_TYPE_PointerTons5__ActionTemplateParameters:
		return soap_in_PointerTons5__ActionTemplateParameters(soap, NULL, NULL, "ns5:ActionTemplateParameters");
	case SOAP_TYPE_PointerTons5__RecipientTemplate:
		return soap_in_PointerTons5__RecipientTemplate(soap, NULL, NULL, "ns5:RecipientTemplate");
	case SOAP_TYPE_PointerTons5__RecipientConfiguration:
		return soap_in_PointerTons5__RecipientConfiguration(soap, NULL, NULL, "ns5:RecipientConfiguration");
	case SOAP_TYPE_PointerTons5__ActionParameters:
		return soap_in_PointerTons5__ActionParameters(soap, NULL, NULL, "ns5:ActionParameters");
	case SOAP_TYPE_PointerTons5__ActionRule:
		return soap_in_PointerTons5__ActionRule(soap, NULL, NULL, "ns5:ActionRule");
	case SOAP_TYPE_PointerToxsd__integer:
		return soap_in_PointerToxsd__integer(soap, NULL, NULL, "xsd:integer");
	case SOAP_TYPE_PointerToxsd__duration:
		return soap_in_PointerToxsd__duration(soap, NULL, NULL, "xsd:duration");
	case SOAP_TYPE_PointerTons5__Conditions:
		return soap_in_PointerTons5__Conditions(soap, NULL, NULL, "ns5:Conditions");
	case SOAP_TYPE_PointerTo_ns4__BaseFaultType_FaultCause:
		return soap_in_PointerTo_ns4__BaseFaultType_FaultCause(soap, NULL, NULL, "ns4:BaseFaultType-FaultCause");
	case SOAP_TYPE_PointerTo_xml__lang:
		return soap_in_PointerTo_xml__lang(soap, NULL, NULL, "xml:lang");
	case SOAP_TYPE_PointerTo_ns4__BaseFaultType_ErrorCode:
		return soap_in_PointerTo_ns4__BaseFaultType_ErrorCode(soap, NULL, NULL, "ns4:BaseFaultType-ErrorCode");
	case SOAP_TYPE_PointerToxsd__nonNegativeInteger:
		return soap_in_PointerToxsd__nonNegativeInteger(soap, NULL, NULL, "xsd:nonNegativeInteger");
	case SOAP_TYPE_PointerTo_ns3__Subscribe_SubscriptionPolicy:
		return soap_in_PointerTo_ns3__Subscribe_SubscriptionPolicy(soap, NULL, NULL, "ns3:Subscribe-SubscriptionPolicy");
	case SOAP_TYPE_PointerTons3__AbsoluteOrRelativeTimeType:
		return soap_in_PointerTons3__AbsoluteOrRelativeTimeType(soap, NULL, NULL, "ns3:AbsoluteOrRelativeTimeType");
	case SOAP_TYPE_PointerTons3__NotificationMessageHolderType:
		return soap_in_PointerTons3__NotificationMessageHolderType(soap, NULL, NULL, "ns3:NotificationMessageHolderType");
	case SOAP_TYPE_PointerTodateTime:
		return soap_in_PointerTodateTime(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_PointerTons3__SubscriptionPolicyType:
		return soap_in_PointerTons3__SubscriptionPolicyType(soap, NULL, NULL, "ns3:SubscriptionPolicyType");
	case SOAP_TYPE_PointerTons3__FilterType:
		return soap_in_PointerTons3__FilterType(soap, NULL, NULL, "ns3:FilterType");
	case SOAP_TYPE_PointerTobool:
		return soap_in_PointerTobool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_PointerTons3__TopicExpressionType:
		return soap_in_PointerTons3__TopicExpressionType(soap, NULL, NULL, "ns3:TopicExpressionType");
	case SOAP_TYPE_PointerTons6__EndpointReferenceType:
		return soap_in_PointerTons6__EndpointReferenceType(soap, NULL, NULL, "ns6:EndpointReferenceType");
	case SOAP_TYPE_PointerTons2__Documentation:
		return soap_in_PointerTons2__Documentation(soap, NULL, NULL, "ns2:Documentation");
	case SOAP_TYPE_PointerTons1__ScheduledEvents:
		return soap_in_PointerTons1__ScheduledEvents(soap, NULL, NULL, "ns1:ScheduledEvents");
	case SOAP_TYPE_PointerTons1__ScheduleFilter:
		return soap_in_PointerTons1__ScheduleFilter(soap, NULL, NULL, "ns1:ScheduleFilter");
	case SOAP_TYPE_PointerTons1__NewScheduledEvent:
		return soap_in_PointerTons1__NewScheduledEvent(soap, NULL, NULL, "ns1:NewScheduledEvent");
	case SOAP_TYPE_PointerTons2__TopicSetType:
		return soap_in_PointerTons2__TopicSetType(soap, NULL, NULL, "ns2:TopicSetType");
	case SOAP_TYPE_PointerTons1__ScheduledType:
		return soap_in_PointerTons1__ScheduledType(soap, NULL, NULL, "ns1:ScheduledType");
	case SOAP_TYPE_PointerTons1__ICalendar:
		return soap_in_PointerTons1__ICalendar(soap, NULL, NULL, "ns1:ICalendar");
	case SOAP_TYPE_PointerTons1__ScheduledEvent:
		return soap_in_PointerTons1__ScheduledEvent(soap, NULL, NULL, "ns1:ScheduledEvent");
	case SOAP_TYPE_PointerTons1__Schedule:
		return soap_in_PointerTons1__Schedule(soap, NULL, NULL, "ns1:Schedule");
	case SOAP_TYPE_PointerTostd__string:
		return soap_in_PointerTostd__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
#else
	*type = 0;
#endif
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "ns6:FaultCodesType"))
		{	*type = SOAP_TYPE_ns6__FaultCodesType__;
			return soap_in_ns6__FaultCodesType__(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:RelationshipType"))
		{	*type = SOAP_TYPE_ns6__RelationshipType__;
			return soap_in_ns6__RelationshipType__(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:SimpleTopicExpression"))
		{	*type = SOAP_TYPE_ns2__SimpleTopicExpression__;
			return soap_in_ns2__SimpleTopicExpression__(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	*type = SOAP_TYPE_ns2__SimpleTopicExpression;
			return soap_in_ns2__SimpleTopicExpression(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ConcreteTopicExpression"))
		{	*type = SOAP_TYPE_ns2__ConcreteTopicExpression__;
			return soap_in_ns2__ConcreteTopicExpression__(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ConcreteTopicExpression"))
		{	*type = SOAP_TYPE_ns2__ConcreteTopicExpression;
			return soap_in_ns2__ConcreteTopicExpression(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:FullTopicExpression"))
		{	*type = SOAP_TYPE_ns2__FullTopicExpression__;
			return soap_in_ns2__FullTopicExpression__(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:FullTopicExpression"))
		{	*type = SOAP_TYPE_ns2__FullTopicExpression;
			return soap_in_ns2__FullTopicExpression(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ScheduledType"))
		{	*type = SOAP_TYPE_ns1__ScheduledType__;
			return soap_in_ns1__ScheduledType__(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:FaultCodesOpenEnumType"))
		{	*type = SOAP_TYPE_ns6__FaultCodesOpenEnumType;
			return soap_in_ns6__FaultCodesOpenEnumType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:RelationshipTypeOpenEnum"))
		{	*type = SOAP_TYPE_ns6__RelationshipTypeOpenEnum;
			return soap_in_ns6__RelationshipTypeOpenEnum(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:AbsoluteOrRelativeTimeType"))
		{	*type = SOAP_TYPE_ns3__AbsoluteOrRelativeTimeType;
			return soap_in_ns3__AbsoluteOrRelativeTimeType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:ProblemActionType"))
		{	*type = SOAP_TYPE_ns6__ProblemActionType;
			return soap_in_ns6__ProblemActionType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:AttributedQNameType"))
		{	*type = SOAP_TYPE_ns6__AttributedQNameType;
			return soap_in_ns6__AttributedQNameType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:AttributedUnsignedLongType"))
		{	*type = SOAP_TYPE_ns6__AttributedUnsignedLongType;
			return soap_in_ns6__AttributedUnsignedLongType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:AttributedURIType"))
		{	*type = SOAP_TYPE_ns6__AttributedURIType;
			return soap_in_ns6__AttributedURIType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:RelatesToType"))
		{	*type = SOAP_TYPE_ns6__RelatesToType;
			return soap_in_ns6__RelatesToType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:MetadataType"))
		{	*type = SOAP_TYPE_ns6__MetadataType;
			return soap_in_ns6__MetadataType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:ReferenceParametersType"))
		{	*type = SOAP_TYPE_ns6__ReferenceParametersType;
			return soap_in_ns6__ReferenceParametersType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:EndpointReferenceType"))
		{	*type = SOAP_TYPE_ns6__EndpointReferenceType;
			return soap_in_ns6__EndpointReferenceType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:UsedActionRule"))
		{	*type = SOAP_TYPE_ns5__UsedActionRule;
			return soap_in_ns5__UsedActionRule(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:UsedByActionRules"))
		{	*type = SOAP_TYPE_ns5__UsedByActionRules;
			return soap_in_ns5__UsedByActionRules(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:UsedActionConfiguration"))
		{	*type = SOAP_TYPE_ns5__UsedActionConfiguration;
			return soap_in_ns5__UsedActionConfiguration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:UsedByActionConfigurations"))
		{	*type = SOAP_TYPE_ns5__UsedByActionConfigurations;
			return soap_in_ns5__UsedByActionConfigurations(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:ActionTemplateParameter"))
		{	*type = SOAP_TYPE_ns5__ActionTemplateParameter;
			return soap_in_ns5__ActionTemplateParameter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:ActionTemplateParameters"))
		{	*type = SOAP_TYPE_ns5__ActionTemplateParameters;
			return soap_in_ns5__ActionTemplateParameters(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:ActionTemplate"))
		{	*type = SOAP_TYPE_ns5__ActionTemplate;
			return soap_in_ns5__ActionTemplate(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:ActionParameter"))
		{	*type = SOAP_TYPE_ns5__ActionParameter;
			return soap_in_ns5__ActionParameter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:ActionTemplates"))
		{	*type = SOAP_TYPE_ns5__ActionTemplates;
			return soap_in_ns5__ActionTemplates(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:ActionParameters"))
		{	*type = SOAP_TYPE_ns5__ActionParameters;
			return soap_in_ns5__ActionParameters(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:ActionConfiguration"))
		{	*type = SOAP_TYPE_ns5__ActionConfiguration;
			return soap_in_ns5__ActionConfiguration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:NewActionConfiguration"))
		{	*type = SOAP_TYPE_ns5__NewActionConfiguration;
			return soap_in_ns5__NewActionConfiguration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:ActionConfigurations"))
		{	*type = SOAP_TYPE_ns5__ActionConfigurations;
			return soap_in_ns5__ActionConfigurations(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:RecipientTemplate"))
		{	*type = SOAP_TYPE_ns5__RecipientTemplate;
			return soap_in_ns5__RecipientTemplate(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:RecipientTemplates"))
		{	*type = SOAP_TYPE_ns5__RecipientTemplates;
			return soap_in_ns5__RecipientTemplates(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:RecipientConfigurations"))
		{	*type = SOAP_TYPE_ns5__RecipientConfigurations;
			return soap_in_ns5__RecipientConfigurations(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:RecipientConfiguration"))
		{	*type = SOAP_TYPE_ns5__RecipientConfiguration;
			return soap_in_ns5__RecipientConfiguration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:NewRecipientConfiguration"))
		{	*type = SOAP_TYPE_ns5__NewRecipientConfiguration;
			return soap_in_ns5__NewRecipientConfiguration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:ActionRule"))
		{	*type = SOAP_TYPE_ns5__ActionRule;
			return soap_in_ns5__ActionRule(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:ActionRules"))
		{	*type = SOAP_TYPE_ns5__ActionRules;
			return soap_in_ns5__ActionRules(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:Conditions"))
		{	*type = SOAP_TYPE_ns5__Conditions;
			return soap_in_ns5__Conditions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:NewActionRule"))
		{	*type = SOAP_TYPE_ns5__NewActionRule;
			return soap_in_ns5__NewActionRule(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:BaseFaultType"))
		{	*type = SOAP_TYPE_ns4__BaseFaultType;
			return soap_in_ns4__BaseFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:ResumeFailedFaultType"))
		{	*type = SOAP_TYPE_ns3__ResumeFailedFaultType;
			return soap_in_ns3__ResumeFailedFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:PauseFailedFaultType"))
		{	*type = SOAP_TYPE_ns3__PauseFailedFaultType;
			return soap_in_ns3__PauseFailedFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:UnableToDestroySubscriptionFaultType"))
		{	*type = SOAP_TYPE_ns3__UnableToDestroySubscriptionFaultType;
			return soap_in_ns3__UnableToDestroySubscriptionFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:UnacceptableTerminationTimeFaultType"))
		{	*type = SOAP_TYPE_ns3__UnacceptableTerminationTimeFaultType;
			return soap_in_ns3__UnacceptableTerminationTimeFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:UnableToCreatePullPointFaultType"))
		{	*type = SOAP_TYPE_ns3__UnableToCreatePullPointFaultType;
			return soap_in_ns3__UnableToCreatePullPointFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:UnableToDestroyPullPointFaultType"))
		{	*type = SOAP_TYPE_ns3__UnableToDestroyPullPointFaultType;
			return soap_in_ns3__UnableToDestroyPullPointFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:UnableToGetMessagesFaultType"))
		{	*type = SOAP_TYPE_ns3__UnableToGetMessagesFaultType;
			return soap_in_ns3__UnableToGetMessagesFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:NoCurrentMessageOnTopicFaultType"))
		{	*type = SOAP_TYPE_ns3__NoCurrentMessageOnTopicFaultType;
			return soap_in_ns3__NoCurrentMessageOnTopicFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:UnacceptableInitialTerminationTimeFaultType"))
		{	*type = SOAP_TYPE_ns3__UnacceptableInitialTerminationTimeFaultType;
			return soap_in_ns3__UnacceptableInitialTerminationTimeFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:NotifyMessageNotSupportedFaultType"))
		{	*type = SOAP_TYPE_ns3__NotifyMessageNotSupportedFaultType;
			return soap_in_ns3__NotifyMessageNotSupportedFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:UnsupportedPolicyRequestFaultType"))
		{	*type = SOAP_TYPE_ns3__UnsupportedPolicyRequestFaultType;
			return soap_in_ns3__UnsupportedPolicyRequestFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:UnrecognizedPolicyRequestFaultType"))
		{	*type = SOAP_TYPE_ns3__UnrecognizedPolicyRequestFaultType;
			return soap_in_ns3__UnrecognizedPolicyRequestFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:InvalidMessageContentExpressionFaultType"))
		{	*type = SOAP_TYPE_ns3__InvalidMessageContentExpressionFaultType;
			return soap_in_ns3__InvalidMessageContentExpressionFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:InvalidProducerPropertiesExpressionFaultType"))
		{	*type = SOAP_TYPE_ns3__InvalidProducerPropertiesExpressionFaultType;
			return soap_in_ns3__InvalidProducerPropertiesExpressionFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:MultipleTopicsSpecifiedFaultType"))
		{	*type = SOAP_TYPE_ns3__MultipleTopicsSpecifiedFaultType;
			return soap_in_ns3__MultipleTopicsSpecifiedFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:TopicNotSupportedFaultType"))
		{	*type = SOAP_TYPE_ns3__TopicNotSupportedFaultType;
			return soap_in_ns3__TopicNotSupportedFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:InvalidTopicExpressionFaultType"))
		{	*type = SOAP_TYPE_ns3__InvalidTopicExpressionFaultType;
			return soap_in_ns3__InvalidTopicExpressionFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:TopicExpressionDialectUnknownFaultType"))
		{	*type = SOAP_TYPE_ns3__TopicExpressionDialectUnknownFaultType;
			return soap_in_ns3__TopicExpressionDialectUnknownFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:InvalidFilterFaultType"))
		{	*type = SOAP_TYPE_ns3__InvalidFilterFaultType;
			return soap_in_ns3__InvalidFilterFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:SubscribeCreationFailedFaultType"))
		{	*type = SOAP_TYPE_ns3__SubscribeCreationFailedFaultType;
			return soap_in_ns3__SubscribeCreationFailedFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:NotificationMessageHolderType"))
		{	*type = SOAP_TYPE_ns3__NotificationMessageHolderType;
			return soap_in_ns3__NotificationMessageHolderType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:SubscriptionPolicyType"))
		{	*type = SOAP_TYPE_ns3__SubscriptionPolicyType;
			return soap_in_ns3__SubscriptionPolicyType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:FilterType"))
		{	*type = SOAP_TYPE_ns3__FilterType;
			return soap_in_ns3__FilterType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:TopicExpressionType"))
		{	*type = SOAP_TYPE_ns3__TopicExpressionType;
			return soap_in_ns3__TopicExpressionType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:QueryExpressionType"))
		{	*type = SOAP_TYPE_ns3__QueryExpressionType;
			return soap_in_ns3__QueryExpressionType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:TopicSetType"))
		{	*type = SOAP_TYPE_ns2__TopicSetType;
			return soap_in_ns2__TopicSetType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:TopicType"))
		{	*type = SOAP_TYPE_ns2__TopicType;
			return soap_in_ns2__TopicType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:TopicNamespaceType"))
		{	*type = SOAP_TYPE_ns2__TopicNamespaceType;
			return soap_in_ns2__TopicNamespaceType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:QueryExpressionType"))
		{	*type = SOAP_TYPE_ns2__QueryExpressionType;
			return soap_in_ns2__QueryExpressionType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ExtensibleDocumented"))
		{	*type = SOAP_TYPE_ns2__ExtensibleDocumented;
			return soap_in_ns2__ExtensibleDocumented(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:Documentation"))
		{	*type = SOAP_TYPE_ns2__Documentation;
			return soap_in_ns2__Documentation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ScheduleFilter"))
		{	*type = SOAP_TYPE_ns1__ScheduleFilter;
			return soap_in_ns1__ScheduleFilter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ICalendar"))
		{	*type = SOAP_TYPE_ns1__ICalendar;
			return soap_in_ns1__ICalendar(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Schedule"))
		{	*type = SOAP_TYPE_ns1__Schedule;
			return soap_in_ns1__Schedule(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ScheduledEvent"))
		{	*type = SOAP_TYPE_ns1__ScheduledEvent;
			return soap_in_ns1__ScheduledEvent(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ScheduledEvents"))
		{	*type = SOAP_TYPE_ns1__ScheduledEvents;
			return soap_in_ns1__ScheduledEvents(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:NewScheduledEvent"))
		{	*type = SOAP_TYPE_ns1__NewScheduledEvent;
			return soap_in_ns1__NewScheduledEvent(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedLong"))
		{	*type = SOAP_TYPE_xsd__unsignedLong;
			return soap_in_xsd__unsignedLong(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:token"))
		{	*type = SOAP_TYPE_xsd__token_;
			return soap_in_xsd__token_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:token"))
		{	*type = SOAP_TYPE_xsd__token;
			return soap_in_xsd__token(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_xsd__string;
			return soap_in_xsd__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:nonNegativeInteger"))
		{	*type = SOAP_TYPE_xsd__nonNegativeInteger_;
			return soap_in_xsd__nonNegativeInteger_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:nonNegativeInteger"))
		{	*type = SOAP_TYPE_xsd__nonNegativeInteger;
			return soap_in_xsd__nonNegativeInteger(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:integer"))
		{	*type = SOAP_TYPE_xsd__integer_;
			return soap_in_xsd__integer_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:integer"))
		{	*type = SOAP_TYPE_xsd__integer;
			return soap_in_xsd__integer(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_xsd__int;
			return soap_in_xsd__int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:duration"))
		{	*type = SOAP_TYPE_xsd__duration_;
			return soap_in_xsd__duration_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:duration"))
		{	*type = SOAP_TYPE_xsd__duration;
			return soap_in_xsd__duration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:dateTime"))
		{	*type = SOAP_TYPE_xsd__dateTime;
			return soap_in_xsd__dateTime(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_xsd__boolean;
			return soap_in_xsd__boolean(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:anyURI"))
		{	*type = SOAP_TYPE_xsd__anyURI_;
			return soap_in_xsd__anyURI_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:anyURI"))
		{	*type = SOAP_TYPE_xsd__anyURI;
			return soap_in_xsd__anyURI(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	*type = SOAP_TYPE_xsd__QName_;
			return soap_in_xsd__QName_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:NCName"))
		{	*type = SOAP_TYPE_xsd__NCName_;
			return soap_in_xsd__NCName_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:NCName"))
		{	*type = SOAP_TYPE_xsd__NCName;
			return soap_in_xsd__NCName(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	*type = SOAP_TYPE_xsd__QName;
			return soap_in_xsd__QName(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_std__string;
			return soap_in_std__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedLong"))
		{	*type = SOAP_TYPE_ULONG64;
			return soap_in_ULONG64(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:dateTime"))
		{	*type = SOAP_TYPE_dateTime;
			return soap_in_dateTime(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_bool;
			return soap_in_bool(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:FaultCodesType"))
		{	*type = SOAP_TYPE_ns6__FaultCodesType;
			return soap_in_ns6__FaultCodesType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:RelationshipType"))
		{	*type = SOAP_TYPE_ns6__RelationshipType;
			return soap_in_ns6__RelationshipType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ScheduledType"))
		{	*type = SOAP_TYPE_ns1__ScheduledType;
			return soap_in_ns1__ScheduledType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:anyAttribute"))
		{	*type = SOAP_TYPE_xsd__anyAttribute;
			return soap_in_xsd__anyAttribute(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:anyType"))
		{	*type = SOAP_TYPE_xsd__anyType;
			return soap_in_xsd__anyType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "ns2:TopicNamespaceType-Topic"))
		{	*type = SOAP_TYPE__ns2__TopicNamespaceType_Topic;
			return soap_in__ns2__TopicNamespaceType_Topic(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:BaseFaultType-FaultCause"))
		{	*type = SOAP_TYPE__ns4__BaseFaultType_FaultCause;
			return soap_in__ns4__BaseFaultType_FaultCause(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:BaseFaultType-Description"))
		{	*type = SOAP_TYPE__ns4__BaseFaultType_Description;
			return soap_in__ns4__BaseFaultType_Description(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:BaseFaultType-ErrorCode"))
		{	*type = SOAP_TYPE__ns4__BaseFaultType_ErrorCode;
			return soap_in__ns4__BaseFaultType_ErrorCode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:Subscribe-SubscriptionPolicy"))
		{	*type = SOAP_TYPE__ns3__Subscribe_SubscriptionPolicy;
			return soap_in__ns3__Subscribe_SubscriptionPolicy(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:NotificationMessageHolderType-Message"))
		{	*type = SOAP_TYPE__ns3__NotificationMessageHolderType_Message;
			return soap_in__ns3__NotificationMessageHolderType_Message(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:InvalidActivationTimeoutFault"))
		{	*type = SOAP_TYPE__ns5__InvalidActivationTimeoutFault;
			return soap_in__ns5__InvalidActivationTimeoutFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:ActionRuleNotFoundFault"))
		{	*type = SOAP_TYPE__ns5__ActionRuleNotFoundFault;
			return soap_in__ns5__ActionRuleNotFoundFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:InsufficientActivationRuleFault"))
		{	*type = SOAP_TYPE__ns5__InsufficientActivationRuleFault;
			return soap_in__ns5__InsufficientActivationRuleFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:InvalidConditionFilterFault"))
		{	*type = SOAP_TYPE__ns5__InvalidConditionFilterFault;
			return soap_in__ns5__InvalidConditionFilterFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:ActionConfigurationIsInUseFault"))
		{	*type = SOAP_TYPE__ns5__ActionConfigurationIsInUseFault;
			return soap_in__ns5__ActionConfigurationIsInUseFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:RecipientTemplateNotFoundFault"))
		{	*type = SOAP_TYPE__ns5__RecipientTemplateNotFoundFault;
			return soap_in__ns5__RecipientTemplateNotFoundFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:ActionConfigurationNotFoundFault"))
		{	*type = SOAP_TYPE__ns5__ActionConfigurationNotFoundFault;
			return soap_in__ns5__ActionConfigurationNotFoundFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:InvalidActionConfigurationFault"))
		{	*type = SOAP_TYPE__ns5__InvalidActionConfigurationFault;
			return soap_in__ns5__InvalidActionConfigurationFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:ParametersMissmatchFault"))
		{	*type = SOAP_TYPE__ns5__ParametersMissmatchFault;
			return soap_in__ns5__ParametersMissmatchFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:RecipientConfigurationNotFoundFault"))
		{	*type = SOAP_TYPE__ns5__RecipientConfigurationNotFoundFault;
			return soap_in__ns5__RecipientConfigurationNotFoundFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:ActionTemplateNotFoundFault"))
		{	*type = SOAP_TYPE__ns5__ActionTemplateNotFoundFault;
			return soap_in__ns5__ActionTemplateNotFoundFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:RemoveActionRuleResponse"))
		{	*type = SOAP_TYPE__ns5__RemoveActionRuleResponse;
			return soap_in__ns5__RemoveActionRuleResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:RemoveActionRule"))
		{	*type = SOAP_TYPE__ns5__RemoveActionRule;
			return soap_in__ns5__RemoveActionRule(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:GetActionRulesResponse"))
		{	*type = SOAP_TYPE__ns5__GetActionRulesResponse;
			return soap_in__ns5__GetActionRulesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:GetActionRules"))
		{	*type = SOAP_TYPE__ns5__GetActionRules;
			return soap_in__ns5__GetActionRules(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:AddActionRuleResponse"))
		{	*type = SOAP_TYPE__ns5__AddActionRuleResponse;
			return soap_in__ns5__AddActionRuleResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:AddActionRule"))
		{	*type = SOAP_TYPE__ns5__AddActionRule;
			return soap_in__ns5__AddActionRule(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:GetRecipientConfigurationsResponse"))
		{	*type = SOAP_TYPE__ns5__GetRecipientConfigurationsResponse;
			return soap_in__ns5__GetRecipientConfigurationsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:GetRecipientConfigurations"))
		{	*type = SOAP_TYPE__ns5__GetRecipientConfigurations;
			return soap_in__ns5__GetRecipientConfigurations(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:RemoveRecipientConfigurationResponse"))
		{	*type = SOAP_TYPE__ns5__RemoveRecipientConfigurationResponse;
			return soap_in__ns5__RemoveRecipientConfigurationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:RemoveRecipientConfiguration"))
		{	*type = SOAP_TYPE__ns5__RemoveRecipientConfiguration;
			return soap_in__ns5__RemoveRecipientConfiguration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:AddRecipientConfigurationResponse"))
		{	*type = SOAP_TYPE__ns5__AddRecipientConfigurationResponse;
			return soap_in__ns5__AddRecipientConfigurationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:AddRecipientConfiguration"))
		{	*type = SOAP_TYPE__ns5__AddRecipientConfiguration;
			return soap_in__ns5__AddRecipientConfiguration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:GetRecipientTemplatesResponse"))
		{	*type = SOAP_TYPE__ns5__GetRecipientTemplatesResponse;
			return soap_in__ns5__GetRecipientTemplatesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:GetRecipientTemplates"))
		{	*type = SOAP_TYPE__ns5__GetRecipientTemplates;
			return soap_in__ns5__GetRecipientTemplates(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:GetActionConfigurationsResponse"))
		{	*type = SOAP_TYPE__ns5__GetActionConfigurationsResponse;
			return soap_in__ns5__GetActionConfigurationsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:GetActionConfigurations"))
		{	*type = SOAP_TYPE__ns5__GetActionConfigurations;
			return soap_in__ns5__GetActionConfigurations(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:RemoveActionConfigurationResponse"))
		{	*type = SOAP_TYPE__ns5__RemoveActionConfigurationResponse;
			return soap_in__ns5__RemoveActionConfigurationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:RemoveActionConfiguration"))
		{	*type = SOAP_TYPE__ns5__RemoveActionConfiguration;
			return soap_in__ns5__RemoveActionConfiguration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:AddActionConfigurationResponse"))
		{	*type = SOAP_TYPE__ns5__AddActionConfigurationResponse;
			return soap_in__ns5__AddActionConfigurationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:AddActionConfiguration"))
		{	*type = SOAP_TYPE__ns5__AddActionConfiguration;
			return soap_in__ns5__AddActionConfiguration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:GetActionTemplatesResponse"))
		{	*type = SOAP_TYPE__ns5__GetActionTemplatesResponse;
			return soap_in__ns5__GetActionTemplatesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:GetActionTemplates"))
		{	*type = SOAP_TYPE__ns5__GetActionTemplates;
			return soap_in__ns5__GetActionTemplates(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:ResumeSubscriptionResponse"))
		{	*type = SOAP_TYPE__ns3__ResumeSubscriptionResponse;
			return soap_in__ns3__ResumeSubscriptionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:ResumeSubscription"))
		{	*type = SOAP_TYPE__ns3__ResumeSubscription;
			return soap_in__ns3__ResumeSubscription(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:PauseSubscriptionResponse"))
		{	*type = SOAP_TYPE__ns3__PauseSubscriptionResponse;
			return soap_in__ns3__PauseSubscriptionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:PauseSubscription"))
		{	*type = SOAP_TYPE__ns3__PauseSubscription;
			return soap_in__ns3__PauseSubscription(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:UnsubscribeResponse"))
		{	*type = SOAP_TYPE__ns3__UnsubscribeResponse;
			return soap_in__ns3__UnsubscribeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:Unsubscribe"))
		{	*type = SOAP_TYPE__ns3__Unsubscribe;
			return soap_in__ns3__Unsubscribe(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:RenewResponse"))
		{	*type = SOAP_TYPE__ns3__RenewResponse;
			return soap_in__ns3__RenewResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:Renew"))
		{	*type = SOAP_TYPE__ns3__Renew;
			return soap_in__ns3__Renew(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:CreatePullPointResponse"))
		{	*type = SOAP_TYPE__ns3__CreatePullPointResponse;
			return soap_in__ns3__CreatePullPointResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:CreatePullPoint"))
		{	*type = SOAP_TYPE__ns3__CreatePullPoint;
			return soap_in__ns3__CreatePullPoint(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:DestroyPullPointResponse"))
		{	*type = SOAP_TYPE__ns3__DestroyPullPointResponse;
			return soap_in__ns3__DestroyPullPointResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:DestroyPullPoint"))
		{	*type = SOAP_TYPE__ns3__DestroyPullPoint;
			return soap_in__ns3__DestroyPullPoint(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:GetMessagesResponse"))
		{	*type = SOAP_TYPE__ns3__GetMessagesResponse;
			return soap_in__ns3__GetMessagesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:GetMessages"))
		{	*type = SOAP_TYPE__ns3__GetMessages;
			return soap_in__ns3__GetMessages(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:GetCurrentMessageResponse"))
		{	*type = SOAP_TYPE__ns3__GetCurrentMessageResponse;
			return soap_in__ns3__GetCurrentMessageResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:GetCurrentMessage"))
		{	*type = SOAP_TYPE__ns3__GetCurrentMessage;
			return soap_in__ns3__GetCurrentMessage(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:SubscribeResponse"))
		{	*type = SOAP_TYPE__ns3__SubscribeResponse;
			return soap_in__ns3__SubscribeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:Subscribe"))
		{	*type = SOAP_TYPE__ns3__Subscribe;
			return soap_in__ns3__Subscribe(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:UseRaw"))
		{	*type = SOAP_TYPE__ns3__UseRaw;
			return soap_in__ns3__UseRaw(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:Notify"))
		{	*type = SOAP_TYPE__ns3__Notify;
			return soap_in__ns3__Notify(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:SubscriptionManagerRP"))
		{	*type = SOAP_TYPE__ns3__SubscriptionManagerRP;
			return soap_in__ns3__SubscriptionManagerRP(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:NotificationProducerRP"))
		{	*type = SOAP_TYPE__ns3__NotificationProducerRP;
			return soap_in__ns3__NotificationProducerRP(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ChangeVirtualInputStateResponse"))
		{	*type = SOAP_TYPE__ns1__ChangeVirtualInputStateResponse;
			return soap_in__ns1__ChangeVirtualInputStateResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ChangeVirtualInputState"))
		{	*type = SOAP_TYPE__ns1__ChangeVirtualInputState;
			return soap_in__ns1__ChangeVirtualInputState(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ScheduledEventAlreadyExistsFault"))
		{	*type = SOAP_TYPE__ns1__ScheduledEventAlreadyExistsFault;
			return soap_in__ns1__ScheduledEventAlreadyExistsFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InvalidScheduledEventIDFault"))
		{	*type = SOAP_TYPE__ns1__InvalidScheduledEventIDFault;
			return soap_in__ns1__InvalidScheduledEventIDFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InvalidScheduleFault"))
		{	*type = SOAP_TYPE__ns1__InvalidScheduleFault;
			return soap_in__ns1__InvalidScheduleFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ScheduledEventNotFoundFault"))
		{	*type = SOAP_TYPE__ns1__ScheduledEventNotFoundFault;
			return soap_in__ns1__ScheduledEventNotFoundFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetScheduledEventsResponse"))
		{	*type = SOAP_TYPE__ns1__GetScheduledEventsResponse;
			return soap_in__ns1__GetScheduledEventsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetScheduledEvents"))
		{	*type = SOAP_TYPE__ns1__GetScheduledEvents;
			return soap_in__ns1__GetScheduledEvents(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RemoveScheduledEventResponse"))
		{	*type = SOAP_TYPE__ns1__RemoveScheduledEventResponse;
			return soap_in__ns1__RemoveScheduledEventResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RemoveScheduledEvent"))
		{	*type = SOAP_TYPE__ns1__RemoveScheduledEvent;
			return soap_in__ns1__RemoveScheduledEvent(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AddScheduledEventResponse"))
		{	*type = SOAP_TYPE__ns1__AddScheduledEventResponse;
			return soap_in__ns1__AddScheduledEventResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AddScheduledEvent"))
		{	*type = SOAP_TYPE__ns1__AddScheduledEvent;
			return soap_in__ns1__AddScheduledEvent(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetEventInstancesResponse"))
		{	*type = SOAP_TYPE__ns1__GetEventInstancesResponse;
			return soap_in__ns1__GetEventInstancesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetEventInstances"))
		{	*type = SOAP_TYPE__ns1__GetEventInstances;
			return soap_in__ns1__GetEventInstances(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xml:lang"))
		{	*type = SOAP_TYPE__xml__lang;
			return soap_in__xml__lang(soap, NULL, NULL, NULL);
		}
#ifndef WITH_NOIDREF
	}
#endif
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level = %u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other && !soap->fignore)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && !soap->fignore && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body && soap_ignore(soap))
				return soap->error;
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, SOAP_MULTIREFTAG, pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_ULONG64:
		return soap_out_ULONG64(soap, tag, id, (const ULONG64 *)ptr, "xsd:unsignedLong");
	case SOAP_TYPE_dateTime:
		return soap_out_dateTime(soap, tag, id, (const time_t *)ptr, "xsd:dateTime");
	case SOAP_TYPE_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE_ns6__FaultCodesType:
		return soap_out_ns6__FaultCodesType(soap, tag, id, (const ns6__FaultCodesType *)ptr, "ns6:FaultCodesType");
	case SOAP_TYPE_ns6__RelationshipType:
		return soap_out_ns6__RelationshipType(soap, tag, id, (const ns6__RelationshipType *)ptr, "ns6:RelationshipType");
	case SOAP_TYPE_ns1__ScheduledType:
		return soap_out_ns1__ScheduledType(soap, tag, id, (const ns1__ScheduledType *)ptr, "ns1:ScheduledType");
	case SOAP_TYPE__ns2__TopicNamespaceType_Topic:
		return ((_ns2__TopicNamespaceType_Topic *)ptr)->soap_out(soap, "ns2:TopicNamespaceType-Topic", id, "");
	case SOAP_TYPE__ns4__BaseFaultType_FaultCause:
		return ((_ns4__BaseFaultType_FaultCause *)ptr)->soap_out(soap, "ns4:BaseFaultType-FaultCause", id, "");
	case SOAP_TYPE__ns4__BaseFaultType_Description:
		return ((_ns4__BaseFaultType_Description *)ptr)->soap_out(soap, "ns4:BaseFaultType-Description", id, "");
	case SOAP_TYPE__ns4__BaseFaultType_ErrorCode:
		return ((_ns4__BaseFaultType_ErrorCode *)ptr)->soap_out(soap, "ns4:BaseFaultType-ErrorCode", id, "");
	case SOAP_TYPE__ns3__Subscribe_SubscriptionPolicy:
		return ((_ns3__Subscribe_SubscriptionPolicy *)ptr)->soap_out(soap, "ns3:Subscribe-SubscriptionPolicy", id, "");
	case SOAP_TYPE__ns3__NotificationMessageHolderType_Message:
		return ((_ns3__NotificationMessageHolderType_Message *)ptr)->soap_out(soap, "ns3:NotificationMessageHolderType-Message", id, "");
	case SOAP_TYPE_ns6__FaultCodesType__:
		return ((ns6__FaultCodesType__ *)ptr)->soap_out(soap, tag, id, "ns6:FaultCodesType");
	case SOAP_TYPE_ns6__RelationshipType__:
		return ((ns6__RelationshipType__ *)ptr)->soap_out(soap, tag, id, "ns6:RelationshipType");
	case SOAP_TYPE_ns2__SimpleTopicExpression__:
		return ((ns2__SimpleTopicExpression__ *)ptr)->soap_out(soap, tag, id, "ns2:SimpleTopicExpression");
	case SOAP_TYPE_ns2__SimpleTopicExpression:
		return soap_out_ns2__SimpleTopicExpression(soap, tag, id, (const std::string *)ptr, "xsd:QName");
	case SOAP_TYPE_ns2__ConcreteTopicExpression__:
		return ((ns2__ConcreteTopicExpression__ *)ptr)->soap_out(soap, tag, id, "ns2:ConcreteTopicExpression");
	case SOAP_TYPE_ns2__ConcreteTopicExpression:
		return soap_out_ns2__ConcreteTopicExpression(soap, tag, id, (const std::string *)ptr, "ns2:ConcreteTopicExpression");
	case SOAP_TYPE_ns2__FullTopicExpression__:
		return ((ns2__FullTopicExpression__ *)ptr)->soap_out(soap, tag, id, "ns2:FullTopicExpression");
	case SOAP_TYPE_ns2__FullTopicExpression:
		return soap_out_ns2__FullTopicExpression(soap, tag, id, (const std::string *)ptr, "ns2:FullTopicExpression");
	case SOAP_TYPE_ns1__ScheduledType__:
		return ((ns1__ScheduledType__ *)ptr)->soap_out(soap, tag, id, "ns1:ScheduledType");
	case SOAP_TYPE_ns6__FaultCodesOpenEnumType:
		return soap_out_ns6__FaultCodesOpenEnumType(soap, tag, id, (const std::string *)ptr, "ns6:FaultCodesOpenEnumType");
	case SOAP_TYPE_ns6__RelationshipTypeOpenEnum:
		return soap_out_ns6__RelationshipTypeOpenEnum(soap, tag, id, (const std::string *)ptr, "ns6:RelationshipTypeOpenEnum");
	case SOAP_TYPE_ns3__AbsoluteOrRelativeTimeType:
		return soap_out_ns3__AbsoluteOrRelativeTimeType(soap, tag, id, (const std::string *)ptr, "ns3:AbsoluteOrRelativeTimeType");
	case SOAP_TYPE_ns6__ProblemActionType:
		return ((ns6__ProblemActionType *)ptr)->soap_out(soap, tag, id, "ns6:ProblemActionType");
	case SOAP_TYPE_ns6__AttributedQNameType:
		return ((ns6__AttributedQNameType *)ptr)->soap_out(soap, tag, id, "ns6:AttributedQNameType");
	case SOAP_TYPE_ns6__AttributedUnsignedLongType:
		return ((ns6__AttributedUnsignedLongType *)ptr)->soap_out(soap, tag, id, "ns6:AttributedUnsignedLongType");
	case SOAP_TYPE_ns6__AttributedURIType:
		return ((ns6__AttributedURIType *)ptr)->soap_out(soap, tag, id, "ns6:AttributedURIType");
	case SOAP_TYPE_ns6__RelatesToType:
		return ((ns6__RelatesToType *)ptr)->soap_out(soap, tag, id, "ns6:RelatesToType");
	case SOAP_TYPE_ns6__MetadataType:
		return ((ns6__MetadataType *)ptr)->soap_out(soap, tag, id, "ns6:MetadataType");
	case SOAP_TYPE_ns6__ReferenceParametersType:
		return ((ns6__ReferenceParametersType *)ptr)->soap_out(soap, tag, id, "ns6:ReferenceParametersType");
	case SOAP_TYPE_ns6__EndpointReferenceType:
		return ((ns6__EndpointReferenceType *)ptr)->soap_out(soap, tag, id, "ns6:EndpointReferenceType");
	case SOAP_TYPE__ns5__InvalidActivationTimeoutFault:
		return ((_ns5__InvalidActivationTimeoutFault *)ptr)->soap_out(soap, "ns5:InvalidActivationTimeoutFault", id, "");
	case SOAP_TYPE__ns5__ActionRuleNotFoundFault:
		return ((_ns5__ActionRuleNotFoundFault *)ptr)->soap_out(soap, "ns5:ActionRuleNotFoundFault", id, "");
	case SOAP_TYPE__ns5__InsufficientActivationRuleFault:
		return ((_ns5__InsufficientActivationRuleFault *)ptr)->soap_out(soap, "ns5:InsufficientActivationRuleFault", id, "");
	case SOAP_TYPE__ns5__InvalidConditionFilterFault:
		return ((_ns5__InvalidConditionFilterFault *)ptr)->soap_out(soap, "ns5:InvalidConditionFilterFault", id, "");
	case SOAP_TYPE__ns5__ActionConfigurationIsInUseFault:
		return ((_ns5__ActionConfigurationIsInUseFault *)ptr)->soap_out(soap, "ns5:ActionConfigurationIsInUseFault", id, "");
	case SOAP_TYPE__ns5__RecipientTemplateNotFoundFault:
		return ((_ns5__RecipientTemplateNotFoundFault *)ptr)->soap_out(soap, "ns5:RecipientTemplateNotFoundFault", id, "");
	case SOAP_TYPE__ns5__ActionConfigurationNotFoundFault:
		return ((_ns5__ActionConfigurationNotFoundFault *)ptr)->soap_out(soap, "ns5:ActionConfigurationNotFoundFault", id, "");
	case SOAP_TYPE__ns5__InvalidActionConfigurationFault:
		return ((_ns5__InvalidActionConfigurationFault *)ptr)->soap_out(soap, "ns5:InvalidActionConfigurationFault", id, "");
	case SOAP_TYPE__ns5__ParametersMissmatchFault:
		return ((_ns5__ParametersMissmatchFault *)ptr)->soap_out(soap, "ns5:ParametersMissmatchFault", id, "");
	case SOAP_TYPE__ns5__RecipientConfigurationNotFoundFault:
		return ((_ns5__RecipientConfigurationNotFoundFault *)ptr)->soap_out(soap, "ns5:RecipientConfigurationNotFoundFault", id, "");
	case SOAP_TYPE__ns5__ActionTemplateNotFoundFault:
		return ((_ns5__ActionTemplateNotFoundFault *)ptr)->soap_out(soap, "ns5:ActionTemplateNotFoundFault", id, "");
	case SOAP_TYPE__ns5__RemoveActionRuleResponse:
		return ((_ns5__RemoveActionRuleResponse *)ptr)->soap_out(soap, "ns5:RemoveActionRuleResponse", id, "");
	case SOAP_TYPE__ns5__RemoveActionRule:
		return ((_ns5__RemoveActionRule *)ptr)->soap_out(soap, "ns5:RemoveActionRule", id, "");
	case SOAP_TYPE__ns5__GetActionRulesResponse:
		return ((_ns5__GetActionRulesResponse *)ptr)->soap_out(soap, "ns5:GetActionRulesResponse", id, "");
	case SOAP_TYPE__ns5__GetActionRules:
		return ((_ns5__GetActionRules *)ptr)->soap_out(soap, "ns5:GetActionRules", id, "");
	case SOAP_TYPE__ns5__AddActionRuleResponse:
		return ((_ns5__AddActionRuleResponse *)ptr)->soap_out(soap, "ns5:AddActionRuleResponse", id, "");
	case SOAP_TYPE__ns5__AddActionRule:
		return ((_ns5__AddActionRule *)ptr)->soap_out(soap, "ns5:AddActionRule", id, "");
	case SOAP_TYPE__ns5__GetRecipientConfigurationsResponse:
		return ((_ns5__GetRecipientConfigurationsResponse *)ptr)->soap_out(soap, "ns5:GetRecipientConfigurationsResponse", id, "");
	case SOAP_TYPE__ns5__GetRecipientConfigurations:
		return ((_ns5__GetRecipientConfigurations *)ptr)->soap_out(soap, "ns5:GetRecipientConfigurations", id, "");
	case SOAP_TYPE__ns5__RemoveRecipientConfigurationResponse:
		return ((_ns5__RemoveRecipientConfigurationResponse *)ptr)->soap_out(soap, "ns5:RemoveRecipientConfigurationResponse", id, "");
	case SOAP_TYPE__ns5__RemoveRecipientConfiguration:
		return ((_ns5__RemoveRecipientConfiguration *)ptr)->soap_out(soap, "ns5:RemoveRecipientConfiguration", id, "");
	case SOAP_TYPE__ns5__AddRecipientConfigurationResponse:
		return ((_ns5__AddRecipientConfigurationResponse *)ptr)->soap_out(soap, "ns5:AddRecipientConfigurationResponse", id, "");
	case SOAP_TYPE__ns5__AddRecipientConfiguration:
		return ((_ns5__AddRecipientConfiguration *)ptr)->soap_out(soap, "ns5:AddRecipientConfiguration", id, "");
	case SOAP_TYPE__ns5__GetRecipientTemplatesResponse:
		return ((_ns5__GetRecipientTemplatesResponse *)ptr)->soap_out(soap, "ns5:GetRecipientTemplatesResponse", id, "");
	case SOAP_TYPE__ns5__GetRecipientTemplates:
		return ((_ns5__GetRecipientTemplates *)ptr)->soap_out(soap, "ns5:GetRecipientTemplates", id, "");
	case SOAP_TYPE__ns5__GetActionConfigurationsResponse:
		return ((_ns5__GetActionConfigurationsResponse *)ptr)->soap_out(soap, "ns5:GetActionConfigurationsResponse", id, "");
	case SOAP_TYPE__ns5__GetActionConfigurations:
		return ((_ns5__GetActionConfigurations *)ptr)->soap_out(soap, "ns5:GetActionConfigurations", id, "");
	case SOAP_TYPE__ns5__RemoveActionConfigurationResponse:
		return ((_ns5__RemoveActionConfigurationResponse *)ptr)->soap_out(soap, "ns5:RemoveActionConfigurationResponse", id, "");
	case SOAP_TYPE__ns5__RemoveActionConfiguration:
		return ((_ns5__RemoveActionConfiguration *)ptr)->soap_out(soap, "ns5:RemoveActionConfiguration", id, "");
	case SOAP_TYPE__ns5__AddActionConfigurationResponse:
		return ((_ns5__AddActionConfigurationResponse *)ptr)->soap_out(soap, "ns5:AddActionConfigurationResponse", id, "");
	case SOAP_TYPE__ns5__AddActionConfiguration:
		return ((_ns5__AddActionConfiguration *)ptr)->soap_out(soap, "ns5:AddActionConfiguration", id, "");
	case SOAP_TYPE__ns5__GetActionTemplatesResponse:
		return ((_ns5__GetActionTemplatesResponse *)ptr)->soap_out(soap, "ns5:GetActionTemplatesResponse", id, "");
	case SOAP_TYPE__ns5__GetActionTemplates:
		return ((_ns5__GetActionTemplates *)ptr)->soap_out(soap, "ns5:GetActionTemplates", id, "");
	case SOAP_TYPE_ns5__UsedActionRule:
		return ((ns5__UsedActionRule *)ptr)->soap_out(soap, tag, id, "ns5:UsedActionRule");
	case SOAP_TYPE_ns5__UsedByActionRules:
		return ((ns5__UsedByActionRules *)ptr)->soap_out(soap, tag, id, "ns5:UsedByActionRules");
	case SOAP_TYPE_ns5__UsedActionConfiguration:
		return ((ns5__UsedActionConfiguration *)ptr)->soap_out(soap, tag, id, "ns5:UsedActionConfiguration");
	case SOAP_TYPE_ns5__UsedByActionConfigurations:
		return ((ns5__UsedByActionConfigurations *)ptr)->soap_out(soap, tag, id, "ns5:UsedByActionConfigurations");
	case SOAP_TYPE_ns5__ActionTemplateParameter:
		return ((ns5__ActionTemplateParameter *)ptr)->soap_out(soap, tag, id, "ns5:ActionTemplateParameter");
	case SOAP_TYPE_ns5__ActionTemplateParameters:
		return ((ns5__ActionTemplateParameters *)ptr)->soap_out(soap, tag, id, "ns5:ActionTemplateParameters");
	case SOAP_TYPE_ns5__ActionTemplate:
		return ((ns5__ActionTemplate *)ptr)->soap_out(soap, tag, id, "ns5:ActionTemplate");
	case SOAP_TYPE_ns5__ActionParameter:
		return ((ns5__ActionParameter *)ptr)->soap_out(soap, tag, id, "ns5:ActionParameter");
	case SOAP_TYPE_ns5__ActionTemplates:
		return ((ns5__ActionTemplates *)ptr)->soap_out(soap, tag, id, "ns5:ActionTemplates");
	case SOAP_TYPE_ns5__ActionParameters:
		return ((ns5__ActionParameters *)ptr)->soap_out(soap, tag, id, "ns5:ActionParameters");
	case SOAP_TYPE_ns5__ActionConfiguration:
		return ((ns5__ActionConfiguration *)ptr)->soap_out(soap, tag, id, "ns5:ActionConfiguration");
	case SOAP_TYPE_ns5__NewActionConfiguration:
		return ((ns5__NewActionConfiguration *)ptr)->soap_out(soap, tag, id, "ns5:NewActionConfiguration");
	case SOAP_TYPE_ns5__ActionConfigurations:
		return ((ns5__ActionConfigurations *)ptr)->soap_out(soap, tag, id, "ns5:ActionConfigurations");
	case SOAP_TYPE_ns5__RecipientTemplate:
		return ((ns5__RecipientTemplate *)ptr)->soap_out(soap, tag, id, "ns5:RecipientTemplate");
	case SOAP_TYPE_ns5__RecipientTemplates:
		return ((ns5__RecipientTemplates *)ptr)->soap_out(soap, tag, id, "ns5:RecipientTemplates");
	case SOAP_TYPE_ns5__RecipientConfigurations:
		return ((ns5__RecipientConfigurations *)ptr)->soap_out(soap, tag, id, "ns5:RecipientConfigurations");
	case SOAP_TYPE_ns5__RecipientConfiguration:
		return ((ns5__RecipientConfiguration *)ptr)->soap_out(soap, tag, id, "ns5:RecipientConfiguration");
	case SOAP_TYPE_ns5__NewRecipientConfiguration:
		return ((ns5__NewRecipientConfiguration *)ptr)->soap_out(soap, tag, id, "ns5:NewRecipientConfiguration");
	case SOAP_TYPE_ns5__ActionRule:
		return ((ns5__ActionRule *)ptr)->soap_out(soap, tag, id, "ns5:ActionRule");
	case SOAP_TYPE_ns5__ActionRules:
		return ((ns5__ActionRules *)ptr)->soap_out(soap, tag, id, "ns5:ActionRules");
	case SOAP_TYPE_ns5__Conditions:
		return ((ns5__Conditions *)ptr)->soap_out(soap, tag, id, "ns5:Conditions");
	case SOAP_TYPE_ns5__NewActionRule:
		return ((ns5__NewActionRule *)ptr)->soap_out(soap, tag, id, "ns5:NewActionRule");
	case SOAP_TYPE_ns4__BaseFaultType:
		return ((ns4__BaseFaultType *)ptr)->soap_out(soap, tag, id, "ns4:BaseFaultType");
	case SOAP_TYPE__ns3__ResumeSubscriptionResponse:
		return ((_ns3__ResumeSubscriptionResponse *)ptr)->soap_out(soap, "ns3:ResumeSubscriptionResponse", id, "");
	case SOAP_TYPE__ns3__ResumeSubscription:
		return ((_ns3__ResumeSubscription *)ptr)->soap_out(soap, "ns3:ResumeSubscription", id, "");
	case SOAP_TYPE__ns3__PauseSubscriptionResponse:
		return ((_ns3__PauseSubscriptionResponse *)ptr)->soap_out(soap, "ns3:PauseSubscriptionResponse", id, "");
	case SOAP_TYPE__ns3__PauseSubscription:
		return ((_ns3__PauseSubscription *)ptr)->soap_out(soap, "ns3:PauseSubscription", id, "");
	case SOAP_TYPE__ns3__UnsubscribeResponse:
		return ((_ns3__UnsubscribeResponse *)ptr)->soap_out(soap, "ns3:UnsubscribeResponse", id, "");
	case SOAP_TYPE__ns3__Unsubscribe:
		return ((_ns3__Unsubscribe *)ptr)->soap_out(soap, "ns3:Unsubscribe", id, "");
	case SOAP_TYPE__ns3__RenewResponse:
		return ((_ns3__RenewResponse *)ptr)->soap_out(soap, "ns3:RenewResponse", id, "");
	case SOAP_TYPE__ns3__Renew:
		return ((_ns3__Renew *)ptr)->soap_out(soap, "ns3:Renew", id, "");
	case SOAP_TYPE__ns3__CreatePullPointResponse:
		return ((_ns3__CreatePullPointResponse *)ptr)->soap_out(soap, "ns3:CreatePullPointResponse", id, "");
	case SOAP_TYPE__ns3__CreatePullPoint:
		return ((_ns3__CreatePullPoint *)ptr)->soap_out(soap, "ns3:CreatePullPoint", id, "");
	case SOAP_TYPE__ns3__DestroyPullPointResponse:
		return ((_ns3__DestroyPullPointResponse *)ptr)->soap_out(soap, "ns3:DestroyPullPointResponse", id, "");
	case SOAP_TYPE__ns3__DestroyPullPoint:
		return ((_ns3__DestroyPullPoint *)ptr)->soap_out(soap, "ns3:DestroyPullPoint", id, "");
	case SOAP_TYPE__ns3__GetMessagesResponse:
		return ((_ns3__GetMessagesResponse *)ptr)->soap_out(soap, "ns3:GetMessagesResponse", id, "");
	case SOAP_TYPE__ns3__GetMessages:
		return ((_ns3__GetMessages *)ptr)->soap_out(soap, "ns3:GetMessages", id, "");
	case SOAP_TYPE__ns3__GetCurrentMessageResponse:
		return ((_ns3__GetCurrentMessageResponse *)ptr)->soap_out(soap, "ns3:GetCurrentMessageResponse", id, "");
	case SOAP_TYPE__ns3__GetCurrentMessage:
		return ((_ns3__GetCurrentMessage *)ptr)->soap_out(soap, "ns3:GetCurrentMessage", id, "");
	case SOAP_TYPE__ns3__SubscribeResponse:
		return ((_ns3__SubscribeResponse *)ptr)->soap_out(soap, "ns3:SubscribeResponse", id, "");
	case SOAP_TYPE__ns3__Subscribe:
		return ((_ns3__Subscribe *)ptr)->soap_out(soap, "ns3:Subscribe", id, "");
	case SOAP_TYPE__ns3__UseRaw:
		return ((_ns3__UseRaw *)ptr)->soap_out(soap, "ns3:UseRaw", id, "");
	case SOAP_TYPE__ns3__Notify:
		return ((_ns3__Notify *)ptr)->soap_out(soap, "ns3:Notify", id, "");
	case SOAP_TYPE__ns3__SubscriptionManagerRP:
		return ((_ns3__SubscriptionManagerRP *)ptr)->soap_out(soap, "ns3:SubscriptionManagerRP", id, "");
	case SOAP_TYPE__ns3__NotificationProducerRP:
		return ((_ns3__NotificationProducerRP *)ptr)->soap_out(soap, "ns3:NotificationProducerRP", id, "");
	case SOAP_TYPE_ns3__ResumeFailedFaultType:
		return ((ns3__ResumeFailedFaultType *)ptr)->soap_out(soap, tag, id, "ns3:ResumeFailedFaultType");
	case SOAP_TYPE_ns3__PauseFailedFaultType:
		return ((ns3__PauseFailedFaultType *)ptr)->soap_out(soap, tag, id, "ns3:PauseFailedFaultType");
	case SOAP_TYPE_ns3__UnableToDestroySubscriptionFaultType:
		return ((ns3__UnableToDestroySubscriptionFaultType *)ptr)->soap_out(soap, tag, id, "ns3:UnableToDestroySubscriptionFaultType");
	case SOAP_TYPE_ns3__UnacceptableTerminationTimeFaultType:
		return ((ns3__UnacceptableTerminationTimeFaultType *)ptr)->soap_out(soap, tag, id, "ns3:UnacceptableTerminationTimeFaultType");
	case SOAP_TYPE_ns3__UnableToCreatePullPointFaultType:
		return ((ns3__UnableToCreatePullPointFaultType *)ptr)->soap_out(soap, tag, id, "ns3:UnableToCreatePullPointFaultType");
	case SOAP_TYPE_ns3__UnableToDestroyPullPointFaultType:
		return ((ns3__UnableToDestroyPullPointFaultType *)ptr)->soap_out(soap, tag, id, "ns3:UnableToDestroyPullPointFaultType");
	case SOAP_TYPE_ns3__UnableToGetMessagesFaultType:
		return ((ns3__UnableToGetMessagesFaultType *)ptr)->soap_out(soap, tag, id, "ns3:UnableToGetMessagesFaultType");
	case SOAP_TYPE_ns3__NoCurrentMessageOnTopicFaultType:
		return ((ns3__NoCurrentMessageOnTopicFaultType *)ptr)->soap_out(soap, tag, id, "ns3:NoCurrentMessageOnTopicFaultType");
	case SOAP_TYPE_ns3__UnacceptableInitialTerminationTimeFaultType:
		return ((ns3__UnacceptableInitialTerminationTimeFaultType *)ptr)->soap_out(soap, tag, id, "ns3:UnacceptableInitialTerminationTimeFaultType");
	case SOAP_TYPE_ns3__NotifyMessageNotSupportedFaultType:
		return ((ns3__NotifyMessageNotSupportedFaultType *)ptr)->soap_out(soap, tag, id, "ns3:NotifyMessageNotSupportedFaultType");
	case SOAP_TYPE_ns3__UnsupportedPolicyRequestFaultType:
		return ((ns3__UnsupportedPolicyRequestFaultType *)ptr)->soap_out(soap, tag, id, "ns3:UnsupportedPolicyRequestFaultType");
	case SOAP_TYPE_ns3__UnrecognizedPolicyRequestFaultType:
		return ((ns3__UnrecognizedPolicyRequestFaultType *)ptr)->soap_out(soap, tag, id, "ns3:UnrecognizedPolicyRequestFaultType");
	case SOAP_TYPE_ns3__InvalidMessageContentExpressionFaultType:
		return ((ns3__InvalidMessageContentExpressionFaultType *)ptr)->soap_out(soap, tag, id, "ns3:InvalidMessageContentExpressionFaultType");
	case SOAP_TYPE_ns3__InvalidProducerPropertiesExpressionFaultType:
		return ((ns3__InvalidProducerPropertiesExpressionFaultType *)ptr)->soap_out(soap, tag, id, "ns3:InvalidProducerPropertiesExpressionFaultType");
	case SOAP_TYPE_ns3__MultipleTopicsSpecifiedFaultType:
		return ((ns3__MultipleTopicsSpecifiedFaultType *)ptr)->soap_out(soap, tag, id, "ns3:MultipleTopicsSpecifiedFaultType");
	case SOAP_TYPE_ns3__TopicNotSupportedFaultType:
		return ((ns3__TopicNotSupportedFaultType *)ptr)->soap_out(soap, tag, id, "ns3:TopicNotSupportedFaultType");
	case SOAP_TYPE_ns3__InvalidTopicExpressionFaultType:
		return ((ns3__InvalidTopicExpressionFaultType *)ptr)->soap_out(soap, tag, id, "ns3:InvalidTopicExpressionFaultType");
	case SOAP_TYPE_ns3__TopicExpressionDialectUnknownFaultType:
		return ((ns3__TopicExpressionDialectUnknownFaultType *)ptr)->soap_out(soap, tag, id, "ns3:TopicExpressionDialectUnknownFaultType");
	case SOAP_TYPE_ns3__InvalidFilterFaultType:
		return ((ns3__InvalidFilterFaultType *)ptr)->soap_out(soap, tag, id, "ns3:InvalidFilterFaultType");
	case SOAP_TYPE_ns3__SubscribeCreationFailedFaultType:
		return ((ns3__SubscribeCreationFailedFaultType *)ptr)->soap_out(soap, tag, id, "ns3:SubscribeCreationFailedFaultType");
	case SOAP_TYPE_ns3__NotificationMessageHolderType:
		return ((ns3__NotificationMessageHolderType *)ptr)->soap_out(soap, tag, id, "ns3:NotificationMessageHolderType");
	case SOAP_TYPE_ns3__SubscriptionPolicyType:
		return ((ns3__SubscriptionPolicyType *)ptr)->soap_out(soap, tag, id, "ns3:SubscriptionPolicyType");
	case SOAP_TYPE_ns3__FilterType:
		return ((ns3__FilterType *)ptr)->soap_out(soap, tag, id, "ns3:FilterType");
	case SOAP_TYPE_ns3__TopicExpressionType:
		return ((ns3__TopicExpressionType *)ptr)->soap_out(soap, tag, id, "ns3:TopicExpressionType");
	case SOAP_TYPE_ns3__QueryExpressionType:
		return ((ns3__QueryExpressionType *)ptr)->soap_out(soap, tag, id, "ns3:QueryExpressionType");
	case SOAP_TYPE_ns2__TopicSetType:
		return ((ns2__TopicSetType *)ptr)->soap_out(soap, tag, id, "ns2:TopicSetType");
	case SOAP_TYPE_ns2__TopicType:
		return ((ns2__TopicType *)ptr)->soap_out(soap, tag, id, "ns2:TopicType");
	case SOAP_TYPE_ns2__TopicNamespaceType:
		return ((ns2__TopicNamespaceType *)ptr)->soap_out(soap, tag, id, "ns2:TopicNamespaceType");
	case SOAP_TYPE_ns2__QueryExpressionType:
		return ((ns2__QueryExpressionType *)ptr)->soap_out(soap, tag, id, "ns2:QueryExpressionType");
	case SOAP_TYPE_ns2__ExtensibleDocumented:
		return ((ns2__ExtensibleDocumented *)ptr)->soap_out(soap, tag, id, "ns2:ExtensibleDocumented");
	case SOAP_TYPE_ns2__Documentation:
		return ((ns2__Documentation *)ptr)->soap_out(soap, tag, id, "ns2:Documentation");
	case SOAP_TYPE__ns1__ChangeVirtualInputStateResponse:
		return ((_ns1__ChangeVirtualInputStateResponse *)ptr)->soap_out(soap, "ns1:ChangeVirtualInputStateResponse", id, "");
	case SOAP_TYPE__ns1__ChangeVirtualInputState:
		return ((_ns1__ChangeVirtualInputState *)ptr)->soap_out(soap, "ns1:ChangeVirtualInputState", id, "");
	case SOAP_TYPE__ns1__ScheduledEventAlreadyExistsFault:
		return ((_ns1__ScheduledEventAlreadyExistsFault *)ptr)->soap_out(soap, "ns1:ScheduledEventAlreadyExistsFault", id, "");
	case SOAP_TYPE__ns1__InvalidScheduledEventIDFault:
		return ((_ns1__InvalidScheduledEventIDFault *)ptr)->soap_out(soap, "ns1:InvalidScheduledEventIDFault", id, "");
	case SOAP_TYPE__ns1__InvalidScheduleFault:
		return ((_ns1__InvalidScheduleFault *)ptr)->soap_out(soap, "ns1:InvalidScheduleFault", id, "");
	case SOAP_TYPE__ns1__ScheduledEventNotFoundFault:
		return ((_ns1__ScheduledEventNotFoundFault *)ptr)->soap_out(soap, "ns1:ScheduledEventNotFoundFault", id, "");
	case SOAP_TYPE__ns1__GetScheduledEventsResponse:
		return ((_ns1__GetScheduledEventsResponse *)ptr)->soap_out(soap, "ns1:GetScheduledEventsResponse", id, "");
	case SOAP_TYPE__ns1__GetScheduledEvents:
		return ((_ns1__GetScheduledEvents *)ptr)->soap_out(soap, "ns1:GetScheduledEvents", id, "");
	case SOAP_TYPE__ns1__RemoveScheduledEventResponse:
		return ((_ns1__RemoveScheduledEventResponse *)ptr)->soap_out(soap, "ns1:RemoveScheduledEventResponse", id, "");
	case SOAP_TYPE__ns1__RemoveScheduledEvent:
		return ((_ns1__RemoveScheduledEvent *)ptr)->soap_out(soap, "ns1:RemoveScheduledEvent", id, "");
	case SOAP_TYPE__ns1__AddScheduledEventResponse:
		return ((_ns1__AddScheduledEventResponse *)ptr)->soap_out(soap, "ns1:AddScheduledEventResponse", id, "");
	case SOAP_TYPE__ns1__AddScheduledEvent:
		return ((_ns1__AddScheduledEvent *)ptr)->soap_out(soap, "ns1:AddScheduledEvent", id, "");
	case SOAP_TYPE__ns1__GetEventInstancesResponse:
		return ((_ns1__GetEventInstancesResponse *)ptr)->soap_out(soap, "ns1:GetEventInstancesResponse", id, "");
	case SOAP_TYPE__ns1__GetEventInstances:
		return ((_ns1__GetEventInstances *)ptr)->soap_out(soap, "ns1:GetEventInstances", id, "");
	case SOAP_TYPE_ns1__ScheduleFilter:
		return ((ns1__ScheduleFilter *)ptr)->soap_out(soap, tag, id, "ns1:ScheduleFilter");
	case SOAP_TYPE_ns1__ICalendar:
		return ((ns1__ICalendar *)ptr)->soap_out(soap, tag, id, "ns1:ICalendar");
	case SOAP_TYPE_ns1__Schedule:
		return ((ns1__Schedule *)ptr)->soap_out(soap, tag, id, "ns1:Schedule");
	case SOAP_TYPE_ns1__ScheduledEvent:
		return ((ns1__ScheduledEvent *)ptr)->soap_out(soap, tag, id, "ns1:ScheduledEvent");
	case SOAP_TYPE_ns1__ScheduledEvents:
		return ((ns1__ScheduledEvents *)ptr)->soap_out(soap, tag, id, "ns1:ScheduledEvents");
	case SOAP_TYPE_ns1__NewScheduledEvent:
		return ((ns1__NewScheduledEvent *)ptr)->soap_out(soap, tag, id, "ns1:NewScheduledEvent");
	case SOAP_TYPE__xml__lang:
		return soap_out__xml__lang(soap, "xml:lang", id, (const std::string *)ptr, "");
	case SOAP_TYPE_xsd__unsignedLong:
		return ((xsd__unsignedLong *)ptr)->soap_out(soap, tag, id, "xsd:unsignedLong");
	case SOAP_TYPE_xsd__token_:
		return ((xsd__token_ *)ptr)->soap_out(soap, tag, id, "xsd:token");
	case SOAP_TYPE_xsd__token:
		return soap_out_xsd__token(soap, tag, id, (const std::string *)ptr, "xsd:token");
	case SOAP_TYPE_xsd__string:
		return ((xsd__string *)ptr)->soap_out(soap, tag, id, "xsd:string");
	case SOAP_TYPE_xsd__nonNegativeInteger_:
		return ((xsd__nonNegativeInteger_ *)ptr)->soap_out(soap, tag, id, "xsd:nonNegativeInteger");
	case SOAP_TYPE_xsd__nonNegativeInteger:
		return soap_out_xsd__nonNegativeInteger(soap, tag, id, (const std::string *)ptr, "xsd:nonNegativeInteger");
	case SOAP_TYPE_xsd__integer_:
		return ((xsd__integer_ *)ptr)->soap_out(soap, tag, id, "xsd:integer");
	case SOAP_TYPE_xsd__integer:
		return soap_out_xsd__integer(soap, tag, id, (const std::string *)ptr, "xsd:integer");
	case SOAP_TYPE_xsd__int:
		return ((xsd__int *)ptr)->soap_out(soap, tag, id, "xsd:int");
	case SOAP_TYPE_xsd__duration_:
		return ((xsd__duration_ *)ptr)->soap_out(soap, tag, id, "xsd:duration");
	case SOAP_TYPE_xsd__duration:
		return soap_out_xsd__duration(soap, tag, id, (const std::string *)ptr, "xsd:duration");
	case SOAP_TYPE_xsd__dateTime:
		return ((xsd__dateTime *)ptr)->soap_out(soap, tag, id, "xsd:dateTime");
	case SOAP_TYPE_xsd__boolean:
		return ((xsd__boolean *)ptr)->soap_out(soap, tag, id, "xsd:boolean");
	case SOAP_TYPE_xsd__anyURI_:
		return ((xsd__anyURI_ *)ptr)->soap_out(soap, tag, id, "xsd:anyURI");
	case SOAP_TYPE_xsd__anyURI:
		return soap_out_xsd__anyURI(soap, tag, id, (const std::string *)ptr, "xsd:anyURI");
	case SOAP_TYPE_xsd__QName_:
		return ((xsd__QName_ *)ptr)->soap_out(soap, tag, id, "xsd:QName");
	case SOAP_TYPE_xsd__NCName_:
		return ((xsd__NCName_ *)ptr)->soap_out(soap, tag, id, "xsd:NCName");
	case SOAP_TYPE_xsd__NCName:
		return soap_out_xsd__NCName(soap, tag, id, (const std::string *)ptr, "xsd:NCName");
	case SOAP_TYPE_xsd__QName:
		return soap_out_xsd__QName(soap, tag, id, (const std::string *)ptr, "xsd:QName");
	case SOAP_TYPE_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE_xsd__anyAttribute:
		return soap_out_xsd__anyAttribute(soap, tag, id, (const struct soap_dom_attribute *)ptr, "xsd:anyAttribute");
	case SOAP_TYPE_xsd__anyType:
		return soap_out_xsd__anyType(soap, tag, id, (const struct soap_dom_element *)ptr, "xsd:anyType");
	case SOAP_TYPE_PointerTo_ns5__RemoveActionRule:
		return soap_out_PointerTo_ns5__RemoveActionRule(soap, tag, id, (_ns5__RemoveActionRule *const*)ptr, "ns5:RemoveActionRule");
	case SOAP_TYPE_PointerTo_ns5__GetActionRules:
		return soap_out_PointerTo_ns5__GetActionRules(soap, tag, id, (_ns5__GetActionRules *const*)ptr, "ns5:GetActionRules");
	case SOAP_TYPE_PointerTo_ns5__AddActionRule:
		return soap_out_PointerTo_ns5__AddActionRule(soap, tag, id, (_ns5__AddActionRule *const*)ptr, "ns5:AddActionRule");
	case SOAP_TYPE_PointerTo_ns5__GetRecipientConfigurations:
		return soap_out_PointerTo_ns5__GetRecipientConfigurations(soap, tag, id, (_ns5__GetRecipientConfigurations *const*)ptr, "ns5:GetRecipientConfigurations");
	case SOAP_TYPE_PointerTo_ns5__RemoveRecipientConfiguration:
		return soap_out_PointerTo_ns5__RemoveRecipientConfiguration(soap, tag, id, (_ns5__RemoveRecipientConfiguration *const*)ptr, "ns5:RemoveRecipientConfiguration");
	case SOAP_TYPE_PointerTo_ns5__AddRecipientConfiguration:
		return soap_out_PointerTo_ns5__AddRecipientConfiguration(soap, tag, id, (_ns5__AddRecipientConfiguration *const*)ptr, "ns5:AddRecipientConfiguration");
	case SOAP_TYPE_PointerTo_ns5__GetRecipientTemplates:
		return soap_out_PointerTo_ns5__GetRecipientTemplates(soap, tag, id, (_ns5__GetRecipientTemplates *const*)ptr, "ns5:GetRecipientTemplates");
	case SOAP_TYPE_PointerTo_ns5__GetActionConfigurations:
		return soap_out_PointerTo_ns5__GetActionConfigurations(soap, tag, id, (_ns5__GetActionConfigurations *const*)ptr, "ns5:GetActionConfigurations");
	case SOAP_TYPE_PointerTo_ns5__RemoveActionConfiguration:
		return soap_out_PointerTo_ns5__RemoveActionConfiguration(soap, tag, id, (_ns5__RemoveActionConfiguration *const*)ptr, "ns5:RemoveActionConfiguration");
	case SOAP_TYPE_PointerTo_ns5__AddActionConfiguration:
		return soap_out_PointerTo_ns5__AddActionConfiguration(soap, tag, id, (_ns5__AddActionConfiguration *const*)ptr, "ns5:AddActionConfiguration");
	case SOAP_TYPE_PointerTo_ns5__GetActionTemplates:
		return soap_out_PointerTo_ns5__GetActionTemplates(soap, tag, id, (_ns5__GetActionTemplates *const*)ptr, "ns5:GetActionTemplates");
	case SOAP_TYPE_PointerTo_ns1__ChangeVirtualInputState:
		return soap_out_PointerTo_ns1__ChangeVirtualInputState(soap, tag, id, (_ns1__ChangeVirtualInputState *const*)ptr, "ns1:ChangeVirtualInputState");
	case SOAP_TYPE_PointerTo_ns1__GetScheduledEvents:
		return soap_out_PointerTo_ns1__GetScheduledEvents(soap, tag, id, (_ns1__GetScheduledEvents *const*)ptr, "ns1:GetScheduledEvents");
	case SOAP_TYPE_PointerTo_ns1__RemoveScheduledEvent:
		return soap_out_PointerTo_ns1__RemoveScheduledEvent(soap, tag, id, (_ns1__RemoveScheduledEvent *const*)ptr, "ns1:RemoveScheduledEvent");
	case SOAP_TYPE_PointerTo_ns1__AddScheduledEvent:
		return soap_out_PointerTo_ns1__AddScheduledEvent(soap, tag, id, (_ns1__AddScheduledEvent *const*)ptr, "ns1:AddScheduledEvent");
	case SOAP_TYPE_PointerTo_ns1__GetEventInstances:
		return soap_out_PointerTo_ns1__GetEventInstances(soap, tag, id, (_ns1__GetEventInstances *const*)ptr, "ns1:GetEventInstances");
	case SOAP_TYPE_PointerTons3__TopicExpressionDialectUnknownFaultType:
		return soap_out_PointerTons3__TopicExpressionDialectUnknownFaultType(soap, tag, id, (ns3__TopicExpressionDialectUnknownFaultType *const*)ptr, "ns3:TopicExpressionDialectUnknownFaultType");
	case SOAP_TYPE_PointerTo_ns5__RecipientTemplateNotFoundFault:
		return soap_out_PointerTo_ns5__RecipientTemplateNotFoundFault(soap, tag, id, (_ns5__RecipientTemplateNotFoundFault *const*)ptr, "ns5:RecipientTemplateNotFoundFault");
	case SOAP_TYPE_PointerTo_ns5__RecipientConfigurationNotFoundFault:
		return soap_out_PointerTo_ns5__RecipientConfigurationNotFoundFault(soap, tag, id, (_ns5__RecipientConfigurationNotFoundFault *const*)ptr, "ns5:RecipientConfigurationNotFoundFault");
	case SOAP_TYPE_PointerTo_ns5__ParametersMissmatchFault:
		return soap_out_PointerTo_ns5__ParametersMissmatchFault(soap, tag, id, (_ns5__ParametersMissmatchFault *const*)ptr, "ns5:ParametersMissmatchFault");
	case SOAP_TYPE_PointerTons3__InvalidTopicExpressionFaultType:
		return soap_out_PointerTons3__InvalidTopicExpressionFaultType(soap, tag, id, (ns3__InvalidTopicExpressionFaultType *const*)ptr, "ns3:InvalidTopicExpressionFaultType");
	case SOAP_TYPE_PointerTons3__InvalidMessageContentExpressionFaultType:
		return soap_out_PointerTons3__InvalidMessageContentExpressionFaultType(soap, tag, id, (ns3__InvalidMessageContentExpressionFaultType *const*)ptr, "ns3:InvalidMessageContentExpressionFaultType");
	case SOAP_TYPE_PointerTons3__InvalidFilterFaultType:
		return soap_out_PointerTons3__InvalidFilterFaultType(soap, tag, id, (ns3__InvalidFilterFaultType *const*)ptr, "ns3:InvalidFilterFaultType");
	case SOAP_TYPE_PointerTo_ns5__InvalidConditionFilterFault:
		return soap_out_PointerTo_ns5__InvalidConditionFilterFault(soap, tag, id, (_ns5__InvalidConditionFilterFault *const*)ptr, "ns5:InvalidConditionFilterFault");
	case SOAP_TYPE_PointerTo_ns5__InvalidActivationTimeoutFault:
		return soap_out_PointerTo_ns5__InvalidActivationTimeoutFault(soap, tag, id, (_ns5__InvalidActivationTimeoutFault *const*)ptr, "ns5:InvalidActivationTimeoutFault");
	case SOAP_TYPE_PointerTo_ns5__InvalidActionConfigurationFault:
		return soap_out_PointerTo_ns5__InvalidActionConfigurationFault(soap, tag, id, (_ns5__InvalidActionConfigurationFault *const*)ptr, "ns5:InvalidActionConfigurationFault");
	case SOAP_TYPE_PointerTo_ns5__InsufficientActivationRuleFault:
		return soap_out_PointerTo_ns5__InsufficientActivationRuleFault(soap, tag, id, (_ns5__InsufficientActivationRuleFault *const*)ptr, "ns5:InsufficientActivationRuleFault");
	case SOAP_TYPE_PointerTo_ns5__ActionTemplateNotFoundFault:
		return soap_out_PointerTo_ns5__ActionTemplateNotFoundFault(soap, tag, id, (_ns5__ActionTemplateNotFoundFault *const*)ptr, "ns5:ActionTemplateNotFoundFault");
	case SOAP_TYPE_PointerTo_ns5__ActionRuleNotFoundFault:
		return soap_out_PointerTo_ns5__ActionRuleNotFoundFault(soap, tag, id, (_ns5__ActionRuleNotFoundFault *const*)ptr, "ns5:ActionRuleNotFoundFault");
	case SOAP_TYPE_PointerTo_ns5__ActionConfigurationNotFoundFault:
		return soap_out_PointerTo_ns5__ActionConfigurationNotFoundFault(soap, tag, id, (_ns5__ActionConfigurationNotFoundFault *const*)ptr, "ns5:ActionConfigurationNotFoundFault");
	case SOAP_TYPE_PointerTo_ns5__ActionConfigurationIsInUseFault:
		return soap_out_PointerTo_ns5__ActionConfigurationIsInUseFault(soap, tag, id, (_ns5__ActionConfigurationIsInUseFault *const*)ptr, "ns5:ActionConfigurationIsInUseFault");
	case SOAP_TYPE_PointerTo_ns1__ScheduledEventNotFoundFault:
		return soap_out_PointerTo_ns1__ScheduledEventNotFoundFault(soap, tag, id, (_ns1__ScheduledEventNotFoundFault *const*)ptr, "ns1:ScheduledEventNotFoundFault");
	case SOAP_TYPE_PointerTo_ns1__ScheduledEventAlreadyExistsFault:
		return soap_out_PointerTo_ns1__ScheduledEventAlreadyExistsFault(soap, tag, id, (_ns1__ScheduledEventAlreadyExistsFault *const*)ptr, "ns1:ScheduledEventAlreadyExistsFault");
	case SOAP_TYPE_PointerTo_ns1__InvalidScheduledEventIDFault:
		return soap_out_PointerTo_ns1__InvalidScheduledEventIDFault(soap, tag, id, (_ns1__InvalidScheduledEventIDFault *const*)ptr, "ns1:InvalidScheduledEventIDFault");
	case SOAP_TYPE_PointerTo_ns1__InvalidScheduleFault:
		return soap_out_PointerTo_ns1__InvalidScheduleFault(soap, tag, id, (_ns1__InvalidScheduleFault *const*)ptr, "ns1:InvalidScheduleFault");
	case SOAP_TYPE_PointerToxsd__NCName:
		return soap_out_PointerToxsd__NCName(soap, tag, id, (std::string *const*)ptr, "xsd:NCName");
	case SOAP_TYPE_PointerTons2__ConcreteTopicExpression:
		return soap_out_PointerTons2__ConcreteTopicExpression(soap, tag, id, (std::string *const*)ptr, "ns2:ConcreteTopicExpression");
	case SOAP_TYPE_PointerToxsd__QName:
		return soap_out_PointerToxsd__QName(soap, tag, id, (std::string *const*)ptr, "xsd:QName");
	case SOAP_TYPE_PointerTons2__TopicType:
		return soap_out_PointerTons2__TopicType(soap, tag, id, (ns2__TopicType *const*)ptr, "ns2:TopicType");
	case SOAP_TYPE_PointerTons2__QueryExpressionType:
		return soap_out_PointerTons2__QueryExpressionType(soap, tag, id, (ns2__QueryExpressionType *const*)ptr, "ns2:QueryExpressionType");
	case SOAP_TYPE_PointerToxsd__anyURI:
		return soap_out_PointerToxsd__anyURI(soap, tag, id, (std::string *const*)ptr, "xsd:anyURI");
	case SOAP_TYPE_PointerTons6__MetadataType:
		return soap_out_PointerTons6__MetadataType(soap, tag, id, (ns6__MetadataType *const*)ptr, "ns6:MetadataType");
	case SOAP_TYPE_PointerTons6__ReferenceParametersType:
		return soap_out_PointerTons6__ReferenceParametersType(soap, tag, id, (ns6__ReferenceParametersType *const*)ptr, "ns6:ReferenceParametersType");
	case SOAP_TYPE_PointerTons6__AttributedURIType:
		return soap_out_PointerTons6__AttributedURIType(soap, tag, id, (ns6__AttributedURIType *const*)ptr, "ns6:AttributedURIType");
	case SOAP_TYPE_PointerTons5__UsedByActionRules:
		return soap_out_PointerTons5__UsedByActionRules(soap, tag, id, (ns5__UsedByActionRules *const*)ptr, "ns5:UsedByActionRules");
	case SOAP_TYPE_PointerTons5__ActionRules:
		return soap_out_PointerTons5__ActionRules(soap, tag, id, (ns5__ActionRules *const*)ptr, "ns5:ActionRules");
	case SOAP_TYPE_PointerTons5__NewActionRule:
		return soap_out_PointerTons5__NewActionRule(soap, tag, id, (ns5__NewActionRule *const*)ptr, "ns5:NewActionRule");
	case SOAP_TYPE_PointerTons5__RecipientConfigurations:
		return soap_out_PointerTons5__RecipientConfigurations(soap, tag, id, (ns5__RecipientConfigurations *const*)ptr, "ns5:RecipientConfigurations");
	case SOAP_TYPE_PointerTons5__NewRecipientConfiguration:
		return soap_out_PointerTons5__NewRecipientConfiguration(soap, tag, id, (ns5__NewRecipientConfiguration *const*)ptr, "ns5:NewRecipientConfiguration");
	case SOAP_TYPE_PointerTons5__RecipientTemplates:
		return soap_out_PointerTons5__RecipientTemplates(soap, tag, id, (ns5__RecipientTemplates *const*)ptr, "ns5:RecipientTemplates");
	case SOAP_TYPE_PointerTons5__ActionConfigurations:
		return soap_out_PointerTons5__ActionConfigurations(soap, tag, id, (ns5__ActionConfigurations *const*)ptr, "ns5:ActionConfigurations");
	case SOAP_TYPE_PointerTons5__NewActionConfiguration:
		return soap_out_PointerTons5__NewActionConfiguration(soap, tag, id, (ns5__NewActionConfiguration *const*)ptr, "ns5:NewActionConfiguration");
	case SOAP_TYPE_PointerTons5__ActionTemplates:
		return soap_out_PointerTons5__ActionTemplates(soap, tag, id, (ns5__ActionTemplates *const*)ptr, "ns5:ActionTemplates");
	case SOAP_TYPE_PointerTons5__UsedActionRule:
		return soap_out_PointerTons5__UsedActionRule(soap, tag, id, (ns5__UsedActionRule *const*)ptr, "ns5:UsedActionRule");
	case SOAP_TYPE_PointerTons5__UsedActionConfiguration:
		return soap_out_PointerTons5__UsedActionConfiguration(soap, tag, id, (ns5__UsedActionConfiguration *const*)ptr, "ns5:UsedActionConfiguration");
	case SOAP_TYPE_PointerTons5__ActionTemplateParameter:
		return soap_out_PointerTons5__ActionTemplateParameter(soap, tag, id, (ns5__ActionTemplateParameter *const*)ptr, "ns5:ActionTemplateParameter");
	case SOAP_TYPE_PointerTons5__ActionTemplate:
		return soap_out_PointerTons5__ActionTemplate(soap, tag, id, (ns5__ActionTemplate *const*)ptr, "ns5:ActionTemplate");
	case SOAP_TYPE_PointerTons5__ActionParameter:
		return soap_out_PointerTons5__ActionParameter(soap, tag, id, (ns5__ActionParameter *const*)ptr, "ns5:ActionParameter");
	case SOAP_TYPE_PointerTons5__ActionConfiguration:
		return soap_out_PointerTons5__ActionConfiguration(soap, tag, id, (ns5__ActionConfiguration *const*)ptr, "ns5:ActionConfiguration");
	case SOAP_TYPE_PointerTons5__ActionTemplateParameters:
		return soap_out_PointerTons5__ActionTemplateParameters(soap, tag, id, (ns5__ActionTemplateParameters *const*)ptr, "ns5:ActionTemplateParameters");
	case SOAP_TYPE_PointerTons5__RecipientTemplate:
		return soap_out_PointerTons5__RecipientTemplate(soap, tag, id, (ns5__RecipientTemplate *const*)ptr, "ns5:RecipientTemplate");
	case SOAP_TYPE_PointerTons5__RecipientConfiguration:
		return soap_out_PointerTons5__RecipientConfiguration(soap, tag, id, (ns5__RecipientConfiguration *const*)ptr, "ns5:RecipientConfiguration");
	case SOAP_TYPE_PointerTons5__ActionParameters:
		return soap_out_PointerTons5__ActionParameters(soap, tag, id, (ns5__ActionParameters *const*)ptr, "ns5:ActionParameters");
	case SOAP_TYPE_PointerTons5__ActionRule:
		return soap_out_PointerTons5__ActionRule(soap, tag, id, (ns5__ActionRule *const*)ptr, "ns5:ActionRule");
	case SOAP_TYPE_PointerToxsd__integer:
		return soap_out_PointerToxsd__integer(soap, tag, id, (std::string *const*)ptr, "xsd:integer");
	case SOAP_TYPE_PointerToxsd__duration:
		return soap_out_PointerToxsd__duration(soap, tag, id, (std::string *const*)ptr, "xsd:duration");
	case SOAP_TYPE_PointerTons5__Conditions:
		return soap_out_PointerTons5__Conditions(soap, tag, id, (ns5__Conditions *const*)ptr, "ns5:Conditions");
	case SOAP_TYPE_PointerTo_ns4__BaseFaultType_FaultCause:
		return soap_out_PointerTo_ns4__BaseFaultType_FaultCause(soap, tag, id, (_ns4__BaseFaultType_FaultCause *const*)ptr, "ns4:BaseFaultType-FaultCause");
	case SOAP_TYPE_PointerTo_xml__lang:
		return soap_out_PointerTo_xml__lang(soap, tag, id, (std::string *const*)ptr, "xml:lang");
	case SOAP_TYPE_PointerTo_ns4__BaseFaultType_ErrorCode:
		return soap_out_PointerTo_ns4__BaseFaultType_ErrorCode(soap, tag, id, (_ns4__BaseFaultType_ErrorCode *const*)ptr, "ns4:BaseFaultType-ErrorCode");
	case SOAP_TYPE_PointerToxsd__nonNegativeInteger:
		return soap_out_PointerToxsd__nonNegativeInteger(soap, tag, id, (std::string *const*)ptr, "xsd:nonNegativeInteger");
	case SOAP_TYPE_PointerTo_ns3__Subscribe_SubscriptionPolicy:
		return soap_out_PointerTo_ns3__Subscribe_SubscriptionPolicy(soap, tag, id, (_ns3__Subscribe_SubscriptionPolicy *const*)ptr, "ns3:Subscribe-SubscriptionPolicy");
	case SOAP_TYPE_PointerTons3__AbsoluteOrRelativeTimeType:
		return soap_out_PointerTons3__AbsoluteOrRelativeTimeType(soap, tag, id, (std::string *const*)ptr, "ns3:AbsoluteOrRelativeTimeType");
	case SOAP_TYPE_PointerTons3__NotificationMessageHolderType:
		return soap_out_PointerTons3__NotificationMessageHolderType(soap, tag, id, (ns3__NotificationMessageHolderType *const*)ptr, "ns3:NotificationMessageHolderType");
	case SOAP_TYPE_PointerTodateTime:
		return soap_out_PointerTodateTime(soap, tag, id, (time_t *const*)ptr, "xsd:dateTime");
	case SOAP_TYPE_PointerTons3__SubscriptionPolicyType:
		return soap_out_PointerTons3__SubscriptionPolicyType(soap, tag, id, (ns3__SubscriptionPolicyType *const*)ptr, "ns3:SubscriptionPolicyType");
	case SOAP_TYPE_PointerTons3__FilterType:
		return soap_out_PointerTons3__FilterType(soap, tag, id, (ns3__FilterType *const*)ptr, "ns3:FilterType");
	case SOAP_TYPE_PointerTobool:
		return soap_out_PointerTobool(soap, tag, id, (bool *const*)ptr, "xsd:boolean");
	case SOAP_TYPE_PointerTons3__TopicExpressionType:
		return soap_out_PointerTons3__TopicExpressionType(soap, tag, id, (ns3__TopicExpressionType *const*)ptr, "ns3:TopicExpressionType");
	case SOAP_TYPE_PointerTons6__EndpointReferenceType:
		return soap_out_PointerTons6__EndpointReferenceType(soap, tag, id, (ns6__EndpointReferenceType *const*)ptr, "ns6:EndpointReferenceType");
	case SOAP_TYPE_PointerTons2__Documentation:
		return soap_out_PointerTons2__Documentation(soap, tag, id, (ns2__Documentation *const*)ptr, "ns2:Documentation");
	case SOAP_TYPE_PointerTons1__ScheduledEvents:
		return soap_out_PointerTons1__ScheduledEvents(soap, tag, id, (ns1__ScheduledEvents *const*)ptr, "ns1:ScheduledEvents");
	case SOAP_TYPE_PointerTons1__ScheduleFilter:
		return soap_out_PointerTons1__ScheduleFilter(soap, tag, id, (ns1__ScheduleFilter *const*)ptr, "ns1:ScheduleFilter");
	case SOAP_TYPE_PointerTons1__NewScheduledEvent:
		return soap_out_PointerTons1__NewScheduledEvent(soap, tag, id, (ns1__NewScheduledEvent *const*)ptr, "ns1:NewScheduledEvent");
	case SOAP_TYPE_PointerTons2__TopicSetType:
		return soap_out_PointerTons2__TopicSetType(soap, tag, id, (ns2__TopicSetType *const*)ptr, "ns2:TopicSetType");
	case SOAP_TYPE_PointerTons1__ScheduledType:
		return soap_out_PointerTons1__ScheduledType(soap, tag, id, (ns1__ScheduledType *const*)ptr, "ns1:ScheduledType");
	case SOAP_TYPE_PointerTons1__ICalendar:
		return soap_out_PointerTons1__ICalendar(soap, tag, id, (ns1__ICalendar *const*)ptr, "ns1:ICalendar");
	case SOAP_TYPE_PointerTons1__ScheduledEvent:
		return soap_out_PointerTons1__ScheduledEvent(soap, tag, id, (ns1__ScheduledEvent *const*)ptr, "ns1:ScheduledEvent");
	case SOAP_TYPE_PointerTons1__Schedule:
		return soap_out_PointerTons1__Schedule(soap, tag, id, (ns1__Schedule *const*)ptr, "ns1:Schedule");
	case SOAP_TYPE_PointerTostd__string:
		return soap_out_PointerTostd__string(soap, tag, id, (std::string *const*)ptr, "xsd:string");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:string");
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_putelement '%s' failed for type %d in generated_with_soapcpp2\soapC.cpp\n", tag ? tag : "", type));
	return soap->error = SOAP_TYPE; /* unknown type to serialize */
}
#ifdef __cplusplus
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE__ns2__TopicNamespaceType_Topic:
		((_ns2__TopicNamespaceType_Topic *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns4__BaseFaultType_FaultCause:
		((_ns4__BaseFaultType_FaultCause *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns4__BaseFaultType_Description:
		((_ns4__BaseFaultType_Description *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns4__BaseFaultType_ErrorCode:
		((_ns4__BaseFaultType_ErrorCode *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__Subscribe_SubscriptionPolicy:
		((_ns3__Subscribe_SubscriptionPolicy *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__NotificationMessageHolderType_Message:
		((_ns3__NotificationMessageHolderType_Message *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__FaultCodesType__:
		((ns6__FaultCodesType__ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__RelationshipType__:
		((ns6__RelationshipType__ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__SimpleTopicExpression__:
		((ns2__SimpleTopicExpression__ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__SimpleTopicExpression:
		soap_serialize_ns2__SimpleTopicExpression(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns2__ConcreteTopicExpression__:
		((ns2__ConcreteTopicExpression__ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ConcreteTopicExpression:
		soap_serialize_ns2__ConcreteTopicExpression(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns2__FullTopicExpression__:
		((ns2__FullTopicExpression__ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__FullTopicExpression:
		soap_serialize_ns2__FullTopicExpression(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns1__ScheduledType__:
		((ns1__ScheduledType__ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__FaultCodesOpenEnumType:
		soap_serialize_ns6__FaultCodesOpenEnumType(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns6__RelationshipTypeOpenEnum:
		soap_serialize_ns6__RelationshipTypeOpenEnum(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns3__AbsoluteOrRelativeTimeType:
		soap_serialize_ns3__AbsoluteOrRelativeTimeType(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns6__ProblemActionType:
		((ns6__ProblemActionType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__AttributedQNameType:
		((ns6__AttributedQNameType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__AttributedUnsignedLongType:
		((ns6__AttributedUnsignedLongType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__AttributedURIType:
		((ns6__AttributedURIType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__RelatesToType:
		((ns6__RelatesToType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__MetadataType:
		((ns6__MetadataType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__ReferenceParametersType:
		((ns6__ReferenceParametersType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__EndpointReferenceType:
		((ns6__EndpointReferenceType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns5__InvalidActivationTimeoutFault:
		((_ns5__InvalidActivationTimeoutFault *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns5__ActionRuleNotFoundFault:
		((_ns5__ActionRuleNotFoundFault *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns5__InsufficientActivationRuleFault:
		((_ns5__InsufficientActivationRuleFault *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns5__InvalidConditionFilterFault:
		((_ns5__InvalidConditionFilterFault *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns5__ActionConfigurationIsInUseFault:
		((_ns5__ActionConfigurationIsInUseFault *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns5__RecipientTemplateNotFoundFault:
		((_ns5__RecipientTemplateNotFoundFault *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns5__ActionConfigurationNotFoundFault:
		((_ns5__ActionConfigurationNotFoundFault *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns5__InvalidActionConfigurationFault:
		((_ns5__InvalidActionConfigurationFault *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns5__ParametersMissmatchFault:
		((_ns5__ParametersMissmatchFault *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns5__RecipientConfigurationNotFoundFault:
		((_ns5__RecipientConfigurationNotFoundFault *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns5__ActionTemplateNotFoundFault:
		((_ns5__ActionTemplateNotFoundFault *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns5__RemoveActionRuleResponse:
		((_ns5__RemoveActionRuleResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns5__RemoveActionRule:
		((_ns5__RemoveActionRule *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns5__GetActionRulesResponse:
		((_ns5__GetActionRulesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns5__GetActionRules:
		((_ns5__GetActionRules *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns5__AddActionRuleResponse:
		((_ns5__AddActionRuleResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns5__AddActionRule:
		((_ns5__AddActionRule *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns5__GetRecipientConfigurationsResponse:
		((_ns5__GetRecipientConfigurationsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns5__GetRecipientConfigurations:
		((_ns5__GetRecipientConfigurations *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns5__RemoveRecipientConfigurationResponse:
		((_ns5__RemoveRecipientConfigurationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns5__RemoveRecipientConfiguration:
		((_ns5__RemoveRecipientConfiguration *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns5__AddRecipientConfigurationResponse:
		((_ns5__AddRecipientConfigurationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns5__AddRecipientConfiguration:
		((_ns5__AddRecipientConfiguration *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns5__GetRecipientTemplatesResponse:
		((_ns5__GetRecipientTemplatesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns5__GetRecipientTemplates:
		((_ns5__GetRecipientTemplates *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns5__GetActionConfigurationsResponse:
		((_ns5__GetActionConfigurationsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns5__GetActionConfigurations:
		((_ns5__GetActionConfigurations *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns5__RemoveActionConfigurationResponse:
		((_ns5__RemoveActionConfigurationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns5__RemoveActionConfiguration:
		((_ns5__RemoveActionConfiguration *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns5__AddActionConfigurationResponse:
		((_ns5__AddActionConfigurationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns5__AddActionConfiguration:
		((_ns5__AddActionConfiguration *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns5__GetActionTemplatesResponse:
		((_ns5__GetActionTemplatesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns5__GetActionTemplates:
		((_ns5__GetActionTemplates *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__UsedActionRule:
		((ns5__UsedActionRule *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__UsedByActionRules:
		((ns5__UsedByActionRules *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__UsedActionConfiguration:
		((ns5__UsedActionConfiguration *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__UsedByActionConfigurations:
		((ns5__UsedByActionConfigurations *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__ActionTemplateParameter:
		((ns5__ActionTemplateParameter *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__ActionTemplateParameters:
		((ns5__ActionTemplateParameters *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__ActionTemplate:
		((ns5__ActionTemplate *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__ActionParameter:
		((ns5__ActionParameter *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__ActionTemplates:
		((ns5__ActionTemplates *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__ActionParameters:
		((ns5__ActionParameters *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__ActionConfiguration:
		((ns5__ActionConfiguration *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__NewActionConfiguration:
		((ns5__NewActionConfiguration *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__ActionConfigurations:
		((ns5__ActionConfigurations *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__RecipientTemplate:
		((ns5__RecipientTemplate *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__RecipientTemplates:
		((ns5__RecipientTemplates *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__RecipientConfigurations:
		((ns5__RecipientConfigurations *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__RecipientConfiguration:
		((ns5__RecipientConfiguration *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__NewRecipientConfiguration:
		((ns5__NewRecipientConfiguration *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__ActionRule:
		((ns5__ActionRule *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__ActionRules:
		((ns5__ActionRules *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__Conditions:
		((ns5__Conditions *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__NewActionRule:
		((ns5__NewActionRule *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__BaseFaultType:
		((ns4__BaseFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__ResumeSubscriptionResponse:
		((_ns3__ResumeSubscriptionResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__ResumeSubscription:
		((_ns3__ResumeSubscription *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__PauseSubscriptionResponse:
		((_ns3__PauseSubscriptionResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__PauseSubscription:
		((_ns3__PauseSubscription *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__UnsubscribeResponse:
		((_ns3__UnsubscribeResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__Unsubscribe:
		((_ns3__Unsubscribe *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__RenewResponse:
		((_ns3__RenewResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__Renew:
		((_ns3__Renew *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__CreatePullPointResponse:
		((_ns3__CreatePullPointResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__CreatePullPoint:
		((_ns3__CreatePullPoint *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__DestroyPullPointResponse:
		((_ns3__DestroyPullPointResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__DestroyPullPoint:
		((_ns3__DestroyPullPoint *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__GetMessagesResponse:
		((_ns3__GetMessagesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__GetMessages:
		((_ns3__GetMessages *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__GetCurrentMessageResponse:
		((_ns3__GetCurrentMessageResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__GetCurrentMessage:
		((_ns3__GetCurrentMessage *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__SubscribeResponse:
		((_ns3__SubscribeResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__Subscribe:
		((_ns3__Subscribe *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__UseRaw:
		((_ns3__UseRaw *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__Notify:
		((_ns3__Notify *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__SubscriptionManagerRP:
		((_ns3__SubscriptionManagerRP *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__NotificationProducerRP:
		((_ns3__NotificationProducerRP *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__ResumeFailedFaultType:
		((ns3__ResumeFailedFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__PauseFailedFaultType:
		((ns3__PauseFailedFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__UnableToDestroySubscriptionFaultType:
		((ns3__UnableToDestroySubscriptionFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__UnacceptableTerminationTimeFaultType:
		((ns3__UnacceptableTerminationTimeFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__UnableToCreatePullPointFaultType:
		((ns3__UnableToCreatePullPointFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__UnableToDestroyPullPointFaultType:
		((ns3__UnableToDestroyPullPointFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__UnableToGetMessagesFaultType:
		((ns3__UnableToGetMessagesFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__NoCurrentMessageOnTopicFaultType:
		((ns3__NoCurrentMessageOnTopicFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__UnacceptableInitialTerminationTimeFaultType:
		((ns3__UnacceptableInitialTerminationTimeFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__NotifyMessageNotSupportedFaultType:
		((ns3__NotifyMessageNotSupportedFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__UnsupportedPolicyRequestFaultType:
		((ns3__UnsupportedPolicyRequestFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__UnrecognizedPolicyRequestFaultType:
		((ns3__UnrecognizedPolicyRequestFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__InvalidMessageContentExpressionFaultType:
		((ns3__InvalidMessageContentExpressionFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__InvalidProducerPropertiesExpressionFaultType:
		((ns3__InvalidProducerPropertiesExpressionFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__MultipleTopicsSpecifiedFaultType:
		((ns3__MultipleTopicsSpecifiedFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__TopicNotSupportedFaultType:
		((ns3__TopicNotSupportedFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__InvalidTopicExpressionFaultType:
		((ns3__InvalidTopicExpressionFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__TopicExpressionDialectUnknownFaultType:
		((ns3__TopicExpressionDialectUnknownFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__InvalidFilterFaultType:
		((ns3__InvalidFilterFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__SubscribeCreationFailedFaultType:
		((ns3__SubscribeCreationFailedFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__NotificationMessageHolderType:
		((ns3__NotificationMessageHolderType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__SubscriptionPolicyType:
		((ns3__SubscriptionPolicyType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__FilterType:
		((ns3__FilterType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__TopicExpressionType:
		((ns3__TopicExpressionType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__QueryExpressionType:
		((ns3__QueryExpressionType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__TopicSetType:
		((ns2__TopicSetType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__TopicType:
		((ns2__TopicType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__TopicNamespaceType:
		((ns2__TopicNamespaceType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__QueryExpressionType:
		((ns2__QueryExpressionType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ExtensibleDocumented:
		((ns2__ExtensibleDocumented *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__Documentation:
		((ns2__Documentation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__ChangeVirtualInputStateResponse:
		((_ns1__ChangeVirtualInputStateResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__ChangeVirtualInputState:
		((_ns1__ChangeVirtualInputState *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__ScheduledEventAlreadyExistsFault:
		((_ns1__ScheduledEventAlreadyExistsFault *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__InvalidScheduledEventIDFault:
		((_ns1__InvalidScheduledEventIDFault *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__InvalidScheduleFault:
		((_ns1__InvalidScheduleFault *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__ScheduledEventNotFoundFault:
		((_ns1__ScheduledEventNotFoundFault *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetScheduledEventsResponse:
		((_ns1__GetScheduledEventsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetScheduledEvents:
		((_ns1__GetScheduledEvents *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__RemoveScheduledEventResponse:
		((_ns1__RemoveScheduledEventResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__RemoveScheduledEvent:
		((_ns1__RemoveScheduledEvent *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__AddScheduledEventResponse:
		((_ns1__AddScheduledEventResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__AddScheduledEvent:
		((_ns1__AddScheduledEvent *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetEventInstancesResponse:
		((_ns1__GetEventInstancesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetEventInstances:
		((_ns1__GetEventInstances *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ScheduleFilter:
		((ns1__ScheduleFilter *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ICalendar:
		((ns1__ICalendar *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__Schedule:
		((ns1__Schedule *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ScheduledEvent:
		((ns1__ScheduledEvent *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ScheduledEvents:
		((ns1__ScheduledEvents *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__NewScheduledEvent:
		((ns1__NewScheduledEvent *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__xml__lang:
		soap_serialize__xml__lang(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__unsignedLong:
		((xsd__unsignedLong *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__token_:
		((xsd__token_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__token:
		soap_serialize_xsd__token(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__string:
		((xsd__string *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__nonNegativeInteger_:
		((xsd__nonNegativeInteger_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__nonNegativeInteger:
		soap_serialize_xsd__nonNegativeInteger(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__integer_:
		((xsd__integer_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__integer:
		soap_serialize_xsd__integer(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__int:
		((xsd__int *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__duration_:
		((xsd__duration_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__duration:
		soap_serialize_xsd__duration(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__dateTime:
		((xsd__dateTime *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__boolean:
		((xsd__boolean *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__anyURI_:
		((xsd__anyURI_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__anyURI:
		soap_serialize_xsd__anyURI(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__QName_:
		((xsd__QName_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__NCName_:
		((xsd__NCName_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__NCName:
		soap_serialize_xsd__NCName(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__QName:
		soap_serialize_xsd__QName(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE___ns5__RemoveActionRule:
		soap_serialize___ns5__RemoveActionRule(soap, (const struct __ns5__RemoveActionRule *)ptr);
		break;
	case SOAP_TYPE___ns5__GetActionRules:
		soap_serialize___ns5__GetActionRules(soap, (const struct __ns5__GetActionRules *)ptr);
		break;
	case SOAP_TYPE___ns5__AddActionRule:
		soap_serialize___ns5__AddActionRule(soap, (const struct __ns5__AddActionRule *)ptr);
		break;
	case SOAP_TYPE___ns5__GetRecipientConfigurations:
		soap_serialize___ns5__GetRecipientConfigurations(soap, (const struct __ns5__GetRecipientConfigurations *)ptr);
		break;
	case SOAP_TYPE___ns5__RemoveRecipientConfiguration:
		soap_serialize___ns5__RemoveRecipientConfiguration(soap, (const struct __ns5__RemoveRecipientConfiguration *)ptr);
		break;
	case SOAP_TYPE___ns5__AddRecipientConfiguration:
		soap_serialize___ns5__AddRecipientConfiguration(soap, (const struct __ns5__AddRecipientConfiguration *)ptr);
		break;
	case SOAP_TYPE___ns5__GetRecipientTemplates:
		soap_serialize___ns5__GetRecipientTemplates(soap, (const struct __ns5__GetRecipientTemplates *)ptr);
		break;
	case SOAP_TYPE___ns5__GetActionConfigurations:
		soap_serialize___ns5__GetActionConfigurations(soap, (const struct __ns5__GetActionConfigurations *)ptr);
		break;
	case SOAP_TYPE___ns5__RemoveActionConfiguration:
		soap_serialize___ns5__RemoveActionConfiguration(soap, (const struct __ns5__RemoveActionConfiguration *)ptr);
		break;
	case SOAP_TYPE___ns5__AddActionConfiguration:
		soap_serialize___ns5__AddActionConfiguration(soap, (const struct __ns5__AddActionConfiguration *)ptr);
		break;
	case SOAP_TYPE___ns5__GetActionTemplates:
		soap_serialize___ns5__GetActionTemplates(soap, (const struct __ns5__GetActionTemplates *)ptr);
		break;
	case SOAP_TYPE___ns1__ChangeVirtualInputState:
		soap_serialize___ns1__ChangeVirtualInputState(soap, (const struct __ns1__ChangeVirtualInputState *)ptr);
		break;
	case SOAP_TYPE___ns1__GetScheduledEvents:
		soap_serialize___ns1__GetScheduledEvents(soap, (const struct __ns1__GetScheduledEvents *)ptr);
		break;
	case SOAP_TYPE___ns1__RemoveScheduledEvent:
		soap_serialize___ns1__RemoveScheduledEvent(soap, (const struct __ns1__RemoveScheduledEvent *)ptr);
		break;
	case SOAP_TYPE___ns1__AddScheduledEvent:
		soap_serialize___ns1__AddScheduledEvent(soap, (const struct __ns1__AddScheduledEvent *)ptr);
		break;
	case SOAP_TYPE___ns1__GetEventInstances:
		soap_serialize___ns1__GetEventInstances(soap, (const struct __ns1__GetEventInstances *)ptr);
		break;
	case SOAP_TYPE_xsd__anyAttribute:
		soap_serialize_xsd__anyAttribute(soap, (const struct soap_dom_attribute *)ptr);
		break;
	case SOAP_TYPE_xsd__anyType:
		soap_serialize_xsd__anyType(soap, (const struct soap_dom_element *)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns5__RemoveActionRule:
		soap_serialize_PointerTo_ns5__RemoveActionRule(soap, (_ns5__RemoveActionRule *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns5__GetActionRules:
		soap_serialize_PointerTo_ns5__GetActionRules(soap, (_ns5__GetActionRules *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns5__AddActionRule:
		soap_serialize_PointerTo_ns5__AddActionRule(soap, (_ns5__AddActionRule *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns5__GetRecipientConfigurations:
		soap_serialize_PointerTo_ns5__GetRecipientConfigurations(soap, (_ns5__GetRecipientConfigurations *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns5__RemoveRecipientConfiguration:
		soap_serialize_PointerTo_ns5__RemoveRecipientConfiguration(soap, (_ns5__RemoveRecipientConfiguration *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns5__AddRecipientConfiguration:
		soap_serialize_PointerTo_ns5__AddRecipientConfiguration(soap, (_ns5__AddRecipientConfiguration *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns5__GetRecipientTemplates:
		soap_serialize_PointerTo_ns5__GetRecipientTemplates(soap, (_ns5__GetRecipientTemplates *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns5__GetActionConfigurations:
		soap_serialize_PointerTo_ns5__GetActionConfigurations(soap, (_ns5__GetActionConfigurations *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns5__RemoveActionConfiguration:
		soap_serialize_PointerTo_ns5__RemoveActionConfiguration(soap, (_ns5__RemoveActionConfiguration *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns5__AddActionConfiguration:
		soap_serialize_PointerTo_ns5__AddActionConfiguration(soap, (_ns5__AddActionConfiguration *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns5__GetActionTemplates:
		soap_serialize_PointerTo_ns5__GetActionTemplates(soap, (_ns5__GetActionTemplates *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__ChangeVirtualInputState:
		soap_serialize_PointerTo_ns1__ChangeVirtualInputState(soap, (_ns1__ChangeVirtualInputState *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetScheduledEvents:
		soap_serialize_PointerTo_ns1__GetScheduledEvents(soap, (_ns1__GetScheduledEvents *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__RemoveScheduledEvent:
		soap_serialize_PointerTo_ns1__RemoveScheduledEvent(soap, (_ns1__RemoveScheduledEvent *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__AddScheduledEvent:
		soap_serialize_PointerTo_ns1__AddScheduledEvent(soap, (_ns1__AddScheduledEvent *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetEventInstances:
		soap_serialize_PointerTo_ns1__GetEventInstances(soap, (_ns1__GetEventInstances *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__TopicExpressionDialectUnknownFaultType:
		soap_serialize_PointerTons3__TopicExpressionDialectUnknownFaultType(soap, (ns3__TopicExpressionDialectUnknownFaultType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns5__RecipientTemplateNotFoundFault:
		soap_serialize_PointerTo_ns5__RecipientTemplateNotFoundFault(soap, (_ns5__RecipientTemplateNotFoundFault *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns5__RecipientConfigurationNotFoundFault:
		soap_serialize_PointerTo_ns5__RecipientConfigurationNotFoundFault(soap, (_ns5__RecipientConfigurationNotFoundFault *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns5__ParametersMissmatchFault:
		soap_serialize_PointerTo_ns5__ParametersMissmatchFault(soap, (_ns5__ParametersMissmatchFault *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__InvalidTopicExpressionFaultType:
		soap_serialize_PointerTons3__InvalidTopicExpressionFaultType(soap, (ns3__InvalidTopicExpressionFaultType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__InvalidMessageContentExpressionFaultType:
		soap_serialize_PointerTons3__InvalidMessageContentExpressionFaultType(soap, (ns3__InvalidMessageContentExpressionFaultType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__InvalidFilterFaultType:
		soap_serialize_PointerTons3__InvalidFilterFaultType(soap, (ns3__InvalidFilterFaultType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns5__InvalidConditionFilterFault:
		soap_serialize_PointerTo_ns5__InvalidConditionFilterFault(soap, (_ns5__InvalidConditionFilterFault *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns5__InvalidActivationTimeoutFault:
		soap_serialize_PointerTo_ns5__InvalidActivationTimeoutFault(soap, (_ns5__InvalidActivationTimeoutFault *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns5__InvalidActionConfigurationFault:
		soap_serialize_PointerTo_ns5__InvalidActionConfigurationFault(soap, (_ns5__InvalidActionConfigurationFault *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns5__InsufficientActivationRuleFault:
		soap_serialize_PointerTo_ns5__InsufficientActivationRuleFault(soap, (_ns5__InsufficientActivationRuleFault *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns5__ActionTemplateNotFoundFault:
		soap_serialize_PointerTo_ns5__ActionTemplateNotFoundFault(soap, (_ns5__ActionTemplateNotFoundFault *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns5__ActionRuleNotFoundFault:
		soap_serialize_PointerTo_ns5__ActionRuleNotFoundFault(soap, (_ns5__ActionRuleNotFoundFault *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns5__ActionConfigurationNotFoundFault:
		soap_serialize_PointerTo_ns5__ActionConfigurationNotFoundFault(soap, (_ns5__ActionConfigurationNotFoundFault *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns5__ActionConfigurationIsInUseFault:
		soap_serialize_PointerTo_ns5__ActionConfigurationIsInUseFault(soap, (_ns5__ActionConfigurationIsInUseFault *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__ScheduledEventNotFoundFault:
		soap_serialize_PointerTo_ns1__ScheduledEventNotFoundFault(soap, (_ns1__ScheduledEventNotFoundFault *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__ScheduledEventAlreadyExistsFault:
		soap_serialize_PointerTo_ns1__ScheduledEventAlreadyExistsFault(soap, (_ns1__ScheduledEventAlreadyExistsFault *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__InvalidScheduledEventIDFault:
		soap_serialize_PointerTo_ns1__InvalidScheduledEventIDFault(soap, (_ns1__InvalidScheduledEventIDFault *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__InvalidScheduleFault:
		soap_serialize_PointerTo_ns1__InvalidScheduleFault(soap, (_ns1__InvalidScheduleFault *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__NCName:
		soap_serialize_PointerToxsd__NCName(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ConcreteTopicExpression:
		soap_serialize_PointerTons2__ConcreteTopicExpression(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__QName:
		soap_serialize_PointerToxsd__QName(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__TopicType:
		soap_serialize_PointerTons2__TopicType(soap, (ns2__TopicType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__QueryExpressionType:
		soap_serialize_PointerTons2__QueryExpressionType(soap, (ns2__QueryExpressionType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__anyURI:
		soap_serialize_PointerToxsd__anyURI(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons6__MetadataType:
		soap_serialize_PointerTons6__MetadataType(soap, (ns6__MetadataType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons6__ReferenceParametersType:
		soap_serialize_PointerTons6__ReferenceParametersType(soap, (ns6__ReferenceParametersType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons6__AttributedURIType:
		soap_serialize_PointerTons6__AttributedURIType(soap, (ns6__AttributedURIType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons5__UsedByActionRules:
		soap_serialize_PointerTons5__UsedByActionRules(soap, (ns5__UsedByActionRules *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons5__ActionRules:
		soap_serialize_PointerTons5__ActionRules(soap, (ns5__ActionRules *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons5__NewActionRule:
		soap_serialize_PointerTons5__NewActionRule(soap, (ns5__NewActionRule *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons5__RecipientConfigurations:
		soap_serialize_PointerTons5__RecipientConfigurations(soap, (ns5__RecipientConfigurations *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons5__NewRecipientConfiguration:
		soap_serialize_PointerTons5__NewRecipientConfiguration(soap, (ns5__NewRecipientConfiguration *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons5__RecipientTemplates:
		soap_serialize_PointerTons5__RecipientTemplates(soap, (ns5__RecipientTemplates *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons5__ActionConfigurations:
		soap_serialize_PointerTons5__ActionConfigurations(soap, (ns5__ActionConfigurations *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons5__NewActionConfiguration:
		soap_serialize_PointerTons5__NewActionConfiguration(soap, (ns5__NewActionConfiguration *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons5__ActionTemplates:
		soap_serialize_PointerTons5__ActionTemplates(soap, (ns5__ActionTemplates *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons5__UsedActionRule:
		soap_serialize_PointerTons5__UsedActionRule(soap, (ns5__UsedActionRule *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons5__UsedActionConfiguration:
		soap_serialize_PointerTons5__UsedActionConfiguration(soap, (ns5__UsedActionConfiguration *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons5__ActionTemplateParameter:
		soap_serialize_PointerTons5__ActionTemplateParameter(soap, (ns5__ActionTemplateParameter *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons5__ActionTemplate:
		soap_serialize_PointerTons5__ActionTemplate(soap, (ns5__ActionTemplate *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons5__ActionParameter:
		soap_serialize_PointerTons5__ActionParameter(soap, (ns5__ActionParameter *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons5__ActionConfiguration:
		soap_serialize_PointerTons5__ActionConfiguration(soap, (ns5__ActionConfiguration *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons5__ActionTemplateParameters:
		soap_serialize_PointerTons5__ActionTemplateParameters(soap, (ns5__ActionTemplateParameters *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons5__RecipientTemplate:
		soap_serialize_PointerTons5__RecipientTemplate(soap, (ns5__RecipientTemplate *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons5__RecipientConfiguration:
		soap_serialize_PointerTons5__RecipientConfiguration(soap, (ns5__RecipientConfiguration *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons5__ActionParameters:
		soap_serialize_PointerTons5__ActionParameters(soap, (ns5__ActionParameters *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons5__ActionRule:
		soap_serialize_PointerTons5__ActionRule(soap, (ns5__ActionRule *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__integer:
		soap_serialize_PointerToxsd__integer(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__duration:
		soap_serialize_PointerToxsd__duration(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons5__Conditions:
		soap_serialize_PointerTons5__Conditions(soap, (ns5__Conditions *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns4__BaseFaultType_FaultCause:
		soap_serialize_PointerTo_ns4__BaseFaultType_FaultCause(soap, (_ns4__BaseFaultType_FaultCause *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_xml__lang:
		soap_serialize_PointerTo_xml__lang(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns4__BaseFaultType_ErrorCode:
		soap_serialize_PointerTo_ns4__BaseFaultType_ErrorCode(soap, (_ns4__BaseFaultType_ErrorCode *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__nonNegativeInteger:
		soap_serialize_PointerToxsd__nonNegativeInteger(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__Subscribe_SubscriptionPolicy:
		soap_serialize_PointerTo_ns3__Subscribe_SubscriptionPolicy(soap, (_ns3__Subscribe_SubscriptionPolicy *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__AbsoluteOrRelativeTimeType:
		soap_serialize_PointerTons3__AbsoluteOrRelativeTimeType(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__NotificationMessageHolderType:
		soap_serialize_PointerTons3__NotificationMessageHolderType(soap, (ns3__NotificationMessageHolderType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTodateTime:
		soap_serialize_PointerTodateTime(soap, (time_t *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__SubscriptionPolicyType:
		soap_serialize_PointerTons3__SubscriptionPolicyType(soap, (ns3__SubscriptionPolicyType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__FilterType:
		soap_serialize_PointerTons3__FilterType(soap, (ns3__FilterType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTobool:
		soap_serialize_PointerTobool(soap, (bool *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__TopicExpressionType:
		soap_serialize_PointerTons3__TopicExpressionType(soap, (ns3__TopicExpressionType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons6__EndpointReferenceType:
		soap_serialize_PointerTons6__EndpointReferenceType(soap, (ns6__EndpointReferenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__Documentation:
		soap_serialize_PointerTons2__Documentation(soap, (ns2__Documentation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ScheduledEvents:
		soap_serialize_PointerTons1__ScheduledEvents(soap, (ns1__ScheduledEvents *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ScheduleFilter:
		soap_serialize_PointerTons1__ScheduleFilter(soap, (ns1__ScheduleFilter *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__NewScheduledEvent:
		soap_serialize_PointerTons1__NewScheduledEvent(soap, (ns1__NewScheduledEvent *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__TopicSetType:
		soap_serialize_PointerTons2__TopicSetType(soap, (ns2__TopicSetType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ScheduledType:
		soap_serialize_PointerTons1__ScheduledType(soap, (ns1__ScheduledType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ICalendar:
		soap_serialize_PointerTons1__ICalendar(soap, (ns1__ICalendar *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ScheduledEvent:
		soap_serialize_PointerTons1__ScheduledEvent(soap, (ns1__ScheduledEvent *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Schedule:
		soap_serialize_PointerTons1__Schedule(soap, (ns1__Schedule *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostd__string:
		soap_serialize_PointerTostd__string(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	}
}
#ifdef __cplusplus
}
#endif
#endif

#ifdef __cplusplus
extern "C" {
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_dupelement(struct soap *soap, const void *ptr, int type)
{(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	return NULL;
}
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_delelement(const void *ptr, int type)
{(void)ptr; (void)type; /* appease -Wall -Werror */
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{	(void)type;
	switch (t)
	{
	case SOAP_TYPE_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__NCName_:
		return (void*)soap_instantiate_xsd__NCName_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__QName_:
		return (void*)soap_instantiate_xsd__QName_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__anyURI_:
		return (void*)soap_instantiate_xsd__anyURI_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__boolean:
		return (void*)soap_instantiate_xsd__boolean(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__dateTime:
		return (void*)soap_instantiate_xsd__dateTime(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__duration_:
		return (void*)soap_instantiate_xsd__duration_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__int:
		return (void*)soap_instantiate_xsd__int(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__integer_:
		return (void*)soap_instantiate_xsd__integer_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__nonNegativeInteger_:
		return (void*)soap_instantiate_xsd__nonNegativeInteger_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__string:
		return (void*)soap_instantiate_xsd__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__token_:
		return (void*)soap_instantiate_xsd__token_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__unsignedLong:
		return (void*)soap_instantiate_xsd__unsignedLong(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ScheduledType__:
		return (void*)soap_instantiate_ns1__ScheduledType__(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__FullTopicExpression__:
		return (void*)soap_instantiate_ns2__FullTopicExpression__(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ConcreteTopicExpression__:
		return (void*)soap_instantiate_ns2__ConcreteTopicExpression__(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__SimpleTopicExpression__:
		return (void*)soap_instantiate_ns2__SimpleTopicExpression__(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__RelationshipType__:
		return (void*)soap_instantiate_ns6__RelationshipType__(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__FaultCodesType__:
		return (void*)soap_instantiate_ns6__FaultCodesType__(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__NewScheduledEvent:
		return (void*)soap_instantiate_ns1__NewScheduledEvent(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ScheduledEvents:
		return (void*)soap_instantiate_ns1__ScheduledEvents(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ScheduledEvent:
		return (void*)soap_instantiate_ns1__ScheduledEvent(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Schedule:
		return (void*)soap_instantiate_ns1__Schedule(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ScheduleFilter:
		return (void*)soap_instantiate_ns1__ScheduleFilter(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetEventInstances:
		return (void*)soap_instantiate__ns1__GetEventInstances(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetEventInstancesResponse:
		return (void*)soap_instantiate__ns1__GetEventInstancesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__AddScheduledEvent:
		return (void*)soap_instantiate__ns1__AddScheduledEvent(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__AddScheduledEventResponse:
		return (void*)soap_instantiate__ns1__AddScheduledEventResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__RemoveScheduledEvent:
		return (void*)soap_instantiate__ns1__RemoveScheduledEvent(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__RemoveScheduledEventResponse:
		return (void*)soap_instantiate__ns1__RemoveScheduledEventResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetScheduledEvents:
		return (void*)soap_instantiate__ns1__GetScheduledEvents(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetScheduledEventsResponse:
		return (void*)soap_instantiate__ns1__GetScheduledEventsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__ScheduledEventNotFoundFault:
		return (void*)soap_instantiate__ns1__ScheduledEventNotFoundFault(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__InvalidScheduleFault:
		return (void*)soap_instantiate__ns1__InvalidScheduleFault(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__InvalidScheduledEventIDFault:
		return (void*)soap_instantiate__ns1__InvalidScheduledEventIDFault(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__ScheduledEventAlreadyExistsFault:
		return (void*)soap_instantiate__ns1__ScheduledEventAlreadyExistsFault(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__ChangeVirtualInputState:
		return (void*)soap_instantiate__ns1__ChangeVirtualInputState(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__ChangeVirtualInputStateResponse:
		return (void*)soap_instantiate__ns1__ChangeVirtualInputStateResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__Documentation:
		return (void*)soap_instantiate_ns2__Documentation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ExtensibleDocumented:
		return (void*)soap_instantiate_ns2__ExtensibleDocumented(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__QueryExpressionType:
		return (void*)soap_instantiate_ns2__QueryExpressionType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__QueryExpressionType:
		return (void*)soap_instantiate_ns3__QueryExpressionType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__TopicExpressionType:
		return (void*)soap_instantiate_ns3__TopicExpressionType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__FilterType:
		return (void*)soap_instantiate_ns3__FilterType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__SubscriptionPolicyType:
		return (void*)soap_instantiate_ns3__SubscriptionPolicyType(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__NotificationMessageHolderType_Message:
		return (void*)soap_instantiate__ns3__NotificationMessageHolderType_Message(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__NotificationMessageHolderType:
		return (void*)soap_instantiate_ns3__NotificationMessageHolderType(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__NotificationProducerRP:
		return (void*)soap_instantiate__ns3__NotificationProducerRP(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__SubscriptionManagerRP:
		return (void*)soap_instantiate__ns3__SubscriptionManagerRP(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__Notify:
		return (void*)soap_instantiate__ns3__Notify(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__UseRaw:
		return (void*)soap_instantiate__ns3__UseRaw(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__Subscribe_SubscriptionPolicy:
		return (void*)soap_instantiate__ns3__Subscribe_SubscriptionPolicy(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__Subscribe:
		return (void*)soap_instantiate__ns3__Subscribe(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__SubscribeResponse:
		return (void*)soap_instantiate__ns3__SubscribeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__GetCurrentMessage:
		return (void*)soap_instantiate__ns3__GetCurrentMessage(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__GetCurrentMessageResponse:
		return (void*)soap_instantiate__ns3__GetCurrentMessageResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__GetMessages:
		return (void*)soap_instantiate__ns3__GetMessages(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__GetMessagesResponse:
		return (void*)soap_instantiate__ns3__GetMessagesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__DestroyPullPoint:
		return (void*)soap_instantiate__ns3__DestroyPullPoint(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__DestroyPullPointResponse:
		return (void*)soap_instantiate__ns3__DestroyPullPointResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__CreatePullPoint:
		return (void*)soap_instantiate__ns3__CreatePullPoint(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__CreatePullPointResponse:
		return (void*)soap_instantiate__ns3__CreatePullPointResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__Renew:
		return (void*)soap_instantiate__ns3__Renew(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__RenewResponse:
		return (void*)soap_instantiate__ns3__RenewResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__Unsubscribe:
		return (void*)soap_instantiate__ns3__Unsubscribe(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__UnsubscribeResponse:
		return (void*)soap_instantiate__ns3__UnsubscribeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__PauseSubscription:
		return (void*)soap_instantiate__ns3__PauseSubscription(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__PauseSubscriptionResponse:
		return (void*)soap_instantiate__ns3__PauseSubscriptionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__ResumeSubscription:
		return (void*)soap_instantiate__ns3__ResumeSubscription(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__ResumeSubscriptionResponse:
		return (void*)soap_instantiate__ns3__ResumeSubscriptionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns4__BaseFaultType_ErrorCode:
		return (void*)soap_instantiate__ns4__BaseFaultType_ErrorCode(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns4__BaseFaultType_Description:
		return (void*)soap_instantiate__ns4__BaseFaultType_Description(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns4__BaseFaultType_FaultCause:
		return (void*)soap_instantiate__ns4__BaseFaultType_FaultCause(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__BaseFaultType:
		return (void*)soap_instantiate_ns4__BaseFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__NewActionRule:
		return (void*)soap_instantiate_ns5__NewActionRule(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__Conditions:
		return (void*)soap_instantiate_ns5__Conditions(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__ActionRules:
		return (void*)soap_instantiate_ns5__ActionRules(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__ActionRule:
		return (void*)soap_instantiate_ns5__ActionRule(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__NewRecipientConfiguration:
		return (void*)soap_instantiate_ns5__NewRecipientConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__RecipientConfiguration:
		return (void*)soap_instantiate_ns5__RecipientConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__RecipientConfigurations:
		return (void*)soap_instantiate_ns5__RecipientConfigurations(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__RecipientTemplates:
		return (void*)soap_instantiate_ns5__RecipientTemplates(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__RecipientTemplate:
		return (void*)soap_instantiate_ns5__RecipientTemplate(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__ActionConfigurations:
		return (void*)soap_instantiate_ns5__ActionConfigurations(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__NewActionConfiguration:
		return (void*)soap_instantiate_ns5__NewActionConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__ActionConfiguration:
		return (void*)soap_instantiate_ns5__ActionConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__ActionParameters:
		return (void*)soap_instantiate_ns5__ActionParameters(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__ActionTemplates:
		return (void*)soap_instantiate_ns5__ActionTemplates(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__ActionParameter:
		return (void*)soap_instantiate_ns5__ActionParameter(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__ActionTemplate:
		return (void*)soap_instantiate_ns5__ActionTemplate(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__ActionTemplateParameters:
		return (void*)soap_instantiate_ns5__ActionTemplateParameters(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__ActionTemplateParameter:
		return (void*)soap_instantiate_ns5__ActionTemplateParameter(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__UsedByActionConfigurations:
		return (void*)soap_instantiate_ns5__UsedByActionConfigurations(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__UsedActionConfiguration:
		return (void*)soap_instantiate_ns5__UsedActionConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__UsedByActionRules:
		return (void*)soap_instantiate_ns5__UsedByActionRules(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__UsedActionRule:
		return (void*)soap_instantiate_ns5__UsedActionRule(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns5__GetActionTemplates:
		return (void*)soap_instantiate__ns5__GetActionTemplates(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns5__GetActionTemplatesResponse:
		return (void*)soap_instantiate__ns5__GetActionTemplatesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns5__AddActionConfiguration:
		return (void*)soap_instantiate__ns5__AddActionConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns5__AddActionConfigurationResponse:
		return (void*)soap_instantiate__ns5__AddActionConfigurationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns5__RemoveActionConfiguration:
		return (void*)soap_instantiate__ns5__RemoveActionConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns5__RemoveActionConfigurationResponse:
		return (void*)soap_instantiate__ns5__RemoveActionConfigurationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns5__GetActionConfigurations:
		return (void*)soap_instantiate__ns5__GetActionConfigurations(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns5__GetActionConfigurationsResponse:
		return (void*)soap_instantiate__ns5__GetActionConfigurationsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns5__GetRecipientTemplates:
		return (void*)soap_instantiate__ns5__GetRecipientTemplates(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns5__GetRecipientTemplatesResponse:
		return (void*)soap_instantiate__ns5__GetRecipientTemplatesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns5__AddRecipientConfiguration:
		return (void*)soap_instantiate__ns5__AddRecipientConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns5__AddRecipientConfigurationResponse:
		return (void*)soap_instantiate__ns5__AddRecipientConfigurationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns5__RemoveRecipientConfiguration:
		return (void*)soap_instantiate__ns5__RemoveRecipientConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns5__RemoveRecipientConfigurationResponse:
		return (void*)soap_instantiate__ns5__RemoveRecipientConfigurationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns5__GetRecipientConfigurations:
		return (void*)soap_instantiate__ns5__GetRecipientConfigurations(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns5__GetRecipientConfigurationsResponse:
		return (void*)soap_instantiate__ns5__GetRecipientConfigurationsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns5__AddActionRule:
		return (void*)soap_instantiate__ns5__AddActionRule(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns5__AddActionRuleResponse:
		return (void*)soap_instantiate__ns5__AddActionRuleResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns5__GetActionRules:
		return (void*)soap_instantiate__ns5__GetActionRules(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns5__GetActionRulesResponse:
		return (void*)soap_instantiate__ns5__GetActionRulesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns5__RemoveActionRule:
		return (void*)soap_instantiate__ns5__RemoveActionRule(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns5__RemoveActionRuleResponse:
		return (void*)soap_instantiate__ns5__RemoveActionRuleResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns5__ActionTemplateNotFoundFault:
		return (void*)soap_instantiate__ns5__ActionTemplateNotFoundFault(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns5__RecipientConfigurationNotFoundFault:
		return (void*)soap_instantiate__ns5__RecipientConfigurationNotFoundFault(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns5__ParametersMissmatchFault:
		return (void*)soap_instantiate__ns5__ParametersMissmatchFault(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns5__InvalidActionConfigurationFault:
		return (void*)soap_instantiate__ns5__InvalidActionConfigurationFault(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns5__ActionConfigurationNotFoundFault:
		return (void*)soap_instantiate__ns5__ActionConfigurationNotFoundFault(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns5__RecipientTemplateNotFoundFault:
		return (void*)soap_instantiate__ns5__RecipientTemplateNotFoundFault(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns5__ActionConfigurationIsInUseFault:
		return (void*)soap_instantiate__ns5__ActionConfigurationIsInUseFault(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns5__InvalidConditionFilterFault:
		return (void*)soap_instantiate__ns5__InvalidConditionFilterFault(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns5__InsufficientActivationRuleFault:
		return (void*)soap_instantiate__ns5__InsufficientActivationRuleFault(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns5__ActionRuleNotFoundFault:
		return (void*)soap_instantiate__ns5__ActionRuleNotFoundFault(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns5__InvalidActivationTimeoutFault:
		return (void*)soap_instantiate__ns5__InvalidActivationTimeoutFault(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__EndpointReferenceType:
		return (void*)soap_instantiate_ns6__EndpointReferenceType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__ReferenceParametersType:
		return (void*)soap_instantiate_ns6__ReferenceParametersType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__MetadataType:
		return (void*)soap_instantiate_ns6__MetadataType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__ProblemActionType:
		return (void*)soap_instantiate_ns6__ProblemActionType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ICalendar:
		return (void*)soap_instantiate_ns1__ICalendar(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__TopicNamespaceType_Topic:
		return (void*)soap_instantiate__ns2__TopicNamespaceType_Topic(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__TopicNamespaceType:
		return (void*)soap_instantiate_ns2__TopicNamespaceType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__TopicType:
		return (void*)soap_instantiate_ns2__TopicType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__TopicSetType:
		return (void*)soap_instantiate_ns2__TopicSetType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__SubscribeCreationFailedFaultType:
		return (void*)soap_instantiate_ns3__SubscribeCreationFailedFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__InvalidFilterFaultType:
		return (void*)soap_instantiate_ns3__InvalidFilterFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__TopicExpressionDialectUnknownFaultType:
		return (void*)soap_instantiate_ns3__TopicExpressionDialectUnknownFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__InvalidTopicExpressionFaultType:
		return (void*)soap_instantiate_ns3__InvalidTopicExpressionFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__TopicNotSupportedFaultType:
		return (void*)soap_instantiate_ns3__TopicNotSupportedFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__MultipleTopicsSpecifiedFaultType:
		return (void*)soap_instantiate_ns3__MultipleTopicsSpecifiedFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__InvalidProducerPropertiesExpressionFaultType:
		return (void*)soap_instantiate_ns3__InvalidProducerPropertiesExpressionFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__InvalidMessageContentExpressionFaultType:
		return (void*)soap_instantiate_ns3__InvalidMessageContentExpressionFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__UnrecognizedPolicyRequestFaultType:
		return (void*)soap_instantiate_ns3__UnrecognizedPolicyRequestFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__UnsupportedPolicyRequestFaultType:
		return (void*)soap_instantiate_ns3__UnsupportedPolicyRequestFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__NotifyMessageNotSupportedFaultType:
		return (void*)soap_instantiate_ns3__NotifyMessageNotSupportedFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__UnacceptableInitialTerminationTimeFaultType:
		return (void*)soap_instantiate_ns3__UnacceptableInitialTerminationTimeFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__NoCurrentMessageOnTopicFaultType:
		return (void*)soap_instantiate_ns3__NoCurrentMessageOnTopicFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__UnableToGetMessagesFaultType:
		return (void*)soap_instantiate_ns3__UnableToGetMessagesFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__UnableToDestroyPullPointFaultType:
		return (void*)soap_instantiate_ns3__UnableToDestroyPullPointFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__UnableToCreatePullPointFaultType:
		return (void*)soap_instantiate_ns3__UnableToCreatePullPointFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__UnacceptableTerminationTimeFaultType:
		return (void*)soap_instantiate_ns3__UnacceptableTerminationTimeFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__UnableToDestroySubscriptionFaultType:
		return (void*)soap_instantiate_ns3__UnableToDestroySubscriptionFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__PauseFailedFaultType:
		return (void*)soap_instantiate_ns3__PauseFailedFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__ResumeFailedFaultType:
		return (void*)soap_instantiate_ns3__ResumeFailedFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__RelatesToType:
		return (void*)soap_instantiate_ns6__RelatesToType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__AttributedURIType:
		return (void*)soap_instantiate_ns6__AttributedURIType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__AttributedUnsignedLongType:
		return (void*)soap_instantiate_ns6__AttributedUnsignedLongType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__AttributedQNameType:
		return (void*)soap_instantiate_ns6__AttributedQNameType(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE___ns1__GetEventInstances:
		return (void*)soap_instantiate___ns1__GetEventInstances(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__AddScheduledEvent:
		return (void*)soap_instantiate___ns1__AddScheduledEvent(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__RemoveScheduledEvent:
		return (void*)soap_instantiate___ns1__RemoveScheduledEvent(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetScheduledEvents:
		return (void*)soap_instantiate___ns1__GetScheduledEvents(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__ChangeVirtualInputState:
		return (void*)soap_instantiate___ns1__ChangeVirtualInputState(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns5__GetActionTemplates:
		return (void*)soap_instantiate___ns5__GetActionTemplates(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns5__AddActionConfiguration:
		return (void*)soap_instantiate___ns5__AddActionConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns5__RemoveActionConfiguration:
		return (void*)soap_instantiate___ns5__RemoveActionConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns5__GetActionConfigurations:
		return (void*)soap_instantiate___ns5__GetActionConfigurations(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns5__GetRecipientTemplates:
		return (void*)soap_instantiate___ns5__GetRecipientTemplates(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns5__AddRecipientConfiguration:
		return (void*)soap_instantiate___ns5__AddRecipientConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns5__RemoveRecipientConfiguration:
		return (void*)soap_instantiate___ns5__RemoveRecipientConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns5__GetRecipientConfigurations:
		return (void*)soap_instantiate___ns5__GetRecipientConfigurations(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns5__AddActionRule:
		return (void*)soap_instantiate___ns5__AddActionRule(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns5__GetActionRules:
		return (void*)soap_instantiate___ns5__GetActionRules(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns5__RemoveActionRule:
		return (void*)soap_instantiate___ns5__RemoveActionRule(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_xsd__anyType:
		return (void*)soap_instantiate_xsd__anyType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__anyAttribute:
		return (void*)soap_instantiate_xsd__anyAttribute(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__QName:
		return (void*)soap_instantiate_xsd__QName(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__NCName:
		return (void*)soap_instantiate_xsd__NCName(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__anyURI:
		return (void*)soap_instantiate_xsd__anyURI(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__duration:
		return (void*)soap_instantiate_xsd__duration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__integer:
		return (void*)soap_instantiate_xsd__integer(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__nonNegativeInteger:
		return (void*)soap_instantiate_xsd__nonNegativeInteger(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__token:
		return (void*)soap_instantiate_xsd__token(soap, -1, type, arrayType, n);
	case SOAP_TYPE__xml__lang:
		return (void*)soap_instantiate__xml__lang(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__AbsoluteOrRelativeTimeType:
		return (void*)soap_instantiate_ns3__AbsoluteOrRelativeTimeType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__RelationshipTypeOpenEnum:
		return (void*)soap_instantiate_ns6__RelationshipTypeOpenEnum(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__FaultCodesOpenEnumType:
		return (void*)soap_instantiate_ns6__FaultCodesOpenEnumType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__FullTopicExpression:
		return (void*)soap_instantiate_ns2__FullTopicExpression(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ConcreteTopicExpression:
		return (void*)soap_instantiate_ns2__ConcreteTopicExpression(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__SimpleTopicExpression:
		return (void*)soap_instantiate_ns2__SimpleTopicExpression(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfxsd__QName:
		return (void*)soap_instantiate_std__vectorTemplateOfxsd__QName(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOf_ns2__TopicNamespaceType_Topic:
		return (void*)soap_instantiate_std__vectorTemplateOf_ns2__TopicNamespaceType_Topic(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__TopicType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__TopicType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons5__UsedActionRule:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons5__UsedActionRule(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons5__UsedActionConfiguration:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons5__UsedActionConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons5__ActionTemplateParameter:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons5__ActionTemplateParameter(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons5__ActionTemplate:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons5__ActionTemplate(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons5__ActionParameter:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons5__ActionParameter(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons5__ActionConfiguration:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons5__ActionConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons5__RecipientTemplate:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons5__RecipientTemplate(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons5__RecipientConfiguration:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons5__RecipientConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons5__ActionRule:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons5__ActionRule(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons3__FilterType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons3__FilterType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOf_ns4__BaseFaultType_Description:
		return (void*)soap_instantiate_std__vectorTemplateOf_ns4__BaseFaultType_Description(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons3__NotificationMessageHolderType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons3__NotificationMessageHolderType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfxsd__anyURI:
		return (void*)soap_instantiate_std__vectorTemplateOfxsd__anyURI(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons3__TopicExpressionType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons3__TopicExpressionType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfxsd__anyType:
		return (void*)soap_instantiate_std__vectorTemplateOfxsd__anyType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__ScheduledEvent:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__ScheduledEvent(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_std__string:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::string*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::string*>(p->ptr));
		break;
	case SOAP_TYPE_xsd__NCName_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<xsd__NCName_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<xsd__NCName_*>(p->ptr));
		break;
	case SOAP_TYPE_xsd__QName_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<xsd__QName_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<xsd__QName_*>(p->ptr));
		break;
	case SOAP_TYPE_xsd__anyURI_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<xsd__anyURI_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<xsd__anyURI_*>(p->ptr));
		break;
	case SOAP_TYPE_xsd__boolean:
		if (p->size < 0)
			SOAP_DELETE(static_cast<xsd__boolean*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<xsd__boolean*>(p->ptr));
		break;
	case SOAP_TYPE_xsd__dateTime:
		if (p->size < 0)
			SOAP_DELETE(static_cast<xsd__dateTime*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<xsd__dateTime*>(p->ptr));
		break;
	case SOAP_TYPE_xsd__duration_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<xsd__duration_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<xsd__duration_*>(p->ptr));
		break;
	case SOAP_TYPE_xsd__int:
		if (p->size < 0)
			SOAP_DELETE(static_cast<xsd__int*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<xsd__int*>(p->ptr));
		break;
	case SOAP_TYPE_xsd__integer_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<xsd__integer_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<xsd__integer_*>(p->ptr));
		break;
	case SOAP_TYPE_xsd__nonNegativeInteger_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<xsd__nonNegativeInteger_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<xsd__nonNegativeInteger_*>(p->ptr));
		break;
	case SOAP_TYPE_xsd__string:
		if (p->size < 0)
			SOAP_DELETE(static_cast<xsd__string*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<xsd__string*>(p->ptr));
		break;
	case SOAP_TYPE_xsd__token_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<xsd__token_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<xsd__token_*>(p->ptr));
		break;
	case SOAP_TYPE_xsd__unsignedLong:
		if (p->size < 0)
			SOAP_DELETE(static_cast<xsd__unsignedLong*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<xsd__unsignedLong*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__ScheduledType__:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__ScheduledType__*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__ScheduledType__*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__FullTopicExpression__:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__FullTopicExpression__*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__FullTopicExpression__*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__ConcreteTopicExpression__:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__ConcreteTopicExpression__*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__ConcreteTopicExpression__*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__SimpleTopicExpression__:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__SimpleTopicExpression__*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__SimpleTopicExpression__*>(p->ptr));
		break;
	case SOAP_TYPE_ns6__RelationshipType__:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns6__RelationshipType__*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns6__RelationshipType__*>(p->ptr));
		break;
	case SOAP_TYPE_ns6__FaultCodesType__:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns6__FaultCodesType__*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns6__FaultCodesType__*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__NewScheduledEvent:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__NewScheduledEvent*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__NewScheduledEvent*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__ScheduledEvents:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__ScheduledEvents*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__ScheduledEvents*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__ScheduledEvent:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__ScheduledEvent*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__ScheduledEvent*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__Schedule:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__Schedule*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__Schedule*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__ScheduleFilter:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__ScheduleFilter*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__ScheduleFilter*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetEventInstances:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetEventInstances*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetEventInstances*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetEventInstancesResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetEventInstancesResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetEventInstancesResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__AddScheduledEvent:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__AddScheduledEvent*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__AddScheduledEvent*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__AddScheduledEventResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__AddScheduledEventResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__AddScheduledEventResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__RemoveScheduledEvent:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__RemoveScheduledEvent*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__RemoveScheduledEvent*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__RemoveScheduledEventResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__RemoveScheduledEventResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__RemoveScheduledEventResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetScheduledEvents:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetScheduledEvents*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetScheduledEvents*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetScheduledEventsResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetScheduledEventsResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetScheduledEventsResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__ScheduledEventNotFoundFault:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__ScheduledEventNotFoundFault*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__ScheduledEventNotFoundFault*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__InvalidScheduleFault:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__InvalidScheduleFault*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__InvalidScheduleFault*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__InvalidScheduledEventIDFault:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__InvalidScheduledEventIDFault*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__InvalidScheduledEventIDFault*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__ScheduledEventAlreadyExistsFault:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__ScheduledEventAlreadyExistsFault*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__ScheduledEventAlreadyExistsFault*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__ChangeVirtualInputState:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__ChangeVirtualInputState*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__ChangeVirtualInputState*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__ChangeVirtualInputStateResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__ChangeVirtualInputStateResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__ChangeVirtualInputStateResponse*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__Documentation:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__Documentation*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__Documentation*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__ExtensibleDocumented:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__ExtensibleDocumented*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__ExtensibleDocumented*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__QueryExpressionType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__QueryExpressionType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__QueryExpressionType*>(p->ptr));
		break;
	case SOAP_TYPE_ns3__QueryExpressionType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns3__QueryExpressionType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns3__QueryExpressionType*>(p->ptr));
		break;
	case SOAP_TYPE_ns3__TopicExpressionType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns3__TopicExpressionType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns3__TopicExpressionType*>(p->ptr));
		break;
	case SOAP_TYPE_ns3__FilterType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns3__FilterType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns3__FilterType*>(p->ptr));
		break;
	case SOAP_TYPE_ns3__SubscriptionPolicyType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns3__SubscriptionPolicyType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns3__SubscriptionPolicyType*>(p->ptr));
		break;
	case SOAP_TYPE__ns3__NotificationMessageHolderType_Message:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns3__NotificationMessageHolderType_Message*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns3__NotificationMessageHolderType_Message*>(p->ptr));
		break;
	case SOAP_TYPE_ns3__NotificationMessageHolderType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns3__NotificationMessageHolderType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns3__NotificationMessageHolderType*>(p->ptr));
		break;
	case SOAP_TYPE__ns3__NotificationProducerRP:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns3__NotificationProducerRP*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns3__NotificationProducerRP*>(p->ptr));
		break;
	case SOAP_TYPE__ns3__SubscriptionManagerRP:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns3__SubscriptionManagerRP*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns3__SubscriptionManagerRP*>(p->ptr));
		break;
	case SOAP_TYPE__ns3__Notify:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns3__Notify*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns3__Notify*>(p->ptr));
		break;
	case SOAP_TYPE__ns3__UseRaw:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns3__UseRaw*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns3__UseRaw*>(p->ptr));
		break;
	case SOAP_TYPE__ns3__Subscribe_SubscriptionPolicy:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns3__Subscribe_SubscriptionPolicy*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns3__Subscribe_SubscriptionPolicy*>(p->ptr));
		break;
	case SOAP_TYPE__ns3__Subscribe:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns3__Subscribe*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns3__Subscribe*>(p->ptr));
		break;
	case SOAP_TYPE__ns3__SubscribeResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns3__SubscribeResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns3__SubscribeResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns3__GetCurrentMessage:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns3__GetCurrentMessage*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns3__GetCurrentMessage*>(p->ptr));
		break;
	case SOAP_TYPE__ns3__GetCurrentMessageResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns3__GetCurrentMessageResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns3__GetCurrentMessageResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns3__GetMessages:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns3__GetMessages*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns3__GetMessages*>(p->ptr));
		break;
	case SOAP_TYPE__ns3__GetMessagesResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns3__GetMessagesResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns3__GetMessagesResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns3__DestroyPullPoint:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns3__DestroyPullPoint*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns3__DestroyPullPoint*>(p->ptr));
		break;
	case SOAP_TYPE__ns3__DestroyPullPointResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns3__DestroyPullPointResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns3__DestroyPullPointResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns3__CreatePullPoint:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns3__CreatePullPoint*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns3__CreatePullPoint*>(p->ptr));
		break;
	case SOAP_TYPE__ns3__CreatePullPointResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns3__CreatePullPointResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns3__CreatePullPointResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns3__Renew:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns3__Renew*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns3__Renew*>(p->ptr));
		break;
	case SOAP_TYPE__ns3__RenewResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns3__RenewResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns3__RenewResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns3__Unsubscribe:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns3__Unsubscribe*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns3__Unsubscribe*>(p->ptr));
		break;
	case SOAP_TYPE__ns3__UnsubscribeResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns3__UnsubscribeResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns3__UnsubscribeResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns3__PauseSubscription:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns3__PauseSubscription*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns3__PauseSubscription*>(p->ptr));
		break;
	case SOAP_TYPE__ns3__PauseSubscriptionResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns3__PauseSubscriptionResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns3__PauseSubscriptionResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns3__ResumeSubscription:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns3__ResumeSubscription*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns3__ResumeSubscription*>(p->ptr));
		break;
	case SOAP_TYPE__ns3__ResumeSubscriptionResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns3__ResumeSubscriptionResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns3__ResumeSubscriptionResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns4__BaseFaultType_ErrorCode:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns4__BaseFaultType_ErrorCode*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns4__BaseFaultType_ErrorCode*>(p->ptr));
		break;
	case SOAP_TYPE__ns4__BaseFaultType_Description:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns4__BaseFaultType_Description*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns4__BaseFaultType_Description*>(p->ptr));
		break;
	case SOAP_TYPE__ns4__BaseFaultType_FaultCause:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns4__BaseFaultType_FaultCause*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns4__BaseFaultType_FaultCause*>(p->ptr));
		break;
	case SOAP_TYPE_ns4__BaseFaultType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns4__BaseFaultType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns4__BaseFaultType*>(p->ptr));
		break;
	case SOAP_TYPE_ns5__NewActionRule:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns5__NewActionRule*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns5__NewActionRule*>(p->ptr));
		break;
	case SOAP_TYPE_ns5__Conditions:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns5__Conditions*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns5__Conditions*>(p->ptr));
		break;
	case SOAP_TYPE_ns5__ActionRules:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns5__ActionRules*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns5__ActionRules*>(p->ptr));
		break;
	case SOAP_TYPE_ns5__ActionRule:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns5__ActionRule*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns5__ActionRule*>(p->ptr));
		break;
	case SOAP_TYPE_ns5__NewRecipientConfiguration:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns5__NewRecipientConfiguration*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns5__NewRecipientConfiguration*>(p->ptr));
		break;
	case SOAP_TYPE_ns5__RecipientConfiguration:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns5__RecipientConfiguration*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns5__RecipientConfiguration*>(p->ptr));
		break;
	case SOAP_TYPE_ns5__RecipientConfigurations:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns5__RecipientConfigurations*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns5__RecipientConfigurations*>(p->ptr));
		break;
	case SOAP_TYPE_ns5__RecipientTemplates:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns5__RecipientTemplates*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns5__RecipientTemplates*>(p->ptr));
		break;
	case SOAP_TYPE_ns5__RecipientTemplate:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns5__RecipientTemplate*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns5__RecipientTemplate*>(p->ptr));
		break;
	case SOAP_TYPE_ns5__ActionConfigurations:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns5__ActionConfigurations*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns5__ActionConfigurations*>(p->ptr));
		break;
	case SOAP_TYPE_ns5__NewActionConfiguration:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns5__NewActionConfiguration*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns5__NewActionConfiguration*>(p->ptr));
		break;
	case SOAP_TYPE_ns5__ActionConfiguration:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns5__ActionConfiguration*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns5__ActionConfiguration*>(p->ptr));
		break;
	case SOAP_TYPE_ns5__ActionParameters:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns5__ActionParameters*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns5__ActionParameters*>(p->ptr));
		break;
	case SOAP_TYPE_ns5__ActionTemplates:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns5__ActionTemplates*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns5__ActionTemplates*>(p->ptr));
		break;
	case SOAP_TYPE_ns5__ActionParameter:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns5__ActionParameter*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns5__ActionParameter*>(p->ptr));
		break;
	case SOAP_TYPE_ns5__ActionTemplate:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns5__ActionTemplate*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns5__ActionTemplate*>(p->ptr));
		break;
	case SOAP_TYPE_ns5__ActionTemplateParameters:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns5__ActionTemplateParameters*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns5__ActionTemplateParameters*>(p->ptr));
		break;
	case SOAP_TYPE_ns5__ActionTemplateParameter:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns5__ActionTemplateParameter*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns5__ActionTemplateParameter*>(p->ptr));
		break;
	case SOAP_TYPE_ns5__UsedByActionConfigurations:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns5__UsedByActionConfigurations*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns5__UsedByActionConfigurations*>(p->ptr));
		break;
	case SOAP_TYPE_ns5__UsedActionConfiguration:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns5__UsedActionConfiguration*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns5__UsedActionConfiguration*>(p->ptr));
		break;
	case SOAP_TYPE_ns5__UsedByActionRules:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns5__UsedByActionRules*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns5__UsedByActionRules*>(p->ptr));
		break;
	case SOAP_TYPE_ns5__UsedActionRule:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns5__UsedActionRule*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns5__UsedActionRule*>(p->ptr));
		break;
	case SOAP_TYPE__ns5__GetActionTemplates:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns5__GetActionTemplates*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns5__GetActionTemplates*>(p->ptr));
		break;
	case SOAP_TYPE__ns5__GetActionTemplatesResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns5__GetActionTemplatesResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns5__GetActionTemplatesResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns5__AddActionConfiguration:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns5__AddActionConfiguration*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns5__AddActionConfiguration*>(p->ptr));
		break;
	case SOAP_TYPE__ns5__AddActionConfigurationResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns5__AddActionConfigurationResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns5__AddActionConfigurationResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns5__RemoveActionConfiguration:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns5__RemoveActionConfiguration*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns5__RemoveActionConfiguration*>(p->ptr));
		break;
	case SOAP_TYPE__ns5__RemoveActionConfigurationResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns5__RemoveActionConfigurationResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns5__RemoveActionConfigurationResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns5__GetActionConfigurations:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns5__GetActionConfigurations*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns5__GetActionConfigurations*>(p->ptr));
		break;
	case SOAP_TYPE__ns5__GetActionConfigurationsResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns5__GetActionConfigurationsResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns5__GetActionConfigurationsResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns5__GetRecipientTemplates:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns5__GetRecipientTemplates*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns5__GetRecipientTemplates*>(p->ptr));
		break;
	case SOAP_TYPE__ns5__GetRecipientTemplatesResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns5__GetRecipientTemplatesResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns5__GetRecipientTemplatesResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns5__AddRecipientConfiguration:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns5__AddRecipientConfiguration*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns5__AddRecipientConfiguration*>(p->ptr));
		break;
	case SOAP_TYPE__ns5__AddRecipientConfigurationResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns5__AddRecipientConfigurationResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns5__AddRecipientConfigurationResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns5__RemoveRecipientConfiguration:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns5__RemoveRecipientConfiguration*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns5__RemoveRecipientConfiguration*>(p->ptr));
		break;
	case SOAP_TYPE__ns5__RemoveRecipientConfigurationResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns5__RemoveRecipientConfigurationResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns5__RemoveRecipientConfigurationResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns5__GetRecipientConfigurations:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns5__GetRecipientConfigurations*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns5__GetRecipientConfigurations*>(p->ptr));
		break;
	case SOAP_TYPE__ns5__GetRecipientConfigurationsResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns5__GetRecipientConfigurationsResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns5__GetRecipientConfigurationsResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns5__AddActionRule:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns5__AddActionRule*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns5__AddActionRule*>(p->ptr));
		break;
	case SOAP_TYPE__ns5__AddActionRuleResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns5__AddActionRuleResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns5__AddActionRuleResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns5__GetActionRules:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns5__GetActionRules*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns5__GetActionRules*>(p->ptr));
		break;
	case SOAP_TYPE__ns5__GetActionRulesResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns5__GetActionRulesResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns5__GetActionRulesResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns5__RemoveActionRule:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns5__RemoveActionRule*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns5__RemoveActionRule*>(p->ptr));
		break;
	case SOAP_TYPE__ns5__RemoveActionRuleResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns5__RemoveActionRuleResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns5__RemoveActionRuleResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns5__ActionTemplateNotFoundFault:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns5__ActionTemplateNotFoundFault*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns5__ActionTemplateNotFoundFault*>(p->ptr));
		break;
	case SOAP_TYPE__ns5__RecipientConfigurationNotFoundFault:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns5__RecipientConfigurationNotFoundFault*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns5__RecipientConfigurationNotFoundFault*>(p->ptr));
		break;
	case SOAP_TYPE__ns5__ParametersMissmatchFault:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns5__ParametersMissmatchFault*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns5__ParametersMissmatchFault*>(p->ptr));
		break;
	case SOAP_TYPE__ns5__InvalidActionConfigurationFault:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns5__InvalidActionConfigurationFault*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns5__InvalidActionConfigurationFault*>(p->ptr));
		break;
	case SOAP_TYPE__ns5__ActionConfigurationNotFoundFault:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns5__ActionConfigurationNotFoundFault*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns5__ActionConfigurationNotFoundFault*>(p->ptr));
		break;
	case SOAP_TYPE__ns5__RecipientTemplateNotFoundFault:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns5__RecipientTemplateNotFoundFault*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns5__RecipientTemplateNotFoundFault*>(p->ptr));
		break;
	case SOAP_TYPE__ns5__ActionConfigurationIsInUseFault:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns5__ActionConfigurationIsInUseFault*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns5__ActionConfigurationIsInUseFault*>(p->ptr));
		break;
	case SOAP_TYPE__ns5__InvalidConditionFilterFault:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns5__InvalidConditionFilterFault*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns5__InvalidConditionFilterFault*>(p->ptr));
		break;
	case SOAP_TYPE__ns5__InsufficientActivationRuleFault:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns5__InsufficientActivationRuleFault*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns5__InsufficientActivationRuleFault*>(p->ptr));
		break;
	case SOAP_TYPE__ns5__ActionRuleNotFoundFault:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns5__ActionRuleNotFoundFault*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns5__ActionRuleNotFoundFault*>(p->ptr));
		break;
	case SOAP_TYPE__ns5__InvalidActivationTimeoutFault:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns5__InvalidActivationTimeoutFault*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns5__InvalidActivationTimeoutFault*>(p->ptr));
		break;
	case SOAP_TYPE_ns6__EndpointReferenceType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns6__EndpointReferenceType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns6__EndpointReferenceType*>(p->ptr));
		break;
	case SOAP_TYPE_ns6__ReferenceParametersType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns6__ReferenceParametersType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns6__ReferenceParametersType*>(p->ptr));
		break;
	case SOAP_TYPE_ns6__MetadataType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns6__MetadataType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns6__MetadataType*>(p->ptr));
		break;
	case SOAP_TYPE_ns6__ProblemActionType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns6__ProblemActionType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns6__ProblemActionType*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__ICalendar:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__ICalendar*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__ICalendar*>(p->ptr));
		break;
	case SOAP_TYPE__ns2__TopicNamespaceType_Topic:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns2__TopicNamespaceType_Topic*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns2__TopicNamespaceType_Topic*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__TopicNamespaceType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__TopicNamespaceType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__TopicNamespaceType*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__TopicType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__TopicType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__TopicType*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__TopicSetType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__TopicSetType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__TopicSetType*>(p->ptr));
		break;
	case SOAP_TYPE_ns3__SubscribeCreationFailedFaultType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns3__SubscribeCreationFailedFaultType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns3__SubscribeCreationFailedFaultType*>(p->ptr));
		break;
	case SOAP_TYPE_ns3__InvalidFilterFaultType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns3__InvalidFilterFaultType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns3__InvalidFilterFaultType*>(p->ptr));
		break;
	case SOAP_TYPE_ns3__TopicExpressionDialectUnknownFaultType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns3__TopicExpressionDialectUnknownFaultType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns3__TopicExpressionDialectUnknownFaultType*>(p->ptr));
		break;
	case SOAP_TYPE_ns3__InvalidTopicExpressionFaultType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns3__InvalidTopicExpressionFaultType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns3__InvalidTopicExpressionFaultType*>(p->ptr));
		break;
	case SOAP_TYPE_ns3__TopicNotSupportedFaultType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns3__TopicNotSupportedFaultType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns3__TopicNotSupportedFaultType*>(p->ptr));
		break;
	case SOAP_TYPE_ns3__MultipleTopicsSpecifiedFaultType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns3__MultipleTopicsSpecifiedFaultType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns3__MultipleTopicsSpecifiedFaultType*>(p->ptr));
		break;
	case SOAP_TYPE_ns3__InvalidProducerPropertiesExpressionFaultType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns3__InvalidProducerPropertiesExpressionFaultType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns3__InvalidProducerPropertiesExpressionFaultType*>(p->ptr));
		break;
	case SOAP_TYPE_ns3__InvalidMessageContentExpressionFaultType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns3__InvalidMessageContentExpressionFaultType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns3__InvalidMessageContentExpressionFaultType*>(p->ptr));
		break;
	case SOAP_TYPE_ns3__UnrecognizedPolicyRequestFaultType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns3__UnrecognizedPolicyRequestFaultType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns3__UnrecognizedPolicyRequestFaultType*>(p->ptr));
		break;
	case SOAP_TYPE_ns3__UnsupportedPolicyRequestFaultType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns3__UnsupportedPolicyRequestFaultType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns3__UnsupportedPolicyRequestFaultType*>(p->ptr));
		break;
	case SOAP_TYPE_ns3__NotifyMessageNotSupportedFaultType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns3__NotifyMessageNotSupportedFaultType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns3__NotifyMessageNotSupportedFaultType*>(p->ptr));
		break;
	case SOAP_TYPE_ns3__UnacceptableInitialTerminationTimeFaultType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns3__UnacceptableInitialTerminationTimeFaultType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns3__UnacceptableInitialTerminationTimeFaultType*>(p->ptr));
		break;
	case SOAP_TYPE_ns3__NoCurrentMessageOnTopicFaultType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns3__NoCurrentMessageOnTopicFaultType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns3__NoCurrentMessageOnTopicFaultType*>(p->ptr));
		break;
	case SOAP_TYPE_ns3__UnableToGetMessagesFaultType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns3__UnableToGetMessagesFaultType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns3__UnableToGetMessagesFaultType*>(p->ptr));
		break;
	case SOAP_TYPE_ns3__UnableToDestroyPullPointFaultType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns3__UnableToDestroyPullPointFaultType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns3__UnableToDestroyPullPointFaultType*>(p->ptr));
		break;
	case SOAP_TYPE_ns3__UnableToCreatePullPointFaultType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns3__UnableToCreatePullPointFaultType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns3__UnableToCreatePullPointFaultType*>(p->ptr));
		break;
	case SOAP_TYPE_ns3__UnacceptableTerminationTimeFaultType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns3__UnacceptableTerminationTimeFaultType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns3__UnacceptableTerminationTimeFaultType*>(p->ptr));
		break;
	case SOAP_TYPE_ns3__UnableToDestroySubscriptionFaultType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns3__UnableToDestroySubscriptionFaultType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns3__UnableToDestroySubscriptionFaultType*>(p->ptr));
		break;
	case SOAP_TYPE_ns3__PauseFailedFaultType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns3__PauseFailedFaultType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns3__PauseFailedFaultType*>(p->ptr));
		break;
	case SOAP_TYPE_ns3__ResumeFailedFaultType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns3__ResumeFailedFaultType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns3__ResumeFailedFaultType*>(p->ptr));
		break;
	case SOAP_TYPE_ns6__RelatesToType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns6__RelatesToType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns6__RelatesToType*>(p->ptr));
		break;
	case SOAP_TYPE_ns6__AttributedURIType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns6__AttributedURIType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns6__AttributedURIType*>(p->ptr));
		break;
	case SOAP_TYPE_ns6__AttributedUnsignedLongType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns6__AttributedUnsignedLongType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns6__AttributedUnsignedLongType*>(p->ptr));
		break;
	case SOAP_TYPE_ns6__AttributedQNameType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns6__AttributedQNameType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns6__AttributedQNameType*>(p->ptr));
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Detail*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Detail*>(p->ptr));
		break;
#endif
	case SOAP_TYPE___ns1__GetEventInstances:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__GetEventInstances*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__GetEventInstances*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__AddScheduledEvent:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__AddScheduledEvent*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__AddScheduledEvent*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__RemoveScheduledEvent:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__RemoveScheduledEvent*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__RemoveScheduledEvent*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__GetScheduledEvents:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__GetScheduledEvents*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__GetScheduledEvents*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__ChangeVirtualInputState:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__ChangeVirtualInputState*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__ChangeVirtualInputState*>(p->ptr));
		break;
	case SOAP_TYPE___ns5__GetActionTemplates:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns5__GetActionTemplates*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns5__GetActionTemplates*>(p->ptr));
		break;
	case SOAP_TYPE___ns5__AddActionConfiguration:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns5__AddActionConfiguration*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns5__AddActionConfiguration*>(p->ptr));
		break;
	case SOAP_TYPE___ns5__RemoveActionConfiguration:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns5__RemoveActionConfiguration*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns5__RemoveActionConfiguration*>(p->ptr));
		break;
	case SOAP_TYPE___ns5__GetActionConfigurations:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns5__GetActionConfigurations*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns5__GetActionConfigurations*>(p->ptr));
		break;
	case SOAP_TYPE___ns5__GetRecipientTemplates:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns5__GetRecipientTemplates*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns5__GetRecipientTemplates*>(p->ptr));
		break;
	case SOAP_TYPE___ns5__AddRecipientConfiguration:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns5__AddRecipientConfiguration*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns5__AddRecipientConfiguration*>(p->ptr));
		break;
	case SOAP_TYPE___ns5__RemoveRecipientConfiguration:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns5__RemoveRecipientConfiguration*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns5__RemoveRecipientConfiguration*>(p->ptr));
		break;
	case SOAP_TYPE___ns5__GetRecipientConfigurations:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns5__GetRecipientConfigurations*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns5__GetRecipientConfigurations*>(p->ptr));
		break;
	case SOAP_TYPE___ns5__AddActionRule:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns5__AddActionRule*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns5__AddActionRule*>(p->ptr));
		break;
	case SOAP_TYPE___ns5__GetActionRules:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns5__GetActionRules*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns5__GetActionRules*>(p->ptr));
		break;
	case SOAP_TYPE___ns5__RemoveActionRule:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns5__RemoveActionRule*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns5__RemoveActionRule*>(p->ptr));
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Header*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Header*>(p->ptr));
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Code*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Code*>(p->ptr));
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Reason*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Reason*>(p->ptr));
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Fault*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Fault*>(p->ptr));
		break;
#endif
	case SOAP_TYPE_xsd__anyType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct soap_dom_element*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct soap_dom_element*>(p->ptr));
		break;
	case SOAP_TYPE_xsd__anyAttribute:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct soap_dom_attribute*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct soap_dom_attribute*>(p->ptr));
		break;
	case SOAP_TYPE_xsd__QName:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::string*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::string*>(p->ptr));
		break;
	case SOAP_TYPE_xsd__NCName:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::string*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::string*>(p->ptr));
		break;
	case SOAP_TYPE_xsd__anyURI:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::string*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::string*>(p->ptr));
		break;
	case SOAP_TYPE_xsd__duration:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::string*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::string*>(p->ptr));
		break;
	case SOAP_TYPE_xsd__integer:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::string*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::string*>(p->ptr));
		break;
	case SOAP_TYPE_xsd__nonNegativeInteger:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::string*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::string*>(p->ptr));
		break;
	case SOAP_TYPE_xsd__token:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::string*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::string*>(p->ptr));
		break;
	case SOAP_TYPE__xml__lang:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::string*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::string*>(p->ptr));
		break;
	case SOAP_TYPE_ns3__AbsoluteOrRelativeTimeType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::string*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::string*>(p->ptr));
		break;
	case SOAP_TYPE_ns6__RelationshipTypeOpenEnum:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::string*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::string*>(p->ptr));
		break;
	case SOAP_TYPE_ns6__FaultCodesOpenEnumType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::string*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::string*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__FullTopicExpression:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::string*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::string*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__ConcreteTopicExpression:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::string*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::string*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__SimpleTopicExpression:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::string*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::string*>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfxsd__QName:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<std::string> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<std::string> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOf_ns2__TopicNamespaceType_Topic:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<_ns2__TopicNamespaceType_Topic> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<_ns2__TopicNamespaceType_Topic> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__TopicType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns2__TopicType *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns2__TopicType *> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons5__UsedActionRule:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns5__UsedActionRule *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns5__UsedActionRule *> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons5__UsedActionConfiguration:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns5__UsedActionConfiguration *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns5__UsedActionConfiguration *> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons5__ActionTemplateParameter:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns5__ActionTemplateParameter *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns5__ActionTemplateParameter *> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons5__ActionTemplate:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns5__ActionTemplate *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns5__ActionTemplate *> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons5__ActionParameter:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns5__ActionParameter *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns5__ActionParameter *> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons5__ActionConfiguration:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns5__ActionConfiguration *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns5__ActionConfiguration *> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons5__RecipientTemplate:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns5__RecipientTemplate *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns5__RecipientTemplate *> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons5__RecipientConfiguration:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns5__RecipientConfiguration *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns5__RecipientConfiguration *> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons5__ActionRule:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns5__ActionRule *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns5__ActionRule *> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons3__FilterType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns3__FilterType *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns3__FilterType *> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOf_ns4__BaseFaultType_Description:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<_ns4__BaseFaultType_Description> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<_ns4__BaseFaultType_Description> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons3__NotificationMessageHolderType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns3__NotificationMessageHolderType *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns3__NotificationMessageHolderType *> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfxsd__anyURI:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<std::string> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<std::string> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons3__TopicExpressionType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns3__TopicExpressionType *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns3__TopicExpressionType *> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfxsd__anyType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<struct soap_dom_element> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<struct soap_dom_element> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__ScheduledEvent:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns1__ScheduledEvent *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns1__ScheduledEvent *> *>(p->ptr));
		break;
	default:
		return SOAP_ERR;
	}
	return SOAP_OK;
}

#ifdef WIN32
#pragma warning(push)
// do not warn on switch w/o cases
#pragma warning(disable:4065)
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_fbase(int t, int b)
{
	do
	{	switch (t)
		{

		case SOAP_TYPE_ns2__TopicNamespaceType: t = SOAP_TYPE_ns2__ExtensibleDocumented; break;
		case SOAP_TYPE_ns2__TopicType: t = SOAP_TYPE_ns2__ExtensibleDocumented; break;
		case SOAP_TYPE_ns2__TopicSetType: t = SOAP_TYPE_ns2__ExtensibleDocumented; break;
		case SOAP_TYPE_ns3__SubscribeCreationFailedFaultType: t = SOAP_TYPE_ns4__BaseFaultType; break;
		case SOAP_TYPE_ns3__InvalidFilterFaultType: t = SOAP_TYPE_ns4__BaseFaultType; break;
		case SOAP_TYPE_ns3__TopicExpressionDialectUnknownFaultType: t = SOAP_TYPE_ns4__BaseFaultType; break;
		case SOAP_TYPE_ns3__InvalidTopicExpressionFaultType: t = SOAP_TYPE_ns4__BaseFaultType; break;
		case SOAP_TYPE_ns3__TopicNotSupportedFaultType: t = SOAP_TYPE_ns4__BaseFaultType; break;
		case SOAP_TYPE_ns3__MultipleTopicsSpecifiedFaultType: t = SOAP_TYPE_ns4__BaseFaultType; break;
		case SOAP_TYPE_ns3__InvalidProducerPropertiesExpressionFaultType: t = SOAP_TYPE_ns4__BaseFaultType; break;
		case SOAP_TYPE_ns3__InvalidMessageContentExpressionFaultType: t = SOAP_TYPE_ns4__BaseFaultType; break;
		case SOAP_TYPE_ns3__UnrecognizedPolicyRequestFaultType: t = SOAP_TYPE_ns4__BaseFaultType; break;
		case SOAP_TYPE_ns3__UnsupportedPolicyRequestFaultType: t = SOAP_TYPE_ns4__BaseFaultType; break;
		case SOAP_TYPE_ns3__NotifyMessageNotSupportedFaultType: t = SOAP_TYPE_ns4__BaseFaultType; break;
		case SOAP_TYPE_ns3__UnacceptableInitialTerminationTimeFaultType: t = SOAP_TYPE_ns4__BaseFaultType; break;
		case SOAP_TYPE_ns3__NoCurrentMessageOnTopicFaultType: t = SOAP_TYPE_ns4__BaseFaultType; break;
		case SOAP_TYPE_ns3__UnableToGetMessagesFaultType: t = SOAP_TYPE_ns4__BaseFaultType; break;
		case SOAP_TYPE_ns3__UnableToDestroyPullPointFaultType: t = SOAP_TYPE_ns4__BaseFaultType; break;
		case SOAP_TYPE_ns3__UnableToCreatePullPointFaultType: t = SOAP_TYPE_ns4__BaseFaultType; break;
		case SOAP_TYPE_ns3__UnacceptableTerminationTimeFaultType: t = SOAP_TYPE_ns4__BaseFaultType; break;
		case SOAP_TYPE_ns3__UnableToDestroySubscriptionFaultType: t = SOAP_TYPE_ns4__BaseFaultType; break;
		case SOAP_TYPE_ns3__PauseFailedFaultType: t = SOAP_TYPE_ns4__BaseFaultType; break;
		case SOAP_TYPE_ns3__ResumeFailedFaultType: t = SOAP_TYPE_ns4__BaseFaultType; break;
		default: return 0;
		}
	}
	while (t != b);
	return 1;
}
#ifdef WIN32
#pragma warning(pop)
#endif

#ifndef WITH_NOIDREF
#ifdef WIN32
#pragma warning(push)
// do not warn on switch w/o cases
#pragma warning(disable:4065)
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_finsert(struct soap *soap, int t, int tt, void *p, size_t index, const void *q, void **x)
{
	(void)soap; (void)t; (void)p; (void)index; (void)q; (void)x; /* appease -Wall -Werror */
	switch (tt)
	{
	case SOAP_TYPE_std__vectorTemplateOfxsd__QName:
		if (t == SOAP_TYPE_xsd__QName)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<std::string>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<std::string> *)p)[index] = *(std::string *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOf_ns2__TopicNamespaceType_Topic:
		if (t == SOAP_TYPE__ns2__TopicNamespaceType_Topic)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<_ns2__TopicNamespaceType_Topic>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<_ns2__TopicNamespaceType_Topic> *)p)[index] = *(_ns2__TopicNamespaceType_Topic *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__TopicType:
		if (t == SOAP_TYPE_ns2__TopicType || soap_fbase(t, SOAP_TYPE_ns2__TopicType))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns2__TopicType *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns2__TopicType *> *)p)[index] = *(ns2__TopicType **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons5__UsedActionRule:
		if (t == SOAP_TYPE_ns5__UsedActionRule || soap_fbase(t, SOAP_TYPE_ns5__UsedActionRule))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns5__UsedActionRule *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns5__UsedActionRule *> *)p)[index] = *(ns5__UsedActionRule **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons5__UsedActionConfiguration:
		if (t == SOAP_TYPE_ns5__UsedActionConfiguration || soap_fbase(t, SOAP_TYPE_ns5__UsedActionConfiguration))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns5__UsedActionConfiguration *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns5__UsedActionConfiguration *> *)p)[index] = *(ns5__UsedActionConfiguration **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons5__ActionTemplateParameter:
		if (t == SOAP_TYPE_ns5__ActionTemplateParameter || soap_fbase(t, SOAP_TYPE_ns5__ActionTemplateParameter))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns5__ActionTemplateParameter *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns5__ActionTemplateParameter *> *)p)[index] = *(ns5__ActionTemplateParameter **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons5__ActionTemplate:
		if (t == SOAP_TYPE_ns5__ActionTemplate || soap_fbase(t, SOAP_TYPE_ns5__ActionTemplate))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns5__ActionTemplate *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns5__ActionTemplate *> *)p)[index] = *(ns5__ActionTemplate **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons5__ActionParameter:
		if (t == SOAP_TYPE_ns5__ActionParameter || soap_fbase(t, SOAP_TYPE_ns5__ActionParameter))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns5__ActionParameter *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns5__ActionParameter *> *)p)[index] = *(ns5__ActionParameter **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons5__ActionConfiguration:
		if (t == SOAP_TYPE_ns5__ActionConfiguration || soap_fbase(t, SOAP_TYPE_ns5__ActionConfiguration))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns5__ActionConfiguration *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns5__ActionConfiguration *> *)p)[index] = *(ns5__ActionConfiguration **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons5__RecipientTemplate:
		if (t == SOAP_TYPE_ns5__RecipientTemplate || soap_fbase(t, SOAP_TYPE_ns5__RecipientTemplate))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns5__RecipientTemplate *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns5__RecipientTemplate *> *)p)[index] = *(ns5__RecipientTemplate **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons5__RecipientConfiguration:
		if (t == SOAP_TYPE_ns5__RecipientConfiguration || soap_fbase(t, SOAP_TYPE_ns5__RecipientConfiguration))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns5__RecipientConfiguration *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns5__RecipientConfiguration *> *)p)[index] = *(ns5__RecipientConfiguration **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons5__ActionRule:
		if (t == SOAP_TYPE_ns5__ActionRule || soap_fbase(t, SOAP_TYPE_ns5__ActionRule))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns5__ActionRule *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns5__ActionRule *> *)p)[index] = *(ns5__ActionRule **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons3__FilterType:
		if (t == SOAP_TYPE_ns3__FilterType || soap_fbase(t, SOAP_TYPE_ns3__FilterType))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns3__FilterType *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns3__FilterType *> *)p)[index] = *(ns3__FilterType **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOf_ns4__BaseFaultType_Description:
		if (t == SOAP_TYPE__ns4__BaseFaultType_Description)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<_ns4__BaseFaultType_Description>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<_ns4__BaseFaultType_Description> *)p)[index] = *(_ns4__BaseFaultType_Description *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons3__NotificationMessageHolderType:
		if (t == SOAP_TYPE_ns3__NotificationMessageHolderType || soap_fbase(t, SOAP_TYPE_ns3__NotificationMessageHolderType))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns3__NotificationMessageHolderType *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns3__NotificationMessageHolderType *> *)p)[index] = *(ns3__NotificationMessageHolderType **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfxsd__anyURI:
		if (t == SOAP_TYPE_xsd__anyURI)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<std::string>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<std::string> *)p)[index] = *(std::string *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons3__TopicExpressionType:
		if (t == SOAP_TYPE_ns3__TopicExpressionType || soap_fbase(t, SOAP_TYPE_ns3__TopicExpressionType))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns3__TopicExpressionType *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns3__TopicExpressionType *> *)p)[index] = *(ns3__TopicExpressionType **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfxsd__anyType:
		if (t == SOAP_TYPE_xsd__anyType)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<struct soap_dom_element>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<struct soap_dom_element> *)p)[index] = *(struct soap_dom_element *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__ScheduledEvent:
		if (t == SOAP_TYPE_ns1__ScheduledEvent || soap_fbase(t, SOAP_TYPE_ns1__ScheduledEvent))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__ScheduledEvent *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__ScheduledEvent *> *)p)[index] = *(ns1__ScheduledEvent **)q;
		}
		break;
	case SOAP_TYPE_std__string:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_xsd__NCName_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xsd__NCName_ type=%d location=%p object=%p\n", t, p, q));
		*(xsd__NCName_*)p = *(xsd__NCName_*)q;
		break;
	case SOAP_TYPE_xsd__QName_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xsd__QName_ type=%d location=%p object=%p\n", t, p, q));
		*(xsd__QName_*)p = *(xsd__QName_*)q;
		break;
	case SOAP_TYPE_xsd__anyURI_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xsd__anyURI_ type=%d location=%p object=%p\n", t, p, q));
		*(xsd__anyURI_*)p = *(xsd__anyURI_*)q;
		break;
	case SOAP_TYPE_xsd__boolean:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xsd__boolean type=%d location=%p object=%p\n", t, p, q));
		*(xsd__boolean*)p = *(xsd__boolean*)q;
		break;
	case SOAP_TYPE_xsd__dateTime:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xsd__dateTime type=%d location=%p object=%p\n", t, p, q));
		*(xsd__dateTime*)p = *(xsd__dateTime*)q;
		break;
	case SOAP_TYPE_xsd__duration_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xsd__duration_ type=%d location=%p object=%p\n", t, p, q));
		*(xsd__duration_*)p = *(xsd__duration_*)q;
		break;
	case SOAP_TYPE_xsd__int:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xsd__int type=%d location=%p object=%p\n", t, p, q));
		*(xsd__int*)p = *(xsd__int*)q;
		break;
	case SOAP_TYPE_xsd__integer_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xsd__integer_ type=%d location=%p object=%p\n", t, p, q));
		*(xsd__integer_*)p = *(xsd__integer_*)q;
		break;
	case SOAP_TYPE_xsd__nonNegativeInteger_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xsd__nonNegativeInteger_ type=%d location=%p object=%p\n", t, p, q));
		*(xsd__nonNegativeInteger_*)p = *(xsd__nonNegativeInteger_*)q;
		break;
	case SOAP_TYPE_xsd__string:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xsd__string type=%d location=%p object=%p\n", t, p, q));
		*(xsd__string*)p = *(xsd__string*)q;
		break;
	case SOAP_TYPE_xsd__token_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xsd__token_ type=%d location=%p object=%p\n", t, p, q));
		*(xsd__token_*)p = *(xsd__token_*)q;
		break;
	case SOAP_TYPE_xsd__unsignedLong:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xsd__unsignedLong type=%d location=%p object=%p\n", t, p, q));
		*(xsd__unsignedLong*)p = *(xsd__unsignedLong*)q;
		break;
	case SOAP_TYPE_ns1__ScheduledType__:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__ScheduledType__ type=%d location=%p object=%p\n", t, p, q));
		*(ns1__ScheduledType__*)p = *(ns1__ScheduledType__*)q;
		break;
	case SOAP_TYPE_ns2__FullTopicExpression__:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__FullTopicExpression__ type=%d location=%p object=%p\n", t, p, q));
		*(ns2__FullTopicExpression__*)p = *(ns2__FullTopicExpression__*)q;
		break;
	case SOAP_TYPE_ns2__ConcreteTopicExpression__:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__ConcreteTopicExpression__ type=%d location=%p object=%p\n", t, p, q));
		*(ns2__ConcreteTopicExpression__*)p = *(ns2__ConcreteTopicExpression__*)q;
		break;
	case SOAP_TYPE_ns2__SimpleTopicExpression__:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__SimpleTopicExpression__ type=%d location=%p object=%p\n", t, p, q));
		*(ns2__SimpleTopicExpression__*)p = *(ns2__SimpleTopicExpression__*)q;
		break;
	case SOAP_TYPE_ns6__RelationshipType__:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns6__RelationshipType__ type=%d location=%p object=%p\n", t, p, q));
		*(ns6__RelationshipType__*)p = *(ns6__RelationshipType__*)q;
		break;
	case SOAP_TYPE_ns6__FaultCodesType__:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns6__FaultCodesType__ type=%d location=%p object=%p\n", t, p, q));
		*(ns6__FaultCodesType__*)p = *(ns6__FaultCodesType__*)q;
		break;
	case SOAP_TYPE_ns1__NewScheduledEvent:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__NewScheduledEvent type=%d location=%p object=%p\n", t, p, q));
		*(ns1__NewScheduledEvent*)p = *(ns1__NewScheduledEvent*)q;
		break;
	case SOAP_TYPE_ns1__ScheduledEvents:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__ScheduledEvents type=%d location=%p object=%p\n", t, p, q));
		*(ns1__ScheduledEvents*)p = *(ns1__ScheduledEvents*)q;
		break;
	case SOAP_TYPE_ns1__ScheduledEvent:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__ScheduledEvent type=%d location=%p object=%p\n", t, p, q));
		*(ns1__ScheduledEvent*)p = *(ns1__ScheduledEvent*)q;
		break;
	case SOAP_TYPE_ns1__Schedule:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__Schedule type=%d location=%p object=%p\n", t, p, q));
		*(ns1__Schedule*)p = *(ns1__Schedule*)q;
		break;
	case SOAP_TYPE_ns1__ScheduleFilter:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__ScheduleFilter type=%d location=%p object=%p\n", t, p, q));
		*(ns1__ScheduleFilter*)p = *(ns1__ScheduleFilter*)q;
		break;
	case SOAP_TYPE__ns1__GetEventInstances:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetEventInstances type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetEventInstances*)p = *(_ns1__GetEventInstances*)q;
		break;
	case SOAP_TYPE__ns1__GetEventInstancesResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetEventInstancesResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetEventInstancesResponse*)p = *(_ns1__GetEventInstancesResponse*)q;
		break;
	case SOAP_TYPE__ns1__AddScheduledEvent:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__AddScheduledEvent type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__AddScheduledEvent*)p = *(_ns1__AddScheduledEvent*)q;
		break;
	case SOAP_TYPE__ns1__AddScheduledEventResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__AddScheduledEventResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__AddScheduledEventResponse*)p = *(_ns1__AddScheduledEventResponse*)q;
		break;
	case SOAP_TYPE__ns1__RemoveScheduledEvent:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__RemoveScheduledEvent type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__RemoveScheduledEvent*)p = *(_ns1__RemoveScheduledEvent*)q;
		break;
	case SOAP_TYPE__ns1__RemoveScheduledEventResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__RemoveScheduledEventResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__RemoveScheduledEventResponse*)p = *(_ns1__RemoveScheduledEventResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetScheduledEvents:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetScheduledEvents type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetScheduledEvents*)p = *(_ns1__GetScheduledEvents*)q;
		break;
	case SOAP_TYPE__ns1__GetScheduledEventsResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetScheduledEventsResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetScheduledEventsResponse*)p = *(_ns1__GetScheduledEventsResponse*)q;
		break;
	case SOAP_TYPE__ns1__ScheduledEventNotFoundFault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__ScheduledEventNotFoundFault type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__ScheduledEventNotFoundFault*)p = *(_ns1__ScheduledEventNotFoundFault*)q;
		break;
	case SOAP_TYPE__ns1__InvalidScheduleFault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__InvalidScheduleFault type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__InvalidScheduleFault*)p = *(_ns1__InvalidScheduleFault*)q;
		break;
	case SOAP_TYPE__ns1__InvalidScheduledEventIDFault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__InvalidScheduledEventIDFault type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__InvalidScheduledEventIDFault*)p = *(_ns1__InvalidScheduledEventIDFault*)q;
		break;
	case SOAP_TYPE__ns1__ScheduledEventAlreadyExistsFault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__ScheduledEventAlreadyExistsFault type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__ScheduledEventAlreadyExistsFault*)p = *(_ns1__ScheduledEventAlreadyExistsFault*)q;
		break;
	case SOAP_TYPE__ns1__ChangeVirtualInputState:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__ChangeVirtualInputState type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__ChangeVirtualInputState*)p = *(_ns1__ChangeVirtualInputState*)q;
		break;
	case SOAP_TYPE__ns1__ChangeVirtualInputStateResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__ChangeVirtualInputStateResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__ChangeVirtualInputStateResponse*)p = *(_ns1__ChangeVirtualInputStateResponse*)q;
		break;
	case SOAP_TYPE_ns2__Documentation:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__Documentation type=%d location=%p object=%p\n", t, p, q));
		*(ns2__Documentation*)p = *(ns2__Documentation*)q;
		break;
	case SOAP_TYPE_ns2__ExtensibleDocumented:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__ExtensibleDocumented type=%d location=%p object=%p\n", t, p, q));
		*(ns2__ExtensibleDocumented*)p = *(ns2__ExtensibleDocumented*)q;
		break;
	case SOAP_TYPE_ns2__QueryExpressionType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__QueryExpressionType type=%d location=%p object=%p\n", t, p, q));
		*(ns2__QueryExpressionType*)p = *(ns2__QueryExpressionType*)q;
		break;
	case SOAP_TYPE_ns3__QueryExpressionType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__QueryExpressionType type=%d location=%p object=%p\n", t, p, q));
		*(ns3__QueryExpressionType*)p = *(ns3__QueryExpressionType*)q;
		break;
	case SOAP_TYPE_ns3__TopicExpressionType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__TopicExpressionType type=%d location=%p object=%p\n", t, p, q));
		*(ns3__TopicExpressionType*)p = *(ns3__TopicExpressionType*)q;
		break;
	case SOAP_TYPE_ns3__FilterType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__FilterType type=%d location=%p object=%p\n", t, p, q));
		*(ns3__FilterType*)p = *(ns3__FilterType*)q;
		break;
	case SOAP_TYPE_ns3__SubscriptionPolicyType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__SubscriptionPolicyType type=%d location=%p object=%p\n", t, p, q));
		*(ns3__SubscriptionPolicyType*)p = *(ns3__SubscriptionPolicyType*)q;
		break;
	case SOAP_TYPE__ns3__NotificationMessageHolderType_Message:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns3__NotificationMessageHolderType_Message type=%d location=%p object=%p\n", t, p, q));
		*(_ns3__NotificationMessageHolderType_Message*)p = *(_ns3__NotificationMessageHolderType_Message*)q;
		break;
	case SOAP_TYPE_ns3__NotificationMessageHolderType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__NotificationMessageHolderType type=%d location=%p object=%p\n", t, p, q));
		*(ns3__NotificationMessageHolderType*)p = *(ns3__NotificationMessageHolderType*)q;
		break;
	case SOAP_TYPE__ns3__NotificationProducerRP:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns3__NotificationProducerRP type=%d location=%p object=%p\n", t, p, q));
		*(_ns3__NotificationProducerRP*)p = *(_ns3__NotificationProducerRP*)q;
		break;
	case SOAP_TYPE__ns3__SubscriptionManagerRP:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns3__SubscriptionManagerRP type=%d location=%p object=%p\n", t, p, q));
		*(_ns3__SubscriptionManagerRP*)p = *(_ns3__SubscriptionManagerRP*)q;
		break;
	case SOAP_TYPE__ns3__Notify:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns3__Notify type=%d location=%p object=%p\n", t, p, q));
		*(_ns3__Notify*)p = *(_ns3__Notify*)q;
		break;
	case SOAP_TYPE__ns3__UseRaw:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns3__UseRaw type=%d location=%p object=%p\n", t, p, q));
		*(_ns3__UseRaw*)p = *(_ns3__UseRaw*)q;
		break;
	case SOAP_TYPE__ns3__Subscribe_SubscriptionPolicy:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns3__Subscribe_SubscriptionPolicy type=%d location=%p object=%p\n", t, p, q));
		*(_ns3__Subscribe_SubscriptionPolicy*)p = *(_ns3__Subscribe_SubscriptionPolicy*)q;
		break;
	case SOAP_TYPE__ns3__Subscribe:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns3__Subscribe type=%d location=%p object=%p\n", t, p, q));
		*(_ns3__Subscribe*)p = *(_ns3__Subscribe*)q;
		break;
	case SOAP_TYPE__ns3__SubscribeResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns3__SubscribeResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns3__SubscribeResponse*)p = *(_ns3__SubscribeResponse*)q;
		break;
	case SOAP_TYPE__ns3__GetCurrentMessage:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns3__GetCurrentMessage type=%d location=%p object=%p\n", t, p, q));
		*(_ns3__GetCurrentMessage*)p = *(_ns3__GetCurrentMessage*)q;
		break;
	case SOAP_TYPE__ns3__GetCurrentMessageResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns3__GetCurrentMessageResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns3__GetCurrentMessageResponse*)p = *(_ns3__GetCurrentMessageResponse*)q;
		break;
	case SOAP_TYPE__ns3__GetMessages:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns3__GetMessages type=%d location=%p object=%p\n", t, p, q));
		*(_ns3__GetMessages*)p = *(_ns3__GetMessages*)q;
		break;
	case SOAP_TYPE__ns3__GetMessagesResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns3__GetMessagesResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns3__GetMessagesResponse*)p = *(_ns3__GetMessagesResponse*)q;
		break;
	case SOAP_TYPE__ns3__DestroyPullPoint:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns3__DestroyPullPoint type=%d location=%p object=%p\n", t, p, q));
		*(_ns3__DestroyPullPoint*)p = *(_ns3__DestroyPullPoint*)q;
		break;
	case SOAP_TYPE__ns3__DestroyPullPointResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns3__DestroyPullPointResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns3__DestroyPullPointResponse*)p = *(_ns3__DestroyPullPointResponse*)q;
		break;
	case SOAP_TYPE__ns3__CreatePullPoint:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns3__CreatePullPoint type=%d location=%p object=%p\n", t, p, q));
		*(_ns3__CreatePullPoint*)p = *(_ns3__CreatePullPoint*)q;
		break;
	case SOAP_TYPE__ns3__CreatePullPointResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns3__CreatePullPointResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns3__CreatePullPointResponse*)p = *(_ns3__CreatePullPointResponse*)q;
		break;
	case SOAP_TYPE__ns3__Renew:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns3__Renew type=%d location=%p object=%p\n", t, p, q));
		*(_ns3__Renew*)p = *(_ns3__Renew*)q;
		break;
	case SOAP_TYPE__ns3__RenewResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns3__RenewResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns3__RenewResponse*)p = *(_ns3__RenewResponse*)q;
		break;
	case SOAP_TYPE__ns3__Unsubscribe:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns3__Unsubscribe type=%d location=%p object=%p\n", t, p, q));
		*(_ns3__Unsubscribe*)p = *(_ns3__Unsubscribe*)q;
		break;
	case SOAP_TYPE__ns3__UnsubscribeResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns3__UnsubscribeResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns3__UnsubscribeResponse*)p = *(_ns3__UnsubscribeResponse*)q;
		break;
	case SOAP_TYPE__ns3__PauseSubscription:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns3__PauseSubscription type=%d location=%p object=%p\n", t, p, q));
		*(_ns3__PauseSubscription*)p = *(_ns3__PauseSubscription*)q;
		break;
	case SOAP_TYPE__ns3__PauseSubscriptionResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns3__PauseSubscriptionResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns3__PauseSubscriptionResponse*)p = *(_ns3__PauseSubscriptionResponse*)q;
		break;
	case SOAP_TYPE__ns3__ResumeSubscription:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns3__ResumeSubscription type=%d location=%p object=%p\n", t, p, q));
		*(_ns3__ResumeSubscription*)p = *(_ns3__ResumeSubscription*)q;
		break;
	case SOAP_TYPE__ns3__ResumeSubscriptionResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns3__ResumeSubscriptionResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns3__ResumeSubscriptionResponse*)p = *(_ns3__ResumeSubscriptionResponse*)q;
		break;
	case SOAP_TYPE__ns4__BaseFaultType_ErrorCode:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns4__BaseFaultType_ErrorCode type=%d location=%p object=%p\n", t, p, q));
		*(_ns4__BaseFaultType_ErrorCode*)p = *(_ns4__BaseFaultType_ErrorCode*)q;
		break;
	case SOAP_TYPE__ns4__BaseFaultType_Description:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns4__BaseFaultType_Description type=%d location=%p object=%p\n", t, p, q));
		*(_ns4__BaseFaultType_Description*)p = *(_ns4__BaseFaultType_Description*)q;
		break;
	case SOAP_TYPE__ns4__BaseFaultType_FaultCause:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns4__BaseFaultType_FaultCause type=%d location=%p object=%p\n", t, p, q));
		*(_ns4__BaseFaultType_FaultCause*)p = *(_ns4__BaseFaultType_FaultCause*)q;
		break;
	case SOAP_TYPE_ns4__BaseFaultType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns4__BaseFaultType type=%d location=%p object=%p\n", t, p, q));
		*(ns4__BaseFaultType*)p = *(ns4__BaseFaultType*)q;
		break;
	case SOAP_TYPE_ns5__NewActionRule:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns5__NewActionRule type=%d location=%p object=%p\n", t, p, q));
		*(ns5__NewActionRule*)p = *(ns5__NewActionRule*)q;
		break;
	case SOAP_TYPE_ns5__Conditions:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns5__Conditions type=%d location=%p object=%p\n", t, p, q));
		*(ns5__Conditions*)p = *(ns5__Conditions*)q;
		break;
	case SOAP_TYPE_ns5__ActionRules:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns5__ActionRules type=%d location=%p object=%p\n", t, p, q));
		*(ns5__ActionRules*)p = *(ns5__ActionRules*)q;
		break;
	case SOAP_TYPE_ns5__ActionRule:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns5__ActionRule type=%d location=%p object=%p\n", t, p, q));
		*(ns5__ActionRule*)p = *(ns5__ActionRule*)q;
		break;
	case SOAP_TYPE_ns5__NewRecipientConfiguration:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns5__NewRecipientConfiguration type=%d location=%p object=%p\n", t, p, q));
		*(ns5__NewRecipientConfiguration*)p = *(ns5__NewRecipientConfiguration*)q;
		break;
	case SOAP_TYPE_ns5__RecipientConfiguration:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns5__RecipientConfiguration type=%d location=%p object=%p\n", t, p, q));
		*(ns5__RecipientConfiguration*)p = *(ns5__RecipientConfiguration*)q;
		break;
	case SOAP_TYPE_ns5__RecipientConfigurations:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns5__RecipientConfigurations type=%d location=%p object=%p\n", t, p, q));
		*(ns5__RecipientConfigurations*)p = *(ns5__RecipientConfigurations*)q;
		break;
	case SOAP_TYPE_ns5__RecipientTemplates:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns5__RecipientTemplates type=%d location=%p object=%p\n", t, p, q));
		*(ns5__RecipientTemplates*)p = *(ns5__RecipientTemplates*)q;
		break;
	case SOAP_TYPE_ns5__RecipientTemplate:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns5__RecipientTemplate type=%d location=%p object=%p\n", t, p, q));
		*(ns5__RecipientTemplate*)p = *(ns5__RecipientTemplate*)q;
		break;
	case SOAP_TYPE_ns5__ActionConfigurations:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns5__ActionConfigurations type=%d location=%p object=%p\n", t, p, q));
		*(ns5__ActionConfigurations*)p = *(ns5__ActionConfigurations*)q;
		break;
	case SOAP_TYPE_ns5__NewActionConfiguration:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns5__NewActionConfiguration type=%d location=%p object=%p\n", t, p, q));
		*(ns5__NewActionConfiguration*)p = *(ns5__NewActionConfiguration*)q;
		break;
	case SOAP_TYPE_ns5__ActionConfiguration:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns5__ActionConfiguration type=%d location=%p object=%p\n", t, p, q));
		*(ns5__ActionConfiguration*)p = *(ns5__ActionConfiguration*)q;
		break;
	case SOAP_TYPE_ns5__ActionParameters:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns5__ActionParameters type=%d location=%p object=%p\n", t, p, q));
		*(ns5__ActionParameters*)p = *(ns5__ActionParameters*)q;
		break;
	case SOAP_TYPE_ns5__ActionTemplates:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns5__ActionTemplates type=%d location=%p object=%p\n", t, p, q));
		*(ns5__ActionTemplates*)p = *(ns5__ActionTemplates*)q;
		break;
	case SOAP_TYPE_ns5__ActionParameter:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns5__ActionParameter type=%d location=%p object=%p\n", t, p, q));
		*(ns5__ActionParameter*)p = *(ns5__ActionParameter*)q;
		break;
	case SOAP_TYPE_ns5__ActionTemplate:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns5__ActionTemplate type=%d location=%p object=%p\n", t, p, q));
		*(ns5__ActionTemplate*)p = *(ns5__ActionTemplate*)q;
		break;
	case SOAP_TYPE_ns5__ActionTemplateParameters:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns5__ActionTemplateParameters type=%d location=%p object=%p\n", t, p, q));
		*(ns5__ActionTemplateParameters*)p = *(ns5__ActionTemplateParameters*)q;
		break;
	case SOAP_TYPE_ns5__ActionTemplateParameter:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns5__ActionTemplateParameter type=%d location=%p object=%p\n", t, p, q));
		*(ns5__ActionTemplateParameter*)p = *(ns5__ActionTemplateParameter*)q;
		break;
	case SOAP_TYPE_ns5__UsedByActionConfigurations:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns5__UsedByActionConfigurations type=%d location=%p object=%p\n", t, p, q));
		*(ns5__UsedByActionConfigurations*)p = *(ns5__UsedByActionConfigurations*)q;
		break;
	case SOAP_TYPE_ns5__UsedActionConfiguration:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns5__UsedActionConfiguration type=%d location=%p object=%p\n", t, p, q));
		*(ns5__UsedActionConfiguration*)p = *(ns5__UsedActionConfiguration*)q;
		break;
	case SOAP_TYPE_ns5__UsedByActionRules:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns5__UsedByActionRules type=%d location=%p object=%p\n", t, p, q));
		*(ns5__UsedByActionRules*)p = *(ns5__UsedByActionRules*)q;
		break;
	case SOAP_TYPE_ns5__UsedActionRule:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns5__UsedActionRule type=%d location=%p object=%p\n", t, p, q));
		*(ns5__UsedActionRule*)p = *(ns5__UsedActionRule*)q;
		break;
	case SOAP_TYPE__ns5__GetActionTemplates:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns5__GetActionTemplates type=%d location=%p object=%p\n", t, p, q));
		*(_ns5__GetActionTemplates*)p = *(_ns5__GetActionTemplates*)q;
		break;
	case SOAP_TYPE__ns5__GetActionTemplatesResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns5__GetActionTemplatesResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns5__GetActionTemplatesResponse*)p = *(_ns5__GetActionTemplatesResponse*)q;
		break;
	case SOAP_TYPE__ns5__AddActionConfiguration:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns5__AddActionConfiguration type=%d location=%p object=%p\n", t, p, q));
		*(_ns5__AddActionConfiguration*)p = *(_ns5__AddActionConfiguration*)q;
		break;
	case SOAP_TYPE__ns5__AddActionConfigurationResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns5__AddActionConfigurationResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns5__AddActionConfigurationResponse*)p = *(_ns5__AddActionConfigurationResponse*)q;
		break;
	case SOAP_TYPE__ns5__RemoveActionConfiguration:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns5__RemoveActionConfiguration type=%d location=%p object=%p\n", t, p, q));
		*(_ns5__RemoveActionConfiguration*)p = *(_ns5__RemoveActionConfiguration*)q;
		break;
	case SOAP_TYPE__ns5__RemoveActionConfigurationResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns5__RemoveActionConfigurationResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns5__RemoveActionConfigurationResponse*)p = *(_ns5__RemoveActionConfigurationResponse*)q;
		break;
	case SOAP_TYPE__ns5__GetActionConfigurations:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns5__GetActionConfigurations type=%d location=%p object=%p\n", t, p, q));
		*(_ns5__GetActionConfigurations*)p = *(_ns5__GetActionConfigurations*)q;
		break;
	case SOAP_TYPE__ns5__GetActionConfigurationsResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns5__GetActionConfigurationsResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns5__GetActionConfigurationsResponse*)p = *(_ns5__GetActionConfigurationsResponse*)q;
		break;
	case SOAP_TYPE__ns5__GetRecipientTemplates:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns5__GetRecipientTemplates type=%d location=%p object=%p\n", t, p, q));
		*(_ns5__GetRecipientTemplates*)p = *(_ns5__GetRecipientTemplates*)q;
		break;
	case SOAP_TYPE__ns5__GetRecipientTemplatesResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns5__GetRecipientTemplatesResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns5__GetRecipientTemplatesResponse*)p = *(_ns5__GetRecipientTemplatesResponse*)q;
		break;
	case SOAP_TYPE__ns5__AddRecipientConfiguration:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns5__AddRecipientConfiguration type=%d location=%p object=%p\n", t, p, q));
		*(_ns5__AddRecipientConfiguration*)p = *(_ns5__AddRecipientConfiguration*)q;
		break;
	case SOAP_TYPE__ns5__AddRecipientConfigurationResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns5__AddRecipientConfigurationResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns5__AddRecipientConfigurationResponse*)p = *(_ns5__AddRecipientConfigurationResponse*)q;
		break;
	case SOAP_TYPE__ns5__RemoveRecipientConfiguration:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns5__RemoveRecipientConfiguration type=%d location=%p object=%p\n", t, p, q));
		*(_ns5__RemoveRecipientConfiguration*)p = *(_ns5__RemoveRecipientConfiguration*)q;
		break;
	case SOAP_TYPE__ns5__RemoveRecipientConfigurationResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns5__RemoveRecipientConfigurationResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns5__RemoveRecipientConfigurationResponse*)p = *(_ns5__RemoveRecipientConfigurationResponse*)q;
		break;
	case SOAP_TYPE__ns5__GetRecipientConfigurations:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns5__GetRecipientConfigurations type=%d location=%p object=%p\n", t, p, q));
		*(_ns5__GetRecipientConfigurations*)p = *(_ns5__GetRecipientConfigurations*)q;
		break;
	case SOAP_TYPE__ns5__GetRecipientConfigurationsResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns5__GetRecipientConfigurationsResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns5__GetRecipientConfigurationsResponse*)p = *(_ns5__GetRecipientConfigurationsResponse*)q;
		break;
	case SOAP_TYPE__ns5__AddActionRule:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns5__AddActionRule type=%d location=%p object=%p\n", t, p, q));
		*(_ns5__AddActionRule*)p = *(_ns5__AddActionRule*)q;
		break;
	case SOAP_TYPE__ns5__AddActionRuleResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns5__AddActionRuleResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns5__AddActionRuleResponse*)p = *(_ns5__AddActionRuleResponse*)q;
		break;
	case SOAP_TYPE__ns5__GetActionRules:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns5__GetActionRules type=%d location=%p object=%p\n", t, p, q));
		*(_ns5__GetActionRules*)p = *(_ns5__GetActionRules*)q;
		break;
	case SOAP_TYPE__ns5__GetActionRulesResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns5__GetActionRulesResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns5__GetActionRulesResponse*)p = *(_ns5__GetActionRulesResponse*)q;
		break;
	case SOAP_TYPE__ns5__RemoveActionRule:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns5__RemoveActionRule type=%d location=%p object=%p\n", t, p, q));
		*(_ns5__RemoveActionRule*)p = *(_ns5__RemoveActionRule*)q;
		break;
	case SOAP_TYPE__ns5__RemoveActionRuleResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns5__RemoveActionRuleResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns5__RemoveActionRuleResponse*)p = *(_ns5__RemoveActionRuleResponse*)q;
		break;
	case SOAP_TYPE__ns5__ActionTemplateNotFoundFault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns5__ActionTemplateNotFoundFault type=%d location=%p object=%p\n", t, p, q));
		*(_ns5__ActionTemplateNotFoundFault*)p = *(_ns5__ActionTemplateNotFoundFault*)q;
		break;
	case SOAP_TYPE__ns5__RecipientConfigurationNotFoundFault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns5__RecipientConfigurationNotFoundFault type=%d location=%p object=%p\n", t, p, q));
		*(_ns5__RecipientConfigurationNotFoundFault*)p = *(_ns5__RecipientConfigurationNotFoundFault*)q;
		break;
	case SOAP_TYPE__ns5__ParametersMissmatchFault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns5__ParametersMissmatchFault type=%d location=%p object=%p\n", t, p, q));
		*(_ns5__ParametersMissmatchFault*)p = *(_ns5__ParametersMissmatchFault*)q;
		break;
	case SOAP_TYPE__ns5__InvalidActionConfigurationFault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns5__InvalidActionConfigurationFault type=%d location=%p object=%p\n", t, p, q));
		*(_ns5__InvalidActionConfigurationFault*)p = *(_ns5__InvalidActionConfigurationFault*)q;
		break;
	case SOAP_TYPE__ns5__ActionConfigurationNotFoundFault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns5__ActionConfigurationNotFoundFault type=%d location=%p object=%p\n", t, p, q));
		*(_ns5__ActionConfigurationNotFoundFault*)p = *(_ns5__ActionConfigurationNotFoundFault*)q;
		break;
	case SOAP_TYPE__ns5__RecipientTemplateNotFoundFault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns5__RecipientTemplateNotFoundFault type=%d location=%p object=%p\n", t, p, q));
		*(_ns5__RecipientTemplateNotFoundFault*)p = *(_ns5__RecipientTemplateNotFoundFault*)q;
		break;
	case SOAP_TYPE__ns5__ActionConfigurationIsInUseFault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns5__ActionConfigurationIsInUseFault type=%d location=%p object=%p\n", t, p, q));
		*(_ns5__ActionConfigurationIsInUseFault*)p = *(_ns5__ActionConfigurationIsInUseFault*)q;
		break;
	case SOAP_TYPE__ns5__InvalidConditionFilterFault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns5__InvalidConditionFilterFault type=%d location=%p object=%p\n", t, p, q));
		*(_ns5__InvalidConditionFilterFault*)p = *(_ns5__InvalidConditionFilterFault*)q;
		break;
	case SOAP_TYPE__ns5__InsufficientActivationRuleFault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns5__InsufficientActivationRuleFault type=%d location=%p object=%p\n", t, p, q));
		*(_ns5__InsufficientActivationRuleFault*)p = *(_ns5__InsufficientActivationRuleFault*)q;
		break;
	case SOAP_TYPE__ns5__ActionRuleNotFoundFault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns5__ActionRuleNotFoundFault type=%d location=%p object=%p\n", t, p, q));
		*(_ns5__ActionRuleNotFoundFault*)p = *(_ns5__ActionRuleNotFoundFault*)q;
		break;
	case SOAP_TYPE__ns5__InvalidActivationTimeoutFault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns5__InvalidActivationTimeoutFault type=%d location=%p object=%p\n", t, p, q));
		*(_ns5__InvalidActivationTimeoutFault*)p = *(_ns5__InvalidActivationTimeoutFault*)q;
		break;
	case SOAP_TYPE_ns6__EndpointReferenceType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns6__EndpointReferenceType type=%d location=%p object=%p\n", t, p, q));
		*(ns6__EndpointReferenceType*)p = *(ns6__EndpointReferenceType*)q;
		break;
	case SOAP_TYPE_ns6__ReferenceParametersType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns6__ReferenceParametersType type=%d location=%p object=%p\n", t, p, q));
		*(ns6__ReferenceParametersType*)p = *(ns6__ReferenceParametersType*)q;
		break;
	case SOAP_TYPE_ns6__MetadataType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns6__MetadataType type=%d location=%p object=%p\n", t, p, q));
		*(ns6__MetadataType*)p = *(ns6__MetadataType*)q;
		break;
	case SOAP_TYPE_ns6__ProblemActionType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns6__ProblemActionType type=%d location=%p object=%p\n", t, p, q));
		*(ns6__ProblemActionType*)p = *(ns6__ProblemActionType*)q;
		break;
	case SOAP_TYPE_ns1__ICalendar:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__ICalendar type=%d location=%p object=%p\n", t, p, q));
		*(ns1__ICalendar*)p = *(ns1__ICalendar*)q;
		break;
	case SOAP_TYPE__ns2__TopicNamespaceType_Topic:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns2__TopicNamespaceType_Topic type=%d location=%p object=%p\n", t, p, q));
		*(_ns2__TopicNamespaceType_Topic*)p = *(_ns2__TopicNamespaceType_Topic*)q;
		break;
	case SOAP_TYPE_ns2__TopicNamespaceType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__TopicNamespaceType type=%d location=%p object=%p\n", t, p, q));
		*(ns2__TopicNamespaceType*)p = *(ns2__TopicNamespaceType*)q;
		break;
	case SOAP_TYPE_ns2__TopicType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__TopicType type=%d location=%p object=%p\n", t, p, q));
		*(ns2__TopicType*)p = *(ns2__TopicType*)q;
		break;
	case SOAP_TYPE_ns2__TopicSetType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__TopicSetType type=%d location=%p object=%p\n", t, p, q));
		*(ns2__TopicSetType*)p = *(ns2__TopicSetType*)q;
		break;
	case SOAP_TYPE_ns3__SubscribeCreationFailedFaultType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__SubscribeCreationFailedFaultType type=%d location=%p object=%p\n", t, p, q));
		*(ns3__SubscribeCreationFailedFaultType*)p = *(ns3__SubscribeCreationFailedFaultType*)q;
		break;
	case SOAP_TYPE_ns3__InvalidFilterFaultType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__InvalidFilterFaultType type=%d location=%p object=%p\n", t, p, q));
		*(ns3__InvalidFilterFaultType*)p = *(ns3__InvalidFilterFaultType*)q;
		break;
	case SOAP_TYPE_ns3__TopicExpressionDialectUnknownFaultType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__TopicExpressionDialectUnknownFaultType type=%d location=%p object=%p\n", t, p, q));
		*(ns3__TopicExpressionDialectUnknownFaultType*)p = *(ns3__TopicExpressionDialectUnknownFaultType*)q;
		break;
	case SOAP_TYPE_ns3__InvalidTopicExpressionFaultType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__InvalidTopicExpressionFaultType type=%d location=%p object=%p\n", t, p, q));
		*(ns3__InvalidTopicExpressionFaultType*)p = *(ns3__InvalidTopicExpressionFaultType*)q;
		break;
	case SOAP_TYPE_ns3__TopicNotSupportedFaultType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__TopicNotSupportedFaultType type=%d location=%p object=%p\n", t, p, q));
		*(ns3__TopicNotSupportedFaultType*)p = *(ns3__TopicNotSupportedFaultType*)q;
		break;
	case SOAP_TYPE_ns3__MultipleTopicsSpecifiedFaultType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__MultipleTopicsSpecifiedFaultType type=%d location=%p object=%p\n", t, p, q));
		*(ns3__MultipleTopicsSpecifiedFaultType*)p = *(ns3__MultipleTopicsSpecifiedFaultType*)q;
		break;
	case SOAP_TYPE_ns3__InvalidProducerPropertiesExpressionFaultType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__InvalidProducerPropertiesExpressionFaultType type=%d location=%p object=%p\n", t, p, q));
		*(ns3__InvalidProducerPropertiesExpressionFaultType*)p = *(ns3__InvalidProducerPropertiesExpressionFaultType*)q;
		break;
	case SOAP_TYPE_ns3__InvalidMessageContentExpressionFaultType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__InvalidMessageContentExpressionFaultType type=%d location=%p object=%p\n", t, p, q));
		*(ns3__InvalidMessageContentExpressionFaultType*)p = *(ns3__InvalidMessageContentExpressionFaultType*)q;
		break;
	case SOAP_TYPE_ns3__UnrecognizedPolicyRequestFaultType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__UnrecognizedPolicyRequestFaultType type=%d location=%p object=%p\n", t, p, q));
		*(ns3__UnrecognizedPolicyRequestFaultType*)p = *(ns3__UnrecognizedPolicyRequestFaultType*)q;
		break;
	case SOAP_TYPE_ns3__UnsupportedPolicyRequestFaultType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__UnsupportedPolicyRequestFaultType type=%d location=%p object=%p\n", t, p, q));
		*(ns3__UnsupportedPolicyRequestFaultType*)p = *(ns3__UnsupportedPolicyRequestFaultType*)q;
		break;
	case SOAP_TYPE_ns3__NotifyMessageNotSupportedFaultType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__NotifyMessageNotSupportedFaultType type=%d location=%p object=%p\n", t, p, q));
		*(ns3__NotifyMessageNotSupportedFaultType*)p = *(ns3__NotifyMessageNotSupportedFaultType*)q;
		break;
	case SOAP_TYPE_ns3__UnacceptableInitialTerminationTimeFaultType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__UnacceptableInitialTerminationTimeFaultType type=%d location=%p object=%p\n", t, p, q));
		*(ns3__UnacceptableInitialTerminationTimeFaultType*)p = *(ns3__UnacceptableInitialTerminationTimeFaultType*)q;
		break;
	case SOAP_TYPE_ns3__NoCurrentMessageOnTopicFaultType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__NoCurrentMessageOnTopicFaultType type=%d location=%p object=%p\n", t, p, q));
		*(ns3__NoCurrentMessageOnTopicFaultType*)p = *(ns3__NoCurrentMessageOnTopicFaultType*)q;
		break;
	case SOAP_TYPE_ns3__UnableToGetMessagesFaultType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__UnableToGetMessagesFaultType type=%d location=%p object=%p\n", t, p, q));
		*(ns3__UnableToGetMessagesFaultType*)p = *(ns3__UnableToGetMessagesFaultType*)q;
		break;
	case SOAP_TYPE_ns3__UnableToDestroyPullPointFaultType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__UnableToDestroyPullPointFaultType type=%d location=%p object=%p\n", t, p, q));
		*(ns3__UnableToDestroyPullPointFaultType*)p = *(ns3__UnableToDestroyPullPointFaultType*)q;
		break;
	case SOAP_TYPE_ns3__UnableToCreatePullPointFaultType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__UnableToCreatePullPointFaultType type=%d location=%p object=%p\n", t, p, q));
		*(ns3__UnableToCreatePullPointFaultType*)p = *(ns3__UnableToCreatePullPointFaultType*)q;
		break;
	case SOAP_TYPE_ns3__UnacceptableTerminationTimeFaultType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__UnacceptableTerminationTimeFaultType type=%d location=%p object=%p\n", t, p, q));
		*(ns3__UnacceptableTerminationTimeFaultType*)p = *(ns3__UnacceptableTerminationTimeFaultType*)q;
		break;
	case SOAP_TYPE_ns3__UnableToDestroySubscriptionFaultType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__UnableToDestroySubscriptionFaultType type=%d location=%p object=%p\n", t, p, q));
		*(ns3__UnableToDestroySubscriptionFaultType*)p = *(ns3__UnableToDestroySubscriptionFaultType*)q;
		break;
	case SOAP_TYPE_ns3__PauseFailedFaultType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__PauseFailedFaultType type=%d location=%p object=%p\n", t, p, q));
		*(ns3__PauseFailedFaultType*)p = *(ns3__PauseFailedFaultType*)q;
		break;
	case SOAP_TYPE_ns3__ResumeFailedFaultType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__ResumeFailedFaultType type=%d location=%p object=%p\n", t, p, q));
		*(ns3__ResumeFailedFaultType*)p = *(ns3__ResumeFailedFaultType*)q;
		break;
	case SOAP_TYPE_ns6__RelatesToType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns6__RelatesToType type=%d location=%p object=%p\n", t, p, q));
		*(ns6__RelatesToType*)p = *(ns6__RelatesToType*)q;
		break;
	case SOAP_TYPE_ns6__AttributedURIType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns6__AttributedURIType type=%d location=%p object=%p\n", t, p, q));
		*(ns6__AttributedURIType*)p = *(ns6__AttributedURIType*)q;
		break;
	case SOAP_TYPE_ns6__AttributedUnsignedLongType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns6__AttributedUnsignedLongType type=%d location=%p object=%p\n", t, p, q));
		*(ns6__AttributedUnsignedLongType*)p = *(ns6__AttributedUnsignedLongType*)q;
		break;
	case SOAP_TYPE_ns6__AttributedQNameType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns6__AttributedQNameType type=%d location=%p object=%p\n", t, p, q));
		*(ns6__AttributedQNameType*)p = *(ns6__AttributedQNameType*)q;
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Detail type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
		break;
#endif
	case SOAP_TYPE___ns1__GetEventInstances:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetEventInstances type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetEventInstances*)p = *(struct __ns1__GetEventInstances*)q;
		break;
	case SOAP_TYPE___ns1__AddScheduledEvent:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__AddScheduledEvent type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__AddScheduledEvent*)p = *(struct __ns1__AddScheduledEvent*)q;
		break;
	case SOAP_TYPE___ns1__RemoveScheduledEvent:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__RemoveScheduledEvent type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__RemoveScheduledEvent*)p = *(struct __ns1__RemoveScheduledEvent*)q;
		break;
	case SOAP_TYPE___ns1__GetScheduledEvents:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetScheduledEvents type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetScheduledEvents*)p = *(struct __ns1__GetScheduledEvents*)q;
		break;
	case SOAP_TYPE___ns1__ChangeVirtualInputState:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__ChangeVirtualInputState type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__ChangeVirtualInputState*)p = *(struct __ns1__ChangeVirtualInputState*)q;
		break;
	case SOAP_TYPE___ns5__GetActionTemplates:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns5__GetActionTemplates type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns5__GetActionTemplates*)p = *(struct __ns5__GetActionTemplates*)q;
		break;
	case SOAP_TYPE___ns5__AddActionConfiguration:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns5__AddActionConfiguration type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns5__AddActionConfiguration*)p = *(struct __ns5__AddActionConfiguration*)q;
		break;
	case SOAP_TYPE___ns5__RemoveActionConfiguration:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns5__RemoveActionConfiguration type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns5__RemoveActionConfiguration*)p = *(struct __ns5__RemoveActionConfiguration*)q;
		break;
	case SOAP_TYPE___ns5__GetActionConfigurations:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns5__GetActionConfigurations type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns5__GetActionConfigurations*)p = *(struct __ns5__GetActionConfigurations*)q;
		break;
	case SOAP_TYPE___ns5__GetRecipientTemplates:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns5__GetRecipientTemplates type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns5__GetRecipientTemplates*)p = *(struct __ns5__GetRecipientTemplates*)q;
		break;
	case SOAP_TYPE___ns5__AddRecipientConfiguration:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns5__AddRecipientConfiguration type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns5__AddRecipientConfiguration*)p = *(struct __ns5__AddRecipientConfiguration*)q;
		break;
	case SOAP_TYPE___ns5__RemoveRecipientConfiguration:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns5__RemoveRecipientConfiguration type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns5__RemoveRecipientConfiguration*)p = *(struct __ns5__RemoveRecipientConfiguration*)q;
		break;
	case SOAP_TYPE___ns5__GetRecipientConfigurations:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns5__GetRecipientConfigurations type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns5__GetRecipientConfigurations*)p = *(struct __ns5__GetRecipientConfigurations*)q;
		break;
	case SOAP_TYPE___ns5__AddActionRule:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns5__AddActionRule type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns5__AddActionRule*)p = *(struct __ns5__AddActionRule*)q;
		break;
	case SOAP_TYPE___ns5__GetActionRules:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns5__GetActionRules type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns5__GetActionRules*)p = *(struct __ns5__GetActionRules*)q;
		break;
	case SOAP_TYPE___ns5__RemoveActionRule:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns5__RemoveActionRule type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns5__RemoveActionRule*)p = *(struct __ns5__RemoveActionRule*)q;
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Header type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Code type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Reason type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Fault type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
		break;
#endif
	case SOAP_TYPE_xsd__anyType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct soap_dom_element type=%d location=%p object=%p\n", t, p, q));
		*(struct soap_dom_element*)p = *(struct soap_dom_element*)q;
		break;
	case SOAP_TYPE_xsd__anyAttribute:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct soap_dom_attribute type=%d location=%p object=%p\n", t, p, q));
		*(struct soap_dom_attribute*)p = *(struct soap_dom_attribute*)q;
		break;
	case SOAP_TYPE_xsd__QName:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_xsd__NCName:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_xsd__anyURI:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_xsd__duration:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_xsd__integer:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_xsd__nonNegativeInteger:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_xsd__token:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE__xml__lang:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_ns3__AbsoluteOrRelativeTimeType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_ns6__RelationshipTypeOpenEnum:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_ns6__FaultCodesOpenEnumType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_ns2__FullTopicExpression:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_ns2__ConcreteTopicExpression:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_ns2__SimpleTopicExpression:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", t, tt));
	}
}
#ifdef WIN32
#pragma warning(pop)
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	a = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return a;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_new_byte(struct soap *soap, int n)
{
	char *a = static_cast<char *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(char)));
	for (char *p = a; p && n--; ++p)
		soap_default_byte(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	if (soap_out_byte(soap, tag ? tag : "byte", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	a = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return a;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_new_int(struct soap *soap, int n)
{
	int *a = static_cast<int *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(int)));
	for (int *p = a; p && n--; ++p)
		soap_default_int(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	if (soap_out_int(soap, tag ? tag : "int", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ULONG64(struct soap *soap, const char *tag, int id, const ULONG64 *a, const char *type)
{
	return soap_outULONG64(soap, tag, id, a, type, SOAP_TYPE_ULONG64);
}

SOAP_FMAC3 ULONG64 * SOAP_FMAC4 soap_in_ULONG64(struct soap *soap, const char *tag, ULONG64 *a, const char *type)
{
	a = soap_inULONG64(soap, tag, a, type, SOAP_TYPE_ULONG64);
	return a;
}

SOAP_FMAC3 ULONG64 * SOAP_FMAC4 soap_new_ULONG64(struct soap *soap, int n)
{
	ULONG64 *a = static_cast<ULONG64 *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(ULONG64)));
	for (ULONG64 *p = a; p && n--; ++p)
		soap_default_ULONG64(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ULONG64(struct soap *soap, const ULONG64 *a, const char *tag, const char *type)
{
	if (soap_out_ULONG64(soap, tag ? tag : "unsignedLong", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ULONG64 * SOAP_FMAC4 soap_get_ULONG64(struct soap *soap, ULONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ULONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dateTime(struct soap *soap, const char *tag, int id, const time_t *a, const char *type)
{
	return soap_outdateTime(soap, tag, id, a, type, SOAP_TYPE_dateTime);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_in_dateTime(struct soap *soap, const char *tag, time_t *a, const char *type)
{
	a = soap_indateTime(soap, tag, a, type, SOAP_TYPE_dateTime);
	return a;
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_new_dateTime(struct soap *soap, int n)
{
	time_t *a = static_cast<time_t *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(time_t)));
	for (time_t *p = a; p && n--; ++p)
		soap_default_dateTime(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dateTime(struct soap *soap, const time_t *a, const char *tag, const char *type)
{
	if (soap_out_dateTime(soap, tag ? tag : "dateTime", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_get_dateTime(struct soap *soap, time_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_dateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (LONG64)false, "false" },
	{ (LONG64)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{
	(void)soap; /* appease -Wall -Werror */
	return soap_code_str(soap_codes_bool, n != 0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2bool(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bool, SOAP_TYPE_bool, sizeof(bool), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_new_bool(struct soap *soap, int n)
{
	bool *a = static_cast<bool *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(bool)));
	for (bool *p = a; p && n--; ++p)
		soap_default_bool(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	if (soap_out_bool(soap, tag ? tag : "boolean", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_ns6__FaultCodesType[] =
{	{ (LONG64)ns6__FaultCodesType::ns6__InvalidAddressingHeader, "ns6:InvalidAddressingHeader" },
	{ (LONG64)ns6__FaultCodesType::ns6__InvalidAddress, "ns6:InvalidAddress" },
	{ (LONG64)ns6__FaultCodesType::ns6__InvalidEPR, "ns6:InvalidEPR" },
	{ (LONG64)ns6__FaultCodesType::ns6__InvalidCardinality, "ns6:InvalidCardinality" },
	{ (LONG64)ns6__FaultCodesType::ns6__MissingAddressInEPR, "ns6:MissingAddressInEPR" },
	{ (LONG64)ns6__FaultCodesType::ns6__DuplicateMessageID, "ns6:DuplicateMessageID" },
	{ (LONG64)ns6__FaultCodesType::ns6__ActionMismatch, "ns6:ActionMismatch" },
	{ (LONG64)ns6__FaultCodesType::ns6__MessageAddressingHeaderRequired, "ns6:MessageAddressingHeaderRequired" },
	{ (LONG64)ns6__FaultCodesType::ns6__DestinationUnreachable, "ns6:DestinationUnreachable" },
	{ (LONG64)ns6__FaultCodesType::ns6__ActionNotSupported, "ns6:ActionNotSupported" },
	{ (LONG64)ns6__FaultCodesType::ns6__EndpointUnavailable, "ns6:EndpointUnavailable" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns6__FaultCodesType2s(struct soap *soap, ns6__FaultCodesType n)
{	const char *s = soap_code_str(soap_codes_ns6__FaultCodesType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__FaultCodesType(struct soap *soap, const char *tag, int id, const ns6__FaultCodesType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__FaultCodesType), type) || soap_send(soap, soap_ns6__FaultCodesType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns6__FaultCodesType(struct soap *soap, const char *s, ns6__FaultCodesType *a)
{
	const struct soap_code_map *map;
	char *t;
	if (!s)
		return soap->error;
	soap_s2QName(soap, s, &t, 0, -1, NULL);
	map = soap_code(soap_codes_ns6__FaultCodesType, t);
	if (map)
		*a = (ns6__FaultCodesType)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 10)
			return soap->error = SOAP_TYPE;
		*a = (ns6__FaultCodesType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 ns6__FaultCodesType * SOAP_FMAC4 soap_in_ns6__FaultCodesType(struct soap *soap, const char *tag, ns6__FaultCodesType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (ns6__FaultCodesType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__FaultCodesType, sizeof(ns6__FaultCodesType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2ns6__FaultCodesType(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (ns6__FaultCodesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__FaultCodesType, SOAP_TYPE_ns6__FaultCodesType, sizeof(ns6__FaultCodesType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns6__FaultCodesType * SOAP_FMAC4 soap_new_ns6__FaultCodesType(struct soap *soap, int n)
{
	ns6__FaultCodesType *a = static_cast<ns6__FaultCodesType *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(ns6__FaultCodesType)));
	for (ns6__FaultCodesType *p = a; p && n--; ++p)
		soap_default_ns6__FaultCodesType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__FaultCodesType(struct soap *soap, const ns6__FaultCodesType *a, const char *tag, const char *type)
{
	if (soap_out_ns6__FaultCodesType(soap, tag ? tag : "ns6:FaultCodesType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns6__FaultCodesType * SOAP_FMAC4 soap_get_ns6__FaultCodesType(struct soap *soap, ns6__FaultCodesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__FaultCodesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_ns6__RelationshipType[] =
{	{ (LONG64)ns6__RelationshipType::http_x003a_x002f_x002fwww_x002ew3_x002eorg_x002f2005_x002f08_x002faddressing_x002freply, "http://www.w3.org/2005/08/addressing/reply" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns6__RelationshipType2s(struct soap *soap, ns6__RelationshipType n)
{	const char *s = soap_code_str(soap_codes_ns6__RelationshipType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__RelationshipType(struct soap *soap, const char *tag, int id, const ns6__RelationshipType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__RelationshipType), type) || soap_send(soap, soap_ns6__RelationshipType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns6__RelationshipType(struct soap *soap, const char *s, ns6__RelationshipType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns6__RelationshipType, s);
	if (map)
		*a = (ns6__RelationshipType)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 0)
			return soap->error = SOAP_TYPE;
		*a = (ns6__RelationshipType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 ns6__RelationshipType * SOAP_FMAC4 soap_in_ns6__RelationshipType(struct soap *soap, const char *tag, ns6__RelationshipType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (ns6__RelationshipType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__RelationshipType, sizeof(ns6__RelationshipType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2ns6__RelationshipType(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (ns6__RelationshipType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__RelationshipType, SOAP_TYPE_ns6__RelationshipType, sizeof(ns6__RelationshipType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns6__RelationshipType * SOAP_FMAC4 soap_new_ns6__RelationshipType(struct soap *soap, int n)
{
	ns6__RelationshipType *a = static_cast<ns6__RelationshipType *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(ns6__RelationshipType)));
	for (ns6__RelationshipType *p = a; p && n--; ++p)
		soap_default_ns6__RelationshipType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__RelationshipType(struct soap *soap, const ns6__RelationshipType *a, const char *tag, const char *type)
{
	if (soap_out_ns6__RelationshipType(soap, tag ? tag : "ns6:RelationshipType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns6__RelationshipType * SOAP_FMAC4 soap_get_ns6__RelationshipType(struct soap *soap, ns6__RelationshipType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__RelationshipType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_ns1__ScheduledType[] =
{	{ (LONG64)ns1__ScheduledType::Interval, "Interval" },
	{ (LONG64)ns1__ScheduledType::Pulse, "Pulse" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__ScheduledType2s(struct soap *soap, ns1__ScheduledType n)
{	const char *s = soap_code_str(soap_codes_ns1__ScheduledType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ScheduledType(struct soap *soap, const char *tag, int id, const ns1__ScheduledType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ScheduledType), type) || soap_send(soap, soap_ns1__ScheduledType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__ScheduledType(struct soap *soap, const char *s, ns1__ScheduledType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__ScheduledType, s);
	if (map)
		*a = (ns1__ScheduledType)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (ns1__ScheduledType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 ns1__ScheduledType * SOAP_FMAC4 soap_in_ns1__ScheduledType(struct soap *soap, const char *tag, ns1__ScheduledType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (ns1__ScheduledType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ScheduledType, sizeof(ns1__ScheduledType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2ns1__ScheduledType(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (ns1__ScheduledType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ScheduledType, SOAP_TYPE_ns1__ScheduledType, sizeof(ns1__ScheduledType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns1__ScheduledType * SOAP_FMAC4 soap_new_ns1__ScheduledType(struct soap *soap, int n)
{
	ns1__ScheduledType *a = static_cast<ns1__ScheduledType *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(ns1__ScheduledType)));
	for (ns1__ScheduledType *p = a; p && n--; ++p)
		soap_default_ns1__ScheduledType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ScheduledType(struct soap *soap, const ns1__ScheduledType *a, const char *tag, const char *type)
{
	if (soap_out_ns1__ScheduledType(soap, tag ? tag : "ns1:ScheduledType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ScheduledType * SOAP_FMAC4 soap_get_ns1__ScheduledType(struct soap *soap, ns1__ScheduledType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ScheduledType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns2__TopicNamespaceType_Topic::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->_ns2__TopicNamespaceType_Topic::documentation = NULL;
	soap_default_xsd__anyAttribute(soap, &this->_ns2__TopicNamespaceType_Topic::__anyAttribute);
	this->_ns2__TopicNamespaceType_Topic::MessagePattern = NULL;
	soap_default_std__vectorTemplateOfPointerTons2__TopicType(soap, &this->_ns2__TopicNamespaceType_Topic::Topic);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->_ns2__TopicNamespaceType_Topic::__any);
	soap_default_xsd__NCName(soap, &this->_ns2__TopicNamespaceType_Topic::name);
	this->_ns2__TopicNamespaceType_Topic::messageTypes = NULL;
	this->_ns2__TopicNamespaceType_Topic::final_ = (bool)0;
	this->_ns2__TopicNamespaceType_Topic::parent = NULL;
}

void _ns2__TopicNamespaceType_Topic::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__Documentation(soap, &this->_ns2__TopicNamespaceType_Topic::documentation);
	soap_serialize_PointerTons2__QueryExpressionType(soap, &this->_ns2__TopicNamespaceType_Topic::MessagePattern);
	soap_serialize_std__vectorTemplateOfPointerTons2__TopicType(soap, &this->_ns2__TopicNamespaceType_Topic::Topic);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->_ns2__TopicNamespaceType_Topic::__any);
#endif
}

int _ns2__TopicNamespaceType_Topic::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns2__TopicNamespaceType_Topic(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__TopicNamespaceType_Topic(struct soap *soap, const char *tag, int id, const _ns2__TopicNamespaceType_Topic *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((_ns2__TopicNamespaceType_Topic*)a)->__anyAttribute, ""))
		return soap->error;
	soap_set_attr(soap, "name", soap_xsd__NCName2s(soap, ((_ns2__TopicNamespaceType_Topic*)a)->name), 1);
	if (((_ns2__TopicNamespaceType_Topic*)a)->messageTypes)
	{	soap_set_attr(soap, "messageTypes", soap_xsd__QName2s(soap, *((_ns2__TopicNamespaceType_Topic*)a)->messageTypes), 1);
	}
	soap_set_attr(soap, "final", soap_bool2s(soap, ((_ns2__TopicNamespaceType_Topic*)a)->final_), 1);
	if (((_ns2__TopicNamespaceType_Topic*)a)->parent)
	{	soap_set_attr(soap, "parent", soap_ns2__ConcreteTopicExpression2s(soap, *((_ns2__TopicNamespaceType_Topic*)a)->parent), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__TopicNamespaceType_Topic), type))
		return soap->error;
	if (soap_out_PointerTons2__Documentation(soap, "ns2:documentation", -1, &a->_ns2__TopicNamespaceType_Topic::documentation, ""))
		return soap->error;
	if (soap_out_PointerTons2__QueryExpressionType(soap, "ns2:MessagePattern", -1, &a->_ns2__TopicNamespaceType_Topic::MessagePattern, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__TopicType(soap, "ns2:Topic", -1, &a->_ns2__TopicNamespaceType_Topic::Topic, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->_ns2__TopicNamespaceType_Topic::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns2__TopicNamespaceType_Topic::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns2__TopicNamespaceType_Topic(soap, tag, this, type);
}

SOAP_FMAC3 _ns2__TopicNamespaceType_Topic * SOAP_FMAC4 soap_in__ns2__TopicNamespaceType_Topic(struct soap *soap, const char *tag, _ns2__TopicNamespaceType_Topic *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns2__TopicNamespaceType_Topic *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__TopicNamespaceType_Topic, sizeof(_ns2__TopicNamespaceType_Topic), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns2__TopicNamespaceType_Topic)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns2__TopicNamespaceType_Topic *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((_ns2__TopicNamespaceType_Topic*)a)->__anyAttribute, "xsd:anyAttribute");
	if (soap_s2xsd__NCName(soap, soap_attr_value(soap, "name", 5, 1), &((_ns2__TopicNamespaceType_Topic*)a)->name))
		return NULL;
	{
		const char *t = soap_attr_value(soap, "messageTypes", 2, 0);
		if (t)
		{
			if (!(((_ns2__TopicNamespaceType_Topic*)a)->messageTypes = soap_new_xsd__QName(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__QName(soap, t, ((_ns2__TopicNamespaceType_Topic*)a)->messageTypes))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2bool(soap, soap_attr_value(soap, "final", 5, 0), &((_ns2__TopicNamespaceType_Topic*)a)->final_))
		return NULL;
	{
		const char *t = soap_attr_value(soap, "parent", 5, 0);
		if (t)
		{
			if (!(((_ns2__TopicNamespaceType_Topic*)a)->parent = soap_new_ns2__ConcreteTopicExpression(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2ns2__ConcreteTopicExpression(soap, t, ((_ns2__TopicNamespaceType_Topic*)a)->parent))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_documentation1 = 1;
	size_t soap_flag_MessagePattern1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_documentation1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__Documentation(soap, "ns2:documentation", &a->_ns2__TopicNamespaceType_Topic::documentation, "ns2:Documentation"))
				{	soap_flag_documentation1--;
					continue;
				}
			}
			if (soap_flag_MessagePattern1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__QueryExpressionType(soap, "ns2:MessagePattern", &a->_ns2__TopicNamespaceType_Topic::MessagePattern, "ns2:QueryExpressionType"))
				{	soap_flag_MessagePattern1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons2__TopicType(soap, "ns2:Topic", &a->_ns2__TopicNamespaceType_Topic::Topic, "ns2:TopicType"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->_ns2__TopicNamespaceType_Topic::__any, "xsd:anyType"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns2__TopicNamespaceType_Topic *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__TopicNamespaceType_Topic, SOAP_TYPE__ns2__TopicNamespaceType_Topic, sizeof(_ns2__TopicNamespaceType_Topic), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns2__TopicNamespaceType_Topic * SOAP_FMAC2 soap_instantiate__ns2__TopicNamespaceType_Topic(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns2__TopicNamespaceType_Topic(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns2__TopicNamespaceType_Topic *p;
	size_t k = sizeof(_ns2__TopicNamespaceType_Topic);
	if (n < 0)
	{	p = SOAP_NEW(_ns2__TopicNamespaceType_Topic);
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns2__TopicNamespaceType_Topic, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns2__TopicNamespaceType_Topic location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns2__TopicNamespaceType_Topic, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns2__TopicNamespaceType_Topic::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns2__TopicNamespaceType_Topic(soap, tag ? tag : "ns2:TopicNamespaceType-Topic", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns2__TopicNamespaceType_Topic::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns2__TopicNamespaceType_Topic(soap, this, tag, type);
}

SOAP_FMAC3 _ns2__TopicNamespaceType_Topic * SOAP_FMAC4 soap_get__ns2__TopicNamespaceType_Topic(struct soap *soap, _ns2__TopicNamespaceType_Topic *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__TopicNamespaceType_Topic(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns4__BaseFaultType_FaultCause::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &this->_ns4__BaseFaultType_FaultCause::__any);
}

void _ns4__BaseFaultType_FaultCause::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__anyType(soap, &this->_ns4__BaseFaultType_FaultCause::__any);
#endif
}

int _ns4__BaseFaultType_FaultCause::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns4__BaseFaultType_FaultCause(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__BaseFaultType_FaultCause(struct soap *soap, const char *tag, int id, const _ns4__BaseFaultType_FaultCause *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns4__BaseFaultType_FaultCause), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-any", -1, &a->_ns4__BaseFaultType_FaultCause::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns4__BaseFaultType_FaultCause::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns4__BaseFaultType_FaultCause(soap, tag, this, type);
}

SOAP_FMAC3 _ns4__BaseFaultType_FaultCause * SOAP_FMAC4 soap_in__ns4__BaseFaultType_FaultCause(struct soap *soap, const char *tag, _ns4__BaseFaultType_FaultCause *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns4__BaseFaultType_FaultCause *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__BaseFaultType_FaultCause, sizeof(_ns4__BaseFaultType_FaultCause), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns4__BaseFaultType_FaultCause)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns4__BaseFaultType_FaultCause *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___any1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__anyType(soap, "-any", &a->_ns4__BaseFaultType_FaultCause::__any, "xsd:anyType"))
				{	soap_flag___any1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns4__BaseFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__BaseFaultType_FaultCause, SOAP_TYPE__ns4__BaseFaultType_FaultCause, sizeof(_ns4__BaseFaultType_FaultCause), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns4__BaseFaultType_FaultCause * SOAP_FMAC2 soap_instantiate__ns4__BaseFaultType_FaultCause(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns4__BaseFaultType_FaultCause(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns4__BaseFaultType_FaultCause *p;
	size_t k = sizeof(_ns4__BaseFaultType_FaultCause);
	if (n < 0)
	{	p = SOAP_NEW(_ns4__BaseFaultType_FaultCause);
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns4__BaseFaultType_FaultCause, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns4__BaseFaultType_FaultCause location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns4__BaseFaultType_FaultCause, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns4__BaseFaultType_FaultCause::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns4__BaseFaultType_FaultCause(soap, tag ? tag : "ns4:BaseFaultType-FaultCause", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns4__BaseFaultType_FaultCause::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns4__BaseFaultType_FaultCause(soap, this, tag, type);
}

SOAP_FMAC3 _ns4__BaseFaultType_FaultCause * SOAP_FMAC4 soap_get__ns4__BaseFaultType_FaultCause(struct soap *soap, _ns4__BaseFaultType_FaultCause *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns4__BaseFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns4__BaseFaultType_Description::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__string(soap, &this->_ns4__BaseFaultType_Description::__item);
	this->_ns4__BaseFaultType_Description::xml__lang = NULL;
}

void _ns4__BaseFaultType_Description::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_ns4__BaseFaultType_Description::__item, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns4__BaseFaultType_Description::__item);
#endif
}

int _ns4__BaseFaultType_Description::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns4__BaseFaultType_Description(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__BaseFaultType_Description(struct soap *soap, const char *tag, int id, const _ns4__BaseFaultType_Description *a, const char *type)
{
	if (((_ns4__BaseFaultType_Description*)a)->xml__lang)
	{	soap_set_attr(soap, "xml:lang", soap__xml__lang2s(soap, *((_ns4__BaseFaultType_Description*)a)->xml__lang), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_std__string(soap, tag, id, &a->_ns4__BaseFaultType_Description::__item, "");
}

void *_ns4__BaseFaultType_Description::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns4__BaseFaultType_Description(soap, tag, this, type);
}

SOAP_FMAC3 _ns4__BaseFaultType_Description * SOAP_FMAC4 soap_in__ns4__BaseFaultType_Description(struct soap *soap, const char *tag, _ns4__BaseFaultType_Description *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (_ns4__BaseFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__BaseFaultType_Description, sizeof(_ns4__BaseFaultType_Description), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns4__BaseFaultType_Description)
		return (_ns4__BaseFaultType_Description *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "xml:lang", 1, 0);
		if (t)
		{
			if (!(((_ns4__BaseFaultType_Description*)a)->xml__lang = soap_new__xml__lang(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2_xml__lang(soap, t, ((_ns4__BaseFaultType_Description*)a)->xml__lang))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (!soap_in_std__string(soap, tag, &a->_ns4__BaseFaultType_Description::__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC1 _ns4__BaseFaultType_Description * SOAP_FMAC2 soap_instantiate__ns4__BaseFaultType_Description(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns4__BaseFaultType_Description(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns4__BaseFaultType_Description *p;
	size_t k = sizeof(_ns4__BaseFaultType_Description);
	if (n < 0)
	{	p = SOAP_NEW(_ns4__BaseFaultType_Description);
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns4__BaseFaultType_Description, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns4__BaseFaultType_Description location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns4__BaseFaultType_Description, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns4__BaseFaultType_Description::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns4__BaseFaultType_Description(soap, tag ? tag : "ns4:BaseFaultType-Description", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns4__BaseFaultType_Description::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns4__BaseFaultType_Description(soap, this, tag, type);
}

SOAP_FMAC3 _ns4__BaseFaultType_Description * SOAP_FMAC4 soap_get__ns4__BaseFaultType_Description(struct soap *soap, _ns4__BaseFaultType_Description *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns4__BaseFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns4__BaseFaultType_ErrorCode::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &this->_ns4__BaseFaultType_ErrorCode::dialect);
	soap_default_xsd__anyType(soap, &this->_ns4__BaseFaultType_ErrorCode::__mixed);
}

void _ns4__BaseFaultType_ErrorCode::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__anyType(soap, &this->_ns4__BaseFaultType_ErrorCode::__mixed);
#endif
}

int _ns4__BaseFaultType_ErrorCode::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns4__BaseFaultType_ErrorCode(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__BaseFaultType_ErrorCode(struct soap *soap, const char *tag, int id, const _ns4__BaseFaultType_ErrorCode *a, const char *type)
{
	soap_set_attr(soap, "dialect", soap_xsd__anyURI2s(soap, ((_ns4__BaseFaultType_ErrorCode*)a)->dialect), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns4__BaseFaultType_ErrorCode), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-mixed", -1, &a->_ns4__BaseFaultType_ErrorCode::__mixed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns4__BaseFaultType_ErrorCode::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns4__BaseFaultType_ErrorCode(soap, tag, this, type);
}

SOAP_FMAC3 _ns4__BaseFaultType_ErrorCode * SOAP_FMAC4 soap_in__ns4__BaseFaultType_ErrorCode(struct soap *soap, const char *tag, _ns4__BaseFaultType_ErrorCode *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns4__BaseFaultType_ErrorCode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__BaseFaultType_ErrorCode, sizeof(_ns4__BaseFaultType_ErrorCode), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns4__BaseFaultType_ErrorCode)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns4__BaseFaultType_ErrorCode *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "dialect", 4, 1), &((_ns4__BaseFaultType_ErrorCode*)a)->dialect))
		return NULL;
	size_t soap_flag___mixed1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___mixed1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__anyType(soap, "-mixed", &a->_ns4__BaseFaultType_ErrorCode::__mixed, "xsd:anyType"))
				{	soap_flag___mixed1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns4__BaseFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__BaseFaultType_ErrorCode, SOAP_TYPE__ns4__BaseFaultType_ErrorCode, sizeof(_ns4__BaseFaultType_ErrorCode), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns4__BaseFaultType_ErrorCode * SOAP_FMAC2 soap_instantiate__ns4__BaseFaultType_ErrorCode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns4__BaseFaultType_ErrorCode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns4__BaseFaultType_ErrorCode *p;
	size_t k = sizeof(_ns4__BaseFaultType_ErrorCode);
	if (n < 0)
	{	p = SOAP_NEW(_ns4__BaseFaultType_ErrorCode);
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns4__BaseFaultType_ErrorCode, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns4__BaseFaultType_ErrorCode location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns4__BaseFaultType_ErrorCode, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns4__BaseFaultType_ErrorCode::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns4__BaseFaultType_ErrorCode(soap, tag ? tag : "ns4:BaseFaultType-ErrorCode", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns4__BaseFaultType_ErrorCode::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns4__BaseFaultType_ErrorCode(soap, this, tag, type);
}

SOAP_FMAC3 _ns4__BaseFaultType_ErrorCode * SOAP_FMAC4 soap_get__ns4__BaseFaultType_ErrorCode(struct soap *soap, _ns4__BaseFaultType_ErrorCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns4__BaseFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns3__Subscribe_SubscriptionPolicy::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->_ns3__Subscribe_SubscriptionPolicy::__any);
}

void _ns3__Subscribe_SubscriptionPolicy::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->_ns3__Subscribe_SubscriptionPolicy::__any);
#endif
}

int _ns3__Subscribe_SubscriptionPolicy::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__Subscribe_SubscriptionPolicy(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__Subscribe_SubscriptionPolicy(struct soap *soap, const char *tag, int id, const _ns3__Subscribe_SubscriptionPolicy *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__Subscribe_SubscriptionPolicy), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->_ns3__Subscribe_SubscriptionPolicy::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns3__Subscribe_SubscriptionPolicy::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__Subscribe_SubscriptionPolicy(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__Subscribe_SubscriptionPolicy * SOAP_FMAC4 soap_in__ns3__Subscribe_SubscriptionPolicy(struct soap *soap, const char *tag, _ns3__Subscribe_SubscriptionPolicy *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__Subscribe_SubscriptionPolicy *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__Subscribe_SubscriptionPolicy, sizeof(_ns3__Subscribe_SubscriptionPolicy), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns3__Subscribe_SubscriptionPolicy)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns3__Subscribe_SubscriptionPolicy *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->_ns3__Subscribe_SubscriptionPolicy::__any, "xsd:anyType"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__Subscribe_SubscriptionPolicy *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__Subscribe_SubscriptionPolicy, SOAP_TYPE__ns3__Subscribe_SubscriptionPolicy, sizeof(_ns3__Subscribe_SubscriptionPolicy), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns3__Subscribe_SubscriptionPolicy * SOAP_FMAC2 soap_instantiate__ns3__Subscribe_SubscriptionPolicy(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__Subscribe_SubscriptionPolicy(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns3__Subscribe_SubscriptionPolicy *p;
	size_t k = sizeof(_ns3__Subscribe_SubscriptionPolicy);
	if (n < 0)
	{	p = SOAP_NEW(_ns3__Subscribe_SubscriptionPolicy);
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns3__Subscribe_SubscriptionPolicy, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns3__Subscribe_SubscriptionPolicy location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns3__Subscribe_SubscriptionPolicy, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns3__Subscribe_SubscriptionPolicy::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns3__Subscribe_SubscriptionPolicy(soap, tag ? tag : "ns3:Subscribe-SubscriptionPolicy", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__Subscribe_SubscriptionPolicy::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__Subscribe_SubscriptionPolicy(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__Subscribe_SubscriptionPolicy * SOAP_FMAC4 soap_get__ns3__Subscribe_SubscriptionPolicy(struct soap *soap, _ns3__Subscribe_SubscriptionPolicy *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__Subscribe_SubscriptionPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns3__NotificationMessageHolderType_Message::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &this->_ns3__NotificationMessageHolderType_Message::__any);
}

void _ns3__NotificationMessageHolderType_Message::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__anyType(soap, &this->_ns3__NotificationMessageHolderType_Message::__any);
#endif
}

int _ns3__NotificationMessageHolderType_Message::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__NotificationMessageHolderType_Message(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__NotificationMessageHolderType_Message(struct soap *soap, const char *tag, int id, const _ns3__NotificationMessageHolderType_Message *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__NotificationMessageHolderType_Message), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-any", -1, &a->_ns3__NotificationMessageHolderType_Message::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns3__NotificationMessageHolderType_Message::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__NotificationMessageHolderType_Message(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__NotificationMessageHolderType_Message * SOAP_FMAC4 soap_in__ns3__NotificationMessageHolderType_Message(struct soap *soap, const char *tag, _ns3__NotificationMessageHolderType_Message *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__NotificationMessageHolderType_Message *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__NotificationMessageHolderType_Message, sizeof(_ns3__NotificationMessageHolderType_Message), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns3__NotificationMessageHolderType_Message)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns3__NotificationMessageHolderType_Message *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___any1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__anyType(soap, "-any", &a->_ns3__NotificationMessageHolderType_Message::__any, "xsd:anyType"))
				{	soap_flag___any1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__NotificationMessageHolderType_Message *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__NotificationMessageHolderType_Message, SOAP_TYPE__ns3__NotificationMessageHolderType_Message, sizeof(_ns3__NotificationMessageHolderType_Message), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns3__NotificationMessageHolderType_Message * SOAP_FMAC2 soap_instantiate__ns3__NotificationMessageHolderType_Message(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__NotificationMessageHolderType_Message(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns3__NotificationMessageHolderType_Message *p;
	size_t k = sizeof(_ns3__NotificationMessageHolderType_Message);
	if (n < 0)
	{	p = SOAP_NEW(_ns3__NotificationMessageHolderType_Message);
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns3__NotificationMessageHolderType_Message, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns3__NotificationMessageHolderType_Message location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns3__NotificationMessageHolderType_Message, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns3__NotificationMessageHolderType_Message::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns3__NotificationMessageHolderType_Message(soap, tag ? tag : "ns3:NotificationMessageHolderType-Message", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__NotificationMessageHolderType_Message::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__NotificationMessageHolderType_Message(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__NotificationMessageHolderType_Message * SOAP_FMAC4 soap_get__ns3__NotificationMessageHolderType_Message(struct soap *soap, _ns3__NotificationMessageHolderType_Message *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__NotificationMessageHolderType_Message(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns6__FaultCodesType__::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_ns6__FaultCodesType(soap, &this->ns6__FaultCodesType__::__item);
}

void ns6__FaultCodesType__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns6__FaultCodesType__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__FaultCodesType__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__FaultCodesType__(struct soap *soap, const char *tag, int id, const ns6__FaultCodesType__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_ns6__FaultCodesType(soap, tag, id, &a->ns6__FaultCodesType__::__item, "");
}

void *ns6__FaultCodesType__::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__FaultCodesType__(soap, tag, this, type);
}

SOAP_FMAC3 ns6__FaultCodesType__ * SOAP_FMAC4 soap_in_ns6__FaultCodesType__(struct soap *soap, const char *tag, ns6__FaultCodesType__ *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns6__FaultCodesType__ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__FaultCodesType__, sizeof(ns6__FaultCodesType__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns6__FaultCodesType__)
		return (ns6__FaultCodesType__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_ns6__FaultCodesType(soap, tag, &a->ns6__FaultCodesType__::__item, "ns6:FaultCodesType"))
		return NULL;
	return a;
}

SOAP_FMAC1 ns6__FaultCodesType__ * SOAP_FMAC2 soap_instantiate_ns6__FaultCodesType__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__FaultCodesType__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns6__FaultCodesType__ *p;
	size_t k = sizeof(ns6__FaultCodesType__);
	if (n < 0)
	{	p = SOAP_NEW(ns6__FaultCodesType__);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns6__FaultCodesType__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns6__FaultCodesType__ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns6__FaultCodesType__, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns6__FaultCodesType__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns6__FaultCodesType__(soap, tag ? tag : "ns6:FaultCodesType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns6__FaultCodesType__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__FaultCodesType__(soap, this, tag, type);
}

SOAP_FMAC3 ns6__FaultCodesType__ * SOAP_FMAC4 soap_get_ns6__FaultCodesType__(struct soap *soap, ns6__FaultCodesType__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__FaultCodesType__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns6__RelationshipType__::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_ns6__RelationshipType(soap, &this->ns6__RelationshipType__::__item);
}

void ns6__RelationshipType__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns6__RelationshipType__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__RelationshipType__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__RelationshipType__(struct soap *soap, const char *tag, int id, const ns6__RelationshipType__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_ns6__RelationshipType(soap, tag, id, &a->ns6__RelationshipType__::__item, "");
}

void *ns6__RelationshipType__::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__RelationshipType__(soap, tag, this, type);
}

SOAP_FMAC3 ns6__RelationshipType__ * SOAP_FMAC4 soap_in_ns6__RelationshipType__(struct soap *soap, const char *tag, ns6__RelationshipType__ *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns6__RelationshipType__ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__RelationshipType__, sizeof(ns6__RelationshipType__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns6__RelationshipType__)
		return (ns6__RelationshipType__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_ns6__RelationshipType(soap, tag, &a->ns6__RelationshipType__::__item, "ns6:RelationshipType"))
		return NULL;
	return a;
}

SOAP_FMAC1 ns6__RelationshipType__ * SOAP_FMAC2 soap_instantiate_ns6__RelationshipType__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__RelationshipType__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns6__RelationshipType__ *p;
	size_t k = sizeof(ns6__RelationshipType__);
	if (n < 0)
	{	p = SOAP_NEW(ns6__RelationshipType__);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns6__RelationshipType__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns6__RelationshipType__ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns6__RelationshipType__, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns6__RelationshipType__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns6__RelationshipType__(soap, tag ? tag : "ns6:RelationshipType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns6__RelationshipType__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__RelationshipType__(soap, this, tag, type);
}

SOAP_FMAC3 ns6__RelationshipType__ * SOAP_FMAC4 soap_get_ns6__RelationshipType__(struct soap *soap, ns6__RelationshipType__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__RelationshipType__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__SimpleTopicExpression__::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_ns2__SimpleTopicExpression(soap, &this->ns2__SimpleTopicExpression__::__item);
}

void ns2__SimpleTopicExpression__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns2__SimpleTopicExpression(soap, &this->ns2__SimpleTopicExpression__::__item);
#endif
}

int ns2__SimpleTopicExpression__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__SimpleTopicExpression__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__SimpleTopicExpression__(struct soap *soap, const char *tag, int id, const ns2__SimpleTopicExpression__ *a, const char *type)
{
	std::string soap_tmp___item(soap_QName2s(soap, a->__item.c_str()));
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_ns2__SimpleTopicExpression(soap, tag, id, &soap_tmp___item, "");
}

void *ns2__SimpleTopicExpression__::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__SimpleTopicExpression__(soap, tag, this, type);
}

SOAP_FMAC3 ns2__SimpleTopicExpression__ * SOAP_FMAC4 soap_in_ns2__SimpleTopicExpression__(struct soap *soap, const char *tag, ns2__SimpleTopicExpression__ *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns2__SimpleTopicExpression__ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__SimpleTopicExpression__, sizeof(ns2__SimpleTopicExpression__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__SimpleTopicExpression__)
		return (ns2__SimpleTopicExpression__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_ns2__SimpleTopicExpression(soap, tag, &a->ns2__SimpleTopicExpression__::__item, "ns2:SimpleTopicExpression"))
		return NULL;
	return a;
}

SOAP_FMAC1 ns2__SimpleTopicExpression__ * SOAP_FMAC2 soap_instantiate_ns2__SimpleTopicExpression__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__SimpleTopicExpression__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__SimpleTopicExpression__ *p;
	size_t k = sizeof(ns2__SimpleTopicExpression__);
	if (n < 0)
	{	p = SOAP_NEW(ns2__SimpleTopicExpression__);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__SimpleTopicExpression__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__SimpleTopicExpression__ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__SimpleTopicExpression__, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__SimpleTopicExpression__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__SimpleTopicExpression__(soap, tag ? tag : "ns2:SimpleTopicExpression", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__SimpleTopicExpression__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__SimpleTopicExpression__(soap, this, tag, type);
}

SOAP_FMAC3 ns2__SimpleTopicExpression__ * SOAP_FMAC4 soap_get_ns2__SimpleTopicExpression__(struct soap *soap, ns2__SimpleTopicExpression__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__SimpleTopicExpression__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__ConcreteTopicExpression__::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_ns2__ConcreteTopicExpression(soap, &this->ns2__ConcreteTopicExpression__::__item);
}

void ns2__ConcreteTopicExpression__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns2__ConcreteTopicExpression__::__item, SOAP_TYPE_ns2__ConcreteTopicExpression);
	soap_serialize_ns2__ConcreteTopicExpression(soap, &this->ns2__ConcreteTopicExpression__::__item);
#endif
}

int ns2__ConcreteTopicExpression__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ConcreteTopicExpression__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ConcreteTopicExpression__(struct soap *soap, const char *tag, int id, const ns2__ConcreteTopicExpression__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_ns2__ConcreteTopicExpression(soap, tag, id, &a->ns2__ConcreteTopicExpression__::__item, "");
}

void *ns2__ConcreteTopicExpression__::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ConcreteTopicExpression__(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ConcreteTopicExpression__ * SOAP_FMAC4 soap_in_ns2__ConcreteTopicExpression__(struct soap *soap, const char *tag, ns2__ConcreteTopicExpression__ *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns2__ConcreteTopicExpression__ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ConcreteTopicExpression__, sizeof(ns2__ConcreteTopicExpression__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__ConcreteTopicExpression__)
		return (ns2__ConcreteTopicExpression__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_ns2__ConcreteTopicExpression(soap, tag, &a->ns2__ConcreteTopicExpression__::__item, "ns2:ConcreteTopicExpression"))
		return NULL;
	return a;
}

SOAP_FMAC1 ns2__ConcreteTopicExpression__ * SOAP_FMAC2 soap_instantiate_ns2__ConcreteTopicExpression__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ConcreteTopicExpression__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__ConcreteTopicExpression__ *p;
	size_t k = sizeof(ns2__ConcreteTopicExpression__);
	if (n < 0)
	{	p = SOAP_NEW(ns2__ConcreteTopicExpression__);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__ConcreteTopicExpression__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__ConcreteTopicExpression__ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__ConcreteTopicExpression__, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__ConcreteTopicExpression__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__ConcreteTopicExpression__(soap, tag ? tag : "ns2:ConcreteTopicExpression", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ConcreteTopicExpression__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ConcreteTopicExpression__(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ConcreteTopicExpression__ * SOAP_FMAC4 soap_get_ns2__ConcreteTopicExpression__(struct soap *soap, ns2__ConcreteTopicExpression__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ConcreteTopicExpression__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ConcreteTopicExpression(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns2__ConcreteTopicExpression), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_ns2__ConcreteTopicExpression(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns2__ConcreteTopicExpression, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 5, 0, -1, "(([\\i-[:]][\\c-[:]]*:)?[\\i-[:]][\\c-[:]]*)(/([\\i-[:]][\\c-[:]]*:)?[\\i-[:]][\\c-[:]]*)*")))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns2__ConcreteTopicExpression, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_ns2__ConcreteTopicExpression, SOAP_TYPE_ns2__ConcreteTopicExpression, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__ConcreteTopicExpression(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_ns2__ConcreteTopicExpression(soap, tag ? tag : "ns2:ConcreteTopicExpression", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_ns2__ConcreteTopicExpression(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ConcreteTopicExpression(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__FullTopicExpression__::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_ns2__FullTopicExpression(soap, &this->ns2__FullTopicExpression__::__item);
}

void ns2__FullTopicExpression__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns2__FullTopicExpression(soap, &this->ns2__FullTopicExpression__::__item);
#endif
}

int ns2__FullTopicExpression__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__FullTopicExpression__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__FullTopicExpression__(struct soap *soap, const char *tag, int id, const ns2__FullTopicExpression__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_ns2__FullTopicExpression(soap, tag, id, &a->ns2__FullTopicExpression__::__item, "");
}

void *ns2__FullTopicExpression__::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__FullTopicExpression__(soap, tag, this, type);
}

SOAP_FMAC3 ns2__FullTopicExpression__ * SOAP_FMAC4 soap_in_ns2__FullTopicExpression__(struct soap *soap, const char *tag, ns2__FullTopicExpression__ *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns2__FullTopicExpression__ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__FullTopicExpression__, sizeof(ns2__FullTopicExpression__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__FullTopicExpression__)
		return (ns2__FullTopicExpression__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_ns2__FullTopicExpression(soap, tag, &a->ns2__FullTopicExpression__::__item, "ns2:FullTopicExpression"))
		return NULL;
	return a;
}

SOAP_FMAC1 ns2__FullTopicExpression__ * SOAP_FMAC2 soap_instantiate_ns2__FullTopicExpression__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__FullTopicExpression__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__FullTopicExpression__ *p;
	size_t k = sizeof(ns2__FullTopicExpression__);
	if (n < 0)
	{	p = SOAP_NEW(ns2__FullTopicExpression__);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__FullTopicExpression__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__FullTopicExpression__ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__FullTopicExpression__, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__FullTopicExpression__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__FullTopicExpression__(soap, tag ? tag : "ns2:FullTopicExpression", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__FullTopicExpression__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__FullTopicExpression__(soap, this, tag, type);
}

SOAP_FMAC3 ns2__FullTopicExpression__ * SOAP_FMAC4 soap_get_ns2__FullTopicExpression__(struct soap *soap, ns2__FullTopicExpression__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__FullTopicExpression__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__FullTopicExpression(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns2__FullTopicExpression), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_ns2__FullTopicExpression(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns2__FullTopicExpression, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 5, 0, -1, "([\\i-[:]][\\c-[:]]*:)?(//)?([\\i-[:]][\\c-[:]]*|\\*)((/|//)(([\\i-[:]][\\c-[:]]*:)?[\\i-[:]][\\c-[:]]*|\\*|[.]))*(\\|([\\i-[:]][\\c-[:]]*:)?(//)?([\\i-[:]][\\c-[:]]*|\\*)((/|//)(([\\i-[:]][\\c-[:]]*:)?[\\i-[:]][\\c-[:]]*|\\*|[.]))*)*")))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns2__FullTopicExpression, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_ns2__FullTopicExpression, SOAP_TYPE_ns2__FullTopicExpression, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__FullTopicExpression(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_ns2__FullTopicExpression(soap, tag ? tag : "ns2:FullTopicExpression", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_ns2__FullTopicExpression(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__FullTopicExpression(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__ScheduledType__::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_ns1__ScheduledType(soap, &this->ns1__ScheduledType__::__item);
}

void ns1__ScheduledType__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__ScheduledType__::__item, SOAP_TYPE_ns1__ScheduledType);
#endif
}

int ns1__ScheduledType__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ScheduledType__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ScheduledType__(struct soap *soap, const char *tag, int id, const ns1__ScheduledType__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_ns1__ScheduledType(soap, tag, id, &a->ns1__ScheduledType__::__item, "");
}

void *ns1__ScheduledType__::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ScheduledType__(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ScheduledType__ * SOAP_FMAC4 soap_in_ns1__ScheduledType__(struct soap *soap, const char *tag, ns1__ScheduledType__ *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns1__ScheduledType__ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ScheduledType__, sizeof(ns1__ScheduledType__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__ScheduledType__)
		return (ns1__ScheduledType__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_ns1__ScheduledType(soap, tag, &a->ns1__ScheduledType__::__item, "ns1:ScheduledType"))
		return NULL;
	return a;
}

SOAP_FMAC1 ns1__ScheduledType__ * SOAP_FMAC2 soap_instantiate_ns1__ScheduledType__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ScheduledType__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__ScheduledType__ *p;
	size_t k = sizeof(ns1__ScheduledType__);
	if (n < 0)
	{	p = SOAP_NEW(ns1__ScheduledType__);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns1__ScheduledType__, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__ScheduledType__ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__ScheduledType__, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns1__ScheduledType__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__ScheduledType__(soap, tag ? tag : "ns1:ScheduledType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ScheduledType__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ScheduledType__(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ScheduledType__ * SOAP_FMAC4 soap_get_ns1__ScheduledType__(struct soap *soap, ns1__ScheduledType__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ScheduledType__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__FaultCodesOpenEnumType(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__FaultCodesOpenEnumType(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns6__FaultCodesOpenEnumType), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_ns6__FaultCodesOpenEnumType(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns6__FaultCodesOpenEnumType, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns6__FaultCodesOpenEnumType, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_ns6__FaultCodesOpenEnumType, SOAP_TYPE_ns6__FaultCodesOpenEnumType, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__FaultCodesOpenEnumType(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_ns6__FaultCodesOpenEnumType(soap, tag ? tag : "ns6:FaultCodesOpenEnumType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_ns6__FaultCodesOpenEnumType(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__FaultCodesOpenEnumType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__RelationshipTypeOpenEnum(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__RelationshipTypeOpenEnum(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns6__RelationshipTypeOpenEnum), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_ns6__RelationshipTypeOpenEnum(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns6__RelationshipTypeOpenEnum, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns6__RelationshipTypeOpenEnum, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_ns6__RelationshipTypeOpenEnum, SOAP_TYPE_ns6__RelationshipTypeOpenEnum, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__RelationshipTypeOpenEnum(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_ns6__RelationshipTypeOpenEnum(soap, tag ? tag : "ns6:RelationshipTypeOpenEnum", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_ns6__RelationshipTypeOpenEnum(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__RelationshipTypeOpenEnum(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns3__AbsoluteOrRelativeTimeType(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__AbsoluteOrRelativeTimeType(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns3__AbsoluteOrRelativeTimeType), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_ns3__AbsoluteOrRelativeTimeType(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns3__AbsoluteOrRelativeTimeType, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns3__AbsoluteOrRelativeTimeType, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_ns3__AbsoluteOrRelativeTimeType, SOAP_TYPE_ns3__AbsoluteOrRelativeTimeType, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__AbsoluteOrRelativeTimeType(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_ns3__AbsoluteOrRelativeTimeType(soap, tag ? tag : "ns3:AbsoluteOrRelativeTimeType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_ns3__AbsoluteOrRelativeTimeType(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__AbsoluteOrRelativeTimeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns6__ProblemActionType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns6__ProblemActionType::Action = NULL;
	this->ns6__ProblemActionType::SoapAction = NULL;
	soap_default_xsd__anyAttribute(soap, &this->ns6__ProblemActionType::__anyAttribute);
}

void ns6__ProblemActionType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons6__AttributedURIType(soap, &this->ns6__ProblemActionType::Action);
	soap_serialize_PointerToxsd__anyURI(soap, &this->ns6__ProblemActionType::SoapAction);
#endif
}

int ns6__ProblemActionType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__ProblemActionType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__ProblemActionType(struct soap *soap, const char *tag, int id, const ns6__ProblemActionType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((ns6__ProblemActionType*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__ProblemActionType), type))
		return soap->error;
	if (soap_out_PointerTons6__AttributedURIType(soap, "ns6:Action", -1, &a->ns6__ProblemActionType::Action, ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "ns6:SoapAction", -1, &a->ns6__ProblemActionType::SoapAction, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns6__ProblemActionType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__ProblemActionType(soap, tag, this, type);
}

SOAP_FMAC3 ns6__ProblemActionType * SOAP_FMAC4 soap_in_ns6__ProblemActionType(struct soap *soap, const char *tag, ns6__ProblemActionType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__ProblemActionType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__ProblemActionType, sizeof(ns6__ProblemActionType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns6__ProblemActionType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns6__ProblemActionType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((ns6__ProblemActionType*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Action1 = 1;
	size_t soap_flag_SoapAction1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Action1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons6__AttributedURIType(soap, "ns6:Action", &a->ns6__ProblemActionType::Action, "ns6:AttributedURIType"))
				{	soap_flag_Action1--;
					continue;
				}
			}
			if (soap_flag_SoapAction1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__anyURI(soap, "ns6:SoapAction", &a->ns6__ProblemActionType::SoapAction, "xsd:anyURI"))
				{	soap_flag_SoapAction1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns6__ProblemActionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__ProblemActionType, SOAP_TYPE_ns6__ProblemActionType, sizeof(ns6__ProblemActionType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns6__ProblemActionType * SOAP_FMAC2 soap_instantiate_ns6__ProblemActionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__ProblemActionType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns6__ProblemActionType *p;
	size_t k = sizeof(ns6__ProblemActionType);
	if (n < 0)
	{	p = SOAP_NEW(ns6__ProblemActionType);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns6__ProblemActionType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns6__ProblemActionType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns6__ProblemActionType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns6__ProblemActionType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns6__ProblemActionType(soap, tag ? tag : "ns6:ProblemActionType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns6__ProblemActionType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__ProblemActionType(soap, this, tag, type);
}

SOAP_FMAC3 ns6__ProblemActionType * SOAP_FMAC4 soap_get_ns6__ProblemActionType(struct soap *soap, ns6__ProblemActionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__ProblemActionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns6__AttributedQNameType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__QName(soap, &this->ns6__AttributedQNameType::__item);
	soap_default_xsd__anyAttribute(soap, &this->ns6__AttributedQNameType::__anyAttribute);
}

void ns6__AttributedQNameType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns6__AttributedQNameType::__item, SOAP_TYPE_xsd__QName);
	soap_serialize_xsd__QName(soap, &this->ns6__AttributedQNameType::__item);
#endif
}

int ns6__AttributedQNameType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__AttributedQNameType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__AttributedQNameType(struct soap *soap, const char *tag, int id, const ns6__AttributedQNameType *a, const char *type)
{
	std::string soap_tmp___item(soap_QName2s(soap, a->__item.c_str()));
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((ns6__AttributedQNameType*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_xsd__QName(soap, tag, id, &soap_tmp___item, "");
}

void *ns6__AttributedQNameType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__AttributedQNameType(soap, tag, this, type);
}

SOAP_FMAC3 ns6__AttributedQNameType * SOAP_FMAC4 soap_in_ns6__AttributedQNameType(struct soap *soap, const char *tag, ns6__AttributedQNameType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns6__AttributedQNameType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__AttributedQNameType, sizeof(ns6__AttributedQNameType), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns6__AttributedQNameType)
		return (ns6__AttributedQNameType *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((ns6__AttributedQNameType*)a)->__anyAttribute, "xsd:anyAttribute");
	if (!soap_in_xsd__QName(soap, tag, &a->ns6__AttributedQNameType::__item, "ns6:AttributedQNameType"))
		return NULL;
	return a;
}

SOAP_FMAC1 ns6__AttributedQNameType * SOAP_FMAC2 soap_instantiate_ns6__AttributedQNameType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__AttributedQNameType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns6__AttributedQNameType *p;
	size_t k = sizeof(ns6__AttributedQNameType);
	if (n < 0)
	{	p = SOAP_NEW(ns6__AttributedQNameType);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns6__AttributedQNameType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns6__AttributedQNameType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns6__AttributedQNameType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns6__AttributedQNameType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns6__AttributedQNameType(soap, tag ? tag : "ns6:AttributedQNameType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns6__AttributedQNameType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__AttributedQNameType(soap, this, tag, type);
}

SOAP_FMAC3 ns6__AttributedQNameType * SOAP_FMAC4 soap_get_ns6__AttributedQNameType(struct soap *soap, ns6__AttributedQNameType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__AttributedQNameType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns6__AttributedUnsignedLongType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_ULONG64(soap, &this->ns6__AttributedUnsignedLongType::__item);
	soap_default_xsd__anyAttribute(soap, &this->ns6__AttributedUnsignedLongType::__anyAttribute);
}

void ns6__AttributedUnsignedLongType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns6__AttributedUnsignedLongType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__AttributedUnsignedLongType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__AttributedUnsignedLongType(struct soap *soap, const char *tag, int id, const ns6__AttributedUnsignedLongType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((ns6__AttributedUnsignedLongType*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_ULONG64(soap, tag, id, &a->ns6__AttributedUnsignedLongType::__item, "");
}

void *ns6__AttributedUnsignedLongType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__AttributedUnsignedLongType(soap, tag, this, type);
}

SOAP_FMAC3 ns6__AttributedUnsignedLongType * SOAP_FMAC4 soap_in_ns6__AttributedUnsignedLongType(struct soap *soap, const char *tag, ns6__AttributedUnsignedLongType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns6__AttributedUnsignedLongType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__AttributedUnsignedLongType, sizeof(ns6__AttributedUnsignedLongType), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns6__AttributedUnsignedLongType)
		return (ns6__AttributedUnsignedLongType *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((ns6__AttributedUnsignedLongType*)a)->__anyAttribute, "xsd:anyAttribute");
	if (!soap_in_ULONG64(soap, tag, &a->ns6__AttributedUnsignedLongType::__item, "ns6:AttributedUnsignedLongType"))
		return NULL;
	return a;
}

SOAP_FMAC1 ns6__AttributedUnsignedLongType * SOAP_FMAC2 soap_instantiate_ns6__AttributedUnsignedLongType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__AttributedUnsignedLongType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns6__AttributedUnsignedLongType *p;
	size_t k = sizeof(ns6__AttributedUnsignedLongType);
	if (n < 0)
	{	p = SOAP_NEW(ns6__AttributedUnsignedLongType);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns6__AttributedUnsignedLongType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns6__AttributedUnsignedLongType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns6__AttributedUnsignedLongType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns6__AttributedUnsignedLongType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns6__AttributedUnsignedLongType(soap, tag ? tag : "ns6:AttributedUnsignedLongType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns6__AttributedUnsignedLongType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__AttributedUnsignedLongType(soap, this, tag, type);
}

SOAP_FMAC3 ns6__AttributedUnsignedLongType * SOAP_FMAC4 soap_get_ns6__AttributedUnsignedLongType(struct soap *soap, ns6__AttributedUnsignedLongType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__AttributedUnsignedLongType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns6__AttributedURIType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &this->ns6__AttributedURIType::__item);
	soap_default_xsd__anyAttribute(soap, &this->ns6__AttributedURIType::__anyAttribute);
}

void ns6__AttributedURIType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns6__AttributedURIType::__item, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->ns6__AttributedURIType::__item);
#endif
}

int ns6__AttributedURIType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__AttributedURIType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__AttributedURIType(struct soap *soap, const char *tag, int id, const ns6__AttributedURIType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((ns6__AttributedURIType*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_xsd__anyURI(soap, tag, id, &a->ns6__AttributedURIType::__item, "");
}

void *ns6__AttributedURIType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__AttributedURIType(soap, tag, this, type);
}

SOAP_FMAC3 ns6__AttributedURIType * SOAP_FMAC4 soap_in_ns6__AttributedURIType(struct soap *soap, const char *tag, ns6__AttributedURIType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns6__AttributedURIType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__AttributedURIType, sizeof(ns6__AttributedURIType), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns6__AttributedURIType)
		return (ns6__AttributedURIType *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((ns6__AttributedURIType*)a)->__anyAttribute, "xsd:anyAttribute");
	if (!soap_in_xsd__anyURI(soap, tag, &a->ns6__AttributedURIType::__item, "ns6:AttributedURIType"))
		return NULL;
	return a;
}

SOAP_FMAC1 ns6__AttributedURIType * SOAP_FMAC2 soap_instantiate_ns6__AttributedURIType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__AttributedURIType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns6__AttributedURIType *p;
	size_t k = sizeof(ns6__AttributedURIType);
	if (n < 0)
	{	p = SOAP_NEW(ns6__AttributedURIType);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns6__AttributedURIType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns6__AttributedURIType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns6__AttributedURIType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns6__AttributedURIType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns6__AttributedURIType(soap, tag ? tag : "ns6:AttributedURIType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns6__AttributedURIType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__AttributedURIType(soap, this, tag, type);
}

SOAP_FMAC3 ns6__AttributedURIType * SOAP_FMAC4 soap_get_ns6__AttributedURIType(struct soap *soap, ns6__AttributedURIType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__AttributedURIType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns6__RelatesToType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &this->ns6__RelatesToType::__item);
	this->ns6__RelatesToType::RelationshipType = "http://www.w3.org/2005/08/addressing/reply";
	soap_default_xsd__anyAttribute(soap, &this->ns6__RelatesToType::__anyAttribute);
}

void ns6__RelatesToType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns6__RelatesToType::__item, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->ns6__RelatesToType::__item);
#endif
}

int ns6__RelatesToType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__RelatesToType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__RelatesToType(struct soap *soap, const char *tag, int id, const ns6__RelatesToType *a, const char *type)
{
	soap_set_attr(soap, "RelationshipType", soap_ns6__RelationshipTypeOpenEnum2s(soap, ((ns6__RelatesToType*)a)->RelationshipType), 1);
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((ns6__RelatesToType*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_xsd__anyURI(soap, tag, id, &a->ns6__RelatesToType::__item, "");
}

void *ns6__RelatesToType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__RelatesToType(soap, tag, this, type);
}

SOAP_FMAC3 ns6__RelatesToType * SOAP_FMAC4 soap_in_ns6__RelatesToType(struct soap *soap, const char *tag, ns6__RelatesToType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns6__RelatesToType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__RelatesToType, sizeof(ns6__RelatesToType), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns6__RelatesToType)
		return (ns6__RelatesToType *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns6__RelationshipTypeOpenEnum(soap, soap_attr_value(soap, "RelationshipType", 1, 0), &((ns6__RelatesToType*)a)->RelationshipType))
		return NULL;
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((ns6__RelatesToType*)a)->__anyAttribute, "xsd:anyAttribute");
	if (!soap_in_xsd__anyURI(soap, tag, &a->ns6__RelatesToType::__item, "ns6:RelatesToType"))
		return NULL;
	return a;
}

SOAP_FMAC1 ns6__RelatesToType * SOAP_FMAC2 soap_instantiate_ns6__RelatesToType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__RelatesToType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns6__RelatesToType *p;
	size_t k = sizeof(ns6__RelatesToType);
	if (n < 0)
	{	p = SOAP_NEW(ns6__RelatesToType);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns6__RelatesToType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns6__RelatesToType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns6__RelatesToType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns6__RelatesToType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns6__RelatesToType(soap, tag ? tag : "ns6:RelatesToType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns6__RelatesToType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__RelatesToType(soap, this, tag, type);
}

SOAP_FMAC3 ns6__RelatesToType * SOAP_FMAC4 soap_get_ns6__RelatesToType(struct soap *soap, ns6__RelatesToType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__RelatesToType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns6__MetadataType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->ns6__MetadataType::__any);
	soap_default_xsd__anyAttribute(soap, &this->ns6__MetadataType::__anyAttribute);
}

void ns6__MetadataType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->ns6__MetadataType::__any);
#endif
}

int ns6__MetadataType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__MetadataType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__MetadataType(struct soap *soap, const char *tag, int id, const ns6__MetadataType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((ns6__MetadataType*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__MetadataType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->ns6__MetadataType::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns6__MetadataType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__MetadataType(soap, tag, this, type);
}

SOAP_FMAC3 ns6__MetadataType * SOAP_FMAC4 soap_in_ns6__MetadataType(struct soap *soap, const char *tag, ns6__MetadataType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__MetadataType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__MetadataType, sizeof(ns6__MetadataType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns6__MetadataType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns6__MetadataType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((ns6__MetadataType*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->ns6__MetadataType::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns6__MetadataType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__MetadataType, SOAP_TYPE_ns6__MetadataType, sizeof(ns6__MetadataType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns6__MetadataType * SOAP_FMAC2 soap_instantiate_ns6__MetadataType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__MetadataType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns6__MetadataType *p;
	size_t k = sizeof(ns6__MetadataType);
	if (n < 0)
	{	p = SOAP_NEW(ns6__MetadataType);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns6__MetadataType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns6__MetadataType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns6__MetadataType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns6__MetadataType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns6__MetadataType(soap, tag ? tag : "ns6:MetadataType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns6__MetadataType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__MetadataType(soap, this, tag, type);
}

SOAP_FMAC3 ns6__MetadataType * SOAP_FMAC4 soap_get_ns6__MetadataType(struct soap *soap, ns6__MetadataType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__MetadataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns6__ReferenceParametersType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->ns6__ReferenceParametersType::__any);
	soap_default_xsd__anyAttribute(soap, &this->ns6__ReferenceParametersType::__anyAttribute);
}

void ns6__ReferenceParametersType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->ns6__ReferenceParametersType::__any);
#endif
}

int ns6__ReferenceParametersType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__ReferenceParametersType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__ReferenceParametersType(struct soap *soap, const char *tag, int id, const ns6__ReferenceParametersType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((ns6__ReferenceParametersType*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__ReferenceParametersType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->ns6__ReferenceParametersType::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns6__ReferenceParametersType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__ReferenceParametersType(soap, tag, this, type);
}

SOAP_FMAC3 ns6__ReferenceParametersType * SOAP_FMAC4 soap_in_ns6__ReferenceParametersType(struct soap *soap, const char *tag, ns6__ReferenceParametersType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__ReferenceParametersType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__ReferenceParametersType, sizeof(ns6__ReferenceParametersType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns6__ReferenceParametersType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns6__ReferenceParametersType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((ns6__ReferenceParametersType*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->ns6__ReferenceParametersType::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns6__ReferenceParametersType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__ReferenceParametersType, SOAP_TYPE_ns6__ReferenceParametersType, sizeof(ns6__ReferenceParametersType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns6__ReferenceParametersType * SOAP_FMAC2 soap_instantiate_ns6__ReferenceParametersType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__ReferenceParametersType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns6__ReferenceParametersType *p;
	size_t k = sizeof(ns6__ReferenceParametersType);
	if (n < 0)
	{	p = SOAP_NEW(ns6__ReferenceParametersType);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns6__ReferenceParametersType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns6__ReferenceParametersType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns6__ReferenceParametersType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns6__ReferenceParametersType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns6__ReferenceParametersType(soap, tag ? tag : "ns6:ReferenceParametersType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns6__ReferenceParametersType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__ReferenceParametersType(soap, this, tag, type);
}

SOAP_FMAC3 ns6__ReferenceParametersType * SOAP_FMAC4 soap_get_ns6__ReferenceParametersType(struct soap *soap, ns6__ReferenceParametersType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__ReferenceParametersType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns6__EndpointReferenceType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns6__EndpointReferenceType::Address = NULL;
	this->ns6__EndpointReferenceType::ReferenceParameters = NULL;
	this->ns6__EndpointReferenceType::Metadata = NULL;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->ns6__EndpointReferenceType::__any);
	soap_default_xsd__anyAttribute(soap, &this->ns6__EndpointReferenceType::__anyAttribute);
}

void ns6__EndpointReferenceType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons6__AttributedURIType(soap, &this->ns6__EndpointReferenceType::Address);
	soap_serialize_PointerTons6__ReferenceParametersType(soap, &this->ns6__EndpointReferenceType::ReferenceParameters);
	soap_serialize_PointerTons6__MetadataType(soap, &this->ns6__EndpointReferenceType::Metadata);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->ns6__EndpointReferenceType::__any);
#endif
}

int ns6__EndpointReferenceType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__EndpointReferenceType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__EndpointReferenceType(struct soap *soap, const char *tag, int id, const ns6__EndpointReferenceType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((ns6__EndpointReferenceType*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__EndpointReferenceType), type))
		return soap->error;
	if (!a->ns6__EndpointReferenceType::Address)
	{	if (soap_element_empty(soap, "ns6:Address"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons6__AttributedURIType(soap, "ns6:Address", -1, &a->ns6__EndpointReferenceType::Address, ""))
		return soap->error;
	if (soap_out_PointerTons6__ReferenceParametersType(soap, "ns6:ReferenceParameters", -1, &a->ns6__EndpointReferenceType::ReferenceParameters, ""))
		return soap->error;
	if (soap_out_PointerTons6__MetadataType(soap, "ns6:Metadata", -1, &a->ns6__EndpointReferenceType::Metadata, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->ns6__EndpointReferenceType::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns6__EndpointReferenceType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__EndpointReferenceType(soap, tag, this, type);
}

SOAP_FMAC3 ns6__EndpointReferenceType * SOAP_FMAC4 soap_in_ns6__EndpointReferenceType(struct soap *soap, const char *tag, ns6__EndpointReferenceType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__EndpointReferenceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__EndpointReferenceType, sizeof(ns6__EndpointReferenceType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns6__EndpointReferenceType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns6__EndpointReferenceType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((ns6__EndpointReferenceType*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Address1 = 1;
	size_t soap_flag_ReferenceParameters1 = 1;
	size_t soap_flag_Metadata1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Address1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons6__AttributedURIType(soap, "ns6:Address", &a->ns6__EndpointReferenceType::Address, "ns6:AttributedURIType"))
				{	soap_flag_Address1--;
					continue;
				}
			}
			if (soap_flag_ReferenceParameters1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons6__ReferenceParametersType(soap, "ns6:ReferenceParameters", &a->ns6__EndpointReferenceType::ReferenceParameters, "ns6:ReferenceParametersType"))
				{	soap_flag_ReferenceParameters1--;
					continue;
				}
			}
			if (soap_flag_Metadata1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons6__MetadataType(soap, "ns6:Metadata", &a->ns6__EndpointReferenceType::Metadata, "ns6:MetadataType"))
				{	soap_flag_Metadata1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->ns6__EndpointReferenceType::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns6__EndpointReferenceType::Address))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns6__EndpointReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__EndpointReferenceType, SOAP_TYPE_ns6__EndpointReferenceType, sizeof(ns6__EndpointReferenceType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns6__EndpointReferenceType * SOAP_FMAC2 soap_instantiate_ns6__EndpointReferenceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__EndpointReferenceType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns6__EndpointReferenceType *p;
	size_t k = sizeof(ns6__EndpointReferenceType);
	if (n < 0)
	{	p = SOAP_NEW(ns6__EndpointReferenceType);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns6__EndpointReferenceType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns6__EndpointReferenceType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns6__EndpointReferenceType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns6__EndpointReferenceType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns6__EndpointReferenceType(soap, tag ? tag : "ns6:EndpointReferenceType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns6__EndpointReferenceType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__EndpointReferenceType(soap, this, tag, type);
}

SOAP_FMAC3 ns6__EndpointReferenceType * SOAP_FMAC4 soap_get_ns6__EndpointReferenceType(struct soap *soap, ns6__EndpointReferenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__EndpointReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns5__InvalidActivationTimeoutFault::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__duration(soap, &this->_ns5__InvalidActivationTimeoutFault::MaximumTimeout);
	/* transient soap skipped */
}

void _ns5__InvalidActivationTimeoutFault::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_ns5__InvalidActivationTimeoutFault::MaximumTimeout, SOAP_TYPE_xsd__duration);
	soap_serialize_xsd__duration(soap, &this->_ns5__InvalidActivationTimeoutFault::MaximumTimeout);
#endif
}

int _ns5__InvalidActivationTimeoutFault::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns5__InvalidActivationTimeoutFault(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns5__InvalidActivationTimeoutFault(struct soap *soap, const char *tag, int id, const _ns5__InvalidActivationTimeoutFault *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns5__InvalidActivationTimeoutFault), type))
		return soap->error;
	if (soap_out_xsd__duration(soap, "ns5:MaximumTimeout", -1, &a->_ns5__InvalidActivationTimeoutFault::MaximumTimeout, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns5__InvalidActivationTimeoutFault::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns5__InvalidActivationTimeoutFault(soap, tag, this, type);
}

SOAP_FMAC3 _ns5__InvalidActivationTimeoutFault * SOAP_FMAC4 soap_in__ns5__InvalidActivationTimeoutFault(struct soap *soap, const char *tag, _ns5__InvalidActivationTimeoutFault *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns5__InvalidActivationTimeoutFault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__InvalidActivationTimeoutFault, sizeof(_ns5__InvalidActivationTimeoutFault), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns5__InvalidActivationTimeoutFault)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns5__InvalidActivationTimeoutFault *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_MaximumTimeout1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MaximumTimeout1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__duration(soap, "ns5:MaximumTimeout", &a->_ns5__InvalidActivationTimeoutFault::MaximumTimeout, "xsd:duration"))
				{	soap_flag_MaximumTimeout1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_MaximumTimeout1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns5__InvalidActivationTimeoutFault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__InvalidActivationTimeoutFault, SOAP_TYPE__ns5__InvalidActivationTimeoutFault, sizeof(_ns5__InvalidActivationTimeoutFault), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns5__InvalidActivationTimeoutFault * SOAP_FMAC2 soap_instantiate__ns5__InvalidActivationTimeoutFault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns5__InvalidActivationTimeoutFault(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns5__InvalidActivationTimeoutFault *p;
	size_t k = sizeof(_ns5__InvalidActivationTimeoutFault);
	if (n < 0)
	{	p = SOAP_NEW(_ns5__InvalidActivationTimeoutFault);
		if (p)
			((_ns5__InvalidActivationTimeoutFault*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns5__InvalidActivationTimeoutFault, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns5__InvalidActivationTimeoutFault*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns5__InvalidActivationTimeoutFault location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns5__InvalidActivationTimeoutFault, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns5__InvalidActivationTimeoutFault::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns5__InvalidActivationTimeoutFault(soap, tag ? tag : "ns5:InvalidActivationTimeoutFault", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns5__InvalidActivationTimeoutFault::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns5__InvalidActivationTimeoutFault(soap, this, tag, type);
}

SOAP_FMAC3 _ns5__InvalidActivationTimeoutFault * SOAP_FMAC4 soap_get__ns5__InvalidActivationTimeoutFault(struct soap *soap, _ns5__InvalidActivationTimeoutFault *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns5__InvalidActivationTimeoutFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns5__ActionRuleNotFoundFault::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns5__ActionRuleNotFoundFault::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns5__ActionRuleNotFoundFault::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns5__ActionRuleNotFoundFault(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns5__ActionRuleNotFoundFault(struct soap *soap, const char *tag, int id, const _ns5__ActionRuleNotFoundFault *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns5__ActionRuleNotFoundFault), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns5__ActionRuleNotFoundFault::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns5__ActionRuleNotFoundFault(soap, tag, this, type);
}

SOAP_FMAC3 _ns5__ActionRuleNotFoundFault * SOAP_FMAC4 soap_in__ns5__ActionRuleNotFoundFault(struct soap *soap, const char *tag, _ns5__ActionRuleNotFoundFault *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns5__ActionRuleNotFoundFault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__ActionRuleNotFoundFault, sizeof(_ns5__ActionRuleNotFoundFault), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns5__ActionRuleNotFoundFault)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns5__ActionRuleNotFoundFault *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns5__ActionRuleNotFoundFault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__ActionRuleNotFoundFault, SOAP_TYPE__ns5__ActionRuleNotFoundFault, sizeof(_ns5__ActionRuleNotFoundFault), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns5__ActionRuleNotFoundFault * SOAP_FMAC2 soap_instantiate__ns5__ActionRuleNotFoundFault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns5__ActionRuleNotFoundFault(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns5__ActionRuleNotFoundFault *p;
	size_t k = sizeof(_ns5__ActionRuleNotFoundFault);
	if (n < 0)
	{	p = SOAP_NEW(_ns5__ActionRuleNotFoundFault);
		if (p)
			((_ns5__ActionRuleNotFoundFault*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns5__ActionRuleNotFoundFault, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns5__ActionRuleNotFoundFault*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns5__ActionRuleNotFoundFault location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns5__ActionRuleNotFoundFault, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns5__ActionRuleNotFoundFault::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns5__ActionRuleNotFoundFault(soap, tag ? tag : "ns5:ActionRuleNotFoundFault", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns5__ActionRuleNotFoundFault::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns5__ActionRuleNotFoundFault(soap, this, tag, type);
}

SOAP_FMAC3 _ns5__ActionRuleNotFoundFault * SOAP_FMAC4 soap_get__ns5__ActionRuleNotFoundFault(struct soap *soap, _ns5__ActionRuleNotFoundFault *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns5__ActionRuleNotFoundFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns5__InsufficientActivationRuleFault::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns5__InsufficientActivationRuleFault::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns5__InsufficientActivationRuleFault::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns5__InsufficientActivationRuleFault(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns5__InsufficientActivationRuleFault(struct soap *soap, const char *tag, int id, const _ns5__InsufficientActivationRuleFault *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns5__InsufficientActivationRuleFault), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns5__InsufficientActivationRuleFault::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns5__InsufficientActivationRuleFault(soap, tag, this, type);
}

SOAP_FMAC3 _ns5__InsufficientActivationRuleFault * SOAP_FMAC4 soap_in__ns5__InsufficientActivationRuleFault(struct soap *soap, const char *tag, _ns5__InsufficientActivationRuleFault *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns5__InsufficientActivationRuleFault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__InsufficientActivationRuleFault, sizeof(_ns5__InsufficientActivationRuleFault), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns5__InsufficientActivationRuleFault)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns5__InsufficientActivationRuleFault *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns5__InsufficientActivationRuleFault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__InsufficientActivationRuleFault, SOAP_TYPE__ns5__InsufficientActivationRuleFault, sizeof(_ns5__InsufficientActivationRuleFault), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns5__InsufficientActivationRuleFault * SOAP_FMAC2 soap_instantiate__ns5__InsufficientActivationRuleFault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns5__InsufficientActivationRuleFault(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns5__InsufficientActivationRuleFault *p;
	size_t k = sizeof(_ns5__InsufficientActivationRuleFault);
	if (n < 0)
	{	p = SOAP_NEW(_ns5__InsufficientActivationRuleFault);
		if (p)
			((_ns5__InsufficientActivationRuleFault*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns5__InsufficientActivationRuleFault, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns5__InsufficientActivationRuleFault*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns5__InsufficientActivationRuleFault location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns5__InsufficientActivationRuleFault, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns5__InsufficientActivationRuleFault::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns5__InsufficientActivationRuleFault(soap, tag ? tag : "ns5:InsufficientActivationRuleFault", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns5__InsufficientActivationRuleFault::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns5__InsufficientActivationRuleFault(soap, this, tag, type);
}

SOAP_FMAC3 _ns5__InsufficientActivationRuleFault * SOAP_FMAC4 soap_get__ns5__InsufficientActivationRuleFault(struct soap *soap, _ns5__InsufficientActivationRuleFault *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns5__InsufficientActivationRuleFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns5__InvalidConditionFilterFault::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns5__InvalidConditionFilterFault::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns5__InvalidConditionFilterFault::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns5__InvalidConditionFilterFault(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns5__InvalidConditionFilterFault(struct soap *soap, const char *tag, int id, const _ns5__InvalidConditionFilterFault *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns5__InvalidConditionFilterFault), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns5__InvalidConditionFilterFault::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns5__InvalidConditionFilterFault(soap, tag, this, type);
}

SOAP_FMAC3 _ns5__InvalidConditionFilterFault * SOAP_FMAC4 soap_in__ns5__InvalidConditionFilterFault(struct soap *soap, const char *tag, _ns5__InvalidConditionFilterFault *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns5__InvalidConditionFilterFault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__InvalidConditionFilterFault, sizeof(_ns5__InvalidConditionFilterFault), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns5__InvalidConditionFilterFault)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns5__InvalidConditionFilterFault *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns5__InvalidConditionFilterFault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__InvalidConditionFilterFault, SOAP_TYPE__ns5__InvalidConditionFilterFault, sizeof(_ns5__InvalidConditionFilterFault), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns5__InvalidConditionFilterFault * SOAP_FMAC2 soap_instantiate__ns5__InvalidConditionFilterFault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns5__InvalidConditionFilterFault(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns5__InvalidConditionFilterFault *p;
	size_t k = sizeof(_ns5__InvalidConditionFilterFault);
	if (n < 0)
	{	p = SOAP_NEW(_ns5__InvalidConditionFilterFault);
		if (p)
			((_ns5__InvalidConditionFilterFault*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns5__InvalidConditionFilterFault, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns5__InvalidConditionFilterFault*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns5__InvalidConditionFilterFault location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns5__InvalidConditionFilterFault, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns5__InvalidConditionFilterFault::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns5__InvalidConditionFilterFault(soap, tag ? tag : "ns5:InvalidConditionFilterFault", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns5__InvalidConditionFilterFault::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns5__InvalidConditionFilterFault(soap, this, tag, type);
}

SOAP_FMAC3 _ns5__InvalidConditionFilterFault * SOAP_FMAC4 soap_get__ns5__InvalidConditionFilterFault(struct soap *soap, _ns5__InvalidConditionFilterFault *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns5__InvalidConditionFilterFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns5__ActionConfigurationIsInUseFault::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns5__ActionConfigurationIsInUseFault::UsedByActionRules = NULL;
	/* transient soap skipped */
}

void _ns5__ActionConfigurationIsInUseFault::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons5__UsedByActionRules(soap, &this->_ns5__ActionConfigurationIsInUseFault::UsedByActionRules);
#endif
}

int _ns5__ActionConfigurationIsInUseFault::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns5__ActionConfigurationIsInUseFault(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns5__ActionConfigurationIsInUseFault(struct soap *soap, const char *tag, int id, const _ns5__ActionConfigurationIsInUseFault *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns5__ActionConfigurationIsInUseFault), type))
		return soap->error;
	if (!a->_ns5__ActionConfigurationIsInUseFault::UsedByActionRules)
	{	if (soap_element_empty(soap, "ns5:UsedByActionRules"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons5__UsedByActionRules(soap, "ns5:UsedByActionRules", -1, &a->_ns5__ActionConfigurationIsInUseFault::UsedByActionRules, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns5__ActionConfigurationIsInUseFault::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns5__ActionConfigurationIsInUseFault(soap, tag, this, type);
}

SOAP_FMAC3 _ns5__ActionConfigurationIsInUseFault * SOAP_FMAC4 soap_in__ns5__ActionConfigurationIsInUseFault(struct soap *soap, const char *tag, _ns5__ActionConfigurationIsInUseFault *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns5__ActionConfigurationIsInUseFault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__ActionConfigurationIsInUseFault, sizeof(_ns5__ActionConfigurationIsInUseFault), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns5__ActionConfigurationIsInUseFault)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns5__ActionConfigurationIsInUseFault *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_UsedByActionRules1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UsedByActionRules1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons5__UsedByActionRules(soap, "ns5:UsedByActionRules", &a->_ns5__ActionConfigurationIsInUseFault::UsedByActionRules, "ns5:UsedByActionRules"))
				{	soap_flag_UsedByActionRules1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_ns5__ActionConfigurationIsInUseFault::UsedByActionRules))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns5__ActionConfigurationIsInUseFault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__ActionConfigurationIsInUseFault, SOAP_TYPE__ns5__ActionConfigurationIsInUseFault, sizeof(_ns5__ActionConfigurationIsInUseFault), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns5__ActionConfigurationIsInUseFault * SOAP_FMAC2 soap_instantiate__ns5__ActionConfigurationIsInUseFault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns5__ActionConfigurationIsInUseFault(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns5__ActionConfigurationIsInUseFault *p;
	size_t k = sizeof(_ns5__ActionConfigurationIsInUseFault);
	if (n < 0)
	{	p = SOAP_NEW(_ns5__ActionConfigurationIsInUseFault);
		if (p)
			((_ns5__ActionConfigurationIsInUseFault*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns5__ActionConfigurationIsInUseFault, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns5__ActionConfigurationIsInUseFault*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns5__ActionConfigurationIsInUseFault location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns5__ActionConfigurationIsInUseFault, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns5__ActionConfigurationIsInUseFault::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns5__ActionConfigurationIsInUseFault(soap, tag ? tag : "ns5:ActionConfigurationIsInUseFault", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns5__ActionConfigurationIsInUseFault::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns5__ActionConfigurationIsInUseFault(soap, this, tag, type);
}

SOAP_FMAC3 _ns5__ActionConfigurationIsInUseFault * SOAP_FMAC4 soap_get__ns5__ActionConfigurationIsInUseFault(struct soap *soap, _ns5__ActionConfigurationIsInUseFault *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns5__ActionConfigurationIsInUseFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns5__RecipientTemplateNotFoundFault::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns5__RecipientTemplateNotFoundFault::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns5__RecipientTemplateNotFoundFault::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns5__RecipientTemplateNotFoundFault(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns5__RecipientTemplateNotFoundFault(struct soap *soap, const char *tag, int id, const _ns5__RecipientTemplateNotFoundFault *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns5__RecipientTemplateNotFoundFault), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns5__RecipientTemplateNotFoundFault::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns5__RecipientTemplateNotFoundFault(soap, tag, this, type);
}

SOAP_FMAC3 _ns5__RecipientTemplateNotFoundFault * SOAP_FMAC4 soap_in__ns5__RecipientTemplateNotFoundFault(struct soap *soap, const char *tag, _ns5__RecipientTemplateNotFoundFault *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns5__RecipientTemplateNotFoundFault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__RecipientTemplateNotFoundFault, sizeof(_ns5__RecipientTemplateNotFoundFault), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns5__RecipientTemplateNotFoundFault)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns5__RecipientTemplateNotFoundFault *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns5__RecipientTemplateNotFoundFault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__RecipientTemplateNotFoundFault, SOAP_TYPE__ns5__RecipientTemplateNotFoundFault, sizeof(_ns5__RecipientTemplateNotFoundFault), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns5__RecipientTemplateNotFoundFault * SOAP_FMAC2 soap_instantiate__ns5__RecipientTemplateNotFoundFault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns5__RecipientTemplateNotFoundFault(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns5__RecipientTemplateNotFoundFault *p;
	size_t k = sizeof(_ns5__RecipientTemplateNotFoundFault);
	if (n < 0)
	{	p = SOAP_NEW(_ns5__RecipientTemplateNotFoundFault);
		if (p)
			((_ns5__RecipientTemplateNotFoundFault*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns5__RecipientTemplateNotFoundFault, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns5__RecipientTemplateNotFoundFault*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns5__RecipientTemplateNotFoundFault location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns5__RecipientTemplateNotFoundFault, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns5__RecipientTemplateNotFoundFault::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns5__RecipientTemplateNotFoundFault(soap, tag ? tag : "ns5:RecipientTemplateNotFoundFault", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns5__RecipientTemplateNotFoundFault::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns5__RecipientTemplateNotFoundFault(soap, this, tag, type);
}

SOAP_FMAC3 _ns5__RecipientTemplateNotFoundFault * SOAP_FMAC4 soap_get__ns5__RecipientTemplateNotFoundFault(struct soap *soap, _ns5__RecipientTemplateNotFoundFault *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns5__RecipientTemplateNotFoundFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns5__ActionConfigurationNotFoundFault::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns5__ActionConfigurationNotFoundFault::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns5__ActionConfigurationNotFoundFault::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns5__ActionConfigurationNotFoundFault(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns5__ActionConfigurationNotFoundFault(struct soap *soap, const char *tag, int id, const _ns5__ActionConfigurationNotFoundFault *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns5__ActionConfigurationNotFoundFault), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns5__ActionConfigurationNotFoundFault::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns5__ActionConfigurationNotFoundFault(soap, tag, this, type);
}

SOAP_FMAC3 _ns5__ActionConfigurationNotFoundFault * SOAP_FMAC4 soap_in__ns5__ActionConfigurationNotFoundFault(struct soap *soap, const char *tag, _ns5__ActionConfigurationNotFoundFault *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns5__ActionConfigurationNotFoundFault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__ActionConfigurationNotFoundFault, sizeof(_ns5__ActionConfigurationNotFoundFault), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns5__ActionConfigurationNotFoundFault)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns5__ActionConfigurationNotFoundFault *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns5__ActionConfigurationNotFoundFault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__ActionConfigurationNotFoundFault, SOAP_TYPE__ns5__ActionConfigurationNotFoundFault, sizeof(_ns5__ActionConfigurationNotFoundFault), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns5__ActionConfigurationNotFoundFault * SOAP_FMAC2 soap_instantiate__ns5__ActionConfigurationNotFoundFault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns5__ActionConfigurationNotFoundFault(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns5__ActionConfigurationNotFoundFault *p;
	size_t k = sizeof(_ns5__ActionConfigurationNotFoundFault);
	if (n < 0)
	{	p = SOAP_NEW(_ns5__ActionConfigurationNotFoundFault);
		if (p)
			((_ns5__ActionConfigurationNotFoundFault*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns5__ActionConfigurationNotFoundFault, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns5__ActionConfigurationNotFoundFault*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns5__ActionConfigurationNotFoundFault location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns5__ActionConfigurationNotFoundFault, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns5__ActionConfigurationNotFoundFault::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns5__ActionConfigurationNotFoundFault(soap, tag ? tag : "ns5:ActionConfigurationNotFoundFault", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns5__ActionConfigurationNotFoundFault::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns5__ActionConfigurationNotFoundFault(soap, this, tag, type);
}

SOAP_FMAC3 _ns5__ActionConfigurationNotFoundFault * SOAP_FMAC4 soap_get__ns5__ActionConfigurationNotFoundFault(struct soap *soap, _ns5__ActionConfigurationNotFoundFault *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns5__ActionConfigurationNotFoundFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns5__InvalidActionConfigurationFault::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns5__InvalidActionConfigurationFault::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns5__InvalidActionConfigurationFault::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns5__InvalidActionConfigurationFault(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns5__InvalidActionConfigurationFault(struct soap *soap, const char *tag, int id, const _ns5__InvalidActionConfigurationFault *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns5__InvalidActionConfigurationFault), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns5__InvalidActionConfigurationFault::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns5__InvalidActionConfigurationFault(soap, tag, this, type);
}

SOAP_FMAC3 _ns5__InvalidActionConfigurationFault * SOAP_FMAC4 soap_in__ns5__InvalidActionConfigurationFault(struct soap *soap, const char *tag, _ns5__InvalidActionConfigurationFault *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns5__InvalidActionConfigurationFault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__InvalidActionConfigurationFault, sizeof(_ns5__InvalidActionConfigurationFault), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns5__InvalidActionConfigurationFault)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns5__InvalidActionConfigurationFault *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns5__InvalidActionConfigurationFault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__InvalidActionConfigurationFault, SOAP_TYPE__ns5__InvalidActionConfigurationFault, sizeof(_ns5__InvalidActionConfigurationFault), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns5__InvalidActionConfigurationFault * SOAP_FMAC2 soap_instantiate__ns5__InvalidActionConfigurationFault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns5__InvalidActionConfigurationFault(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns5__InvalidActionConfigurationFault *p;
	size_t k = sizeof(_ns5__InvalidActionConfigurationFault);
	if (n < 0)
	{	p = SOAP_NEW(_ns5__InvalidActionConfigurationFault);
		if (p)
			((_ns5__InvalidActionConfigurationFault*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns5__InvalidActionConfigurationFault, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns5__InvalidActionConfigurationFault*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns5__InvalidActionConfigurationFault location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns5__InvalidActionConfigurationFault, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns5__InvalidActionConfigurationFault::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns5__InvalidActionConfigurationFault(soap, tag ? tag : "ns5:InvalidActionConfigurationFault", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns5__InvalidActionConfigurationFault::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns5__InvalidActionConfigurationFault(soap, this, tag, type);
}

SOAP_FMAC3 _ns5__InvalidActionConfigurationFault * SOAP_FMAC4 soap_get__ns5__InvalidActionConfigurationFault(struct soap *soap, _ns5__InvalidActionConfigurationFault *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns5__InvalidActionConfigurationFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns5__ParametersMissmatchFault::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns5__ParametersMissmatchFault::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns5__ParametersMissmatchFault::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns5__ParametersMissmatchFault(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns5__ParametersMissmatchFault(struct soap *soap, const char *tag, int id, const _ns5__ParametersMissmatchFault *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns5__ParametersMissmatchFault), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns5__ParametersMissmatchFault::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns5__ParametersMissmatchFault(soap, tag, this, type);
}

SOAP_FMAC3 _ns5__ParametersMissmatchFault * SOAP_FMAC4 soap_in__ns5__ParametersMissmatchFault(struct soap *soap, const char *tag, _ns5__ParametersMissmatchFault *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns5__ParametersMissmatchFault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__ParametersMissmatchFault, sizeof(_ns5__ParametersMissmatchFault), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns5__ParametersMissmatchFault)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns5__ParametersMissmatchFault *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns5__ParametersMissmatchFault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__ParametersMissmatchFault, SOAP_TYPE__ns5__ParametersMissmatchFault, sizeof(_ns5__ParametersMissmatchFault), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns5__ParametersMissmatchFault * SOAP_FMAC2 soap_instantiate__ns5__ParametersMissmatchFault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns5__ParametersMissmatchFault(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns5__ParametersMissmatchFault *p;
	size_t k = sizeof(_ns5__ParametersMissmatchFault);
	if (n < 0)
	{	p = SOAP_NEW(_ns5__ParametersMissmatchFault);
		if (p)
			((_ns5__ParametersMissmatchFault*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns5__ParametersMissmatchFault, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns5__ParametersMissmatchFault*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns5__ParametersMissmatchFault location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns5__ParametersMissmatchFault, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns5__ParametersMissmatchFault::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns5__ParametersMissmatchFault(soap, tag ? tag : "ns5:ParametersMissmatchFault", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns5__ParametersMissmatchFault::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns5__ParametersMissmatchFault(soap, this, tag, type);
}

SOAP_FMAC3 _ns5__ParametersMissmatchFault * SOAP_FMAC4 soap_get__ns5__ParametersMissmatchFault(struct soap *soap, _ns5__ParametersMissmatchFault *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns5__ParametersMissmatchFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns5__RecipientConfigurationNotFoundFault::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns5__RecipientConfigurationNotFoundFault::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns5__RecipientConfigurationNotFoundFault::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns5__RecipientConfigurationNotFoundFault(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns5__RecipientConfigurationNotFoundFault(struct soap *soap, const char *tag, int id, const _ns5__RecipientConfigurationNotFoundFault *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns5__RecipientConfigurationNotFoundFault), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns5__RecipientConfigurationNotFoundFault::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns5__RecipientConfigurationNotFoundFault(soap, tag, this, type);
}

SOAP_FMAC3 _ns5__RecipientConfigurationNotFoundFault * SOAP_FMAC4 soap_in__ns5__RecipientConfigurationNotFoundFault(struct soap *soap, const char *tag, _ns5__RecipientConfigurationNotFoundFault *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns5__RecipientConfigurationNotFoundFault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__RecipientConfigurationNotFoundFault, sizeof(_ns5__RecipientConfigurationNotFoundFault), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns5__RecipientConfigurationNotFoundFault)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns5__RecipientConfigurationNotFoundFault *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns5__RecipientConfigurationNotFoundFault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__RecipientConfigurationNotFoundFault, SOAP_TYPE__ns5__RecipientConfigurationNotFoundFault, sizeof(_ns5__RecipientConfigurationNotFoundFault), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns5__RecipientConfigurationNotFoundFault * SOAP_FMAC2 soap_instantiate__ns5__RecipientConfigurationNotFoundFault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns5__RecipientConfigurationNotFoundFault(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns5__RecipientConfigurationNotFoundFault *p;
	size_t k = sizeof(_ns5__RecipientConfigurationNotFoundFault);
	if (n < 0)
	{	p = SOAP_NEW(_ns5__RecipientConfigurationNotFoundFault);
		if (p)
			((_ns5__RecipientConfigurationNotFoundFault*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns5__RecipientConfigurationNotFoundFault, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns5__RecipientConfigurationNotFoundFault*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns5__RecipientConfigurationNotFoundFault location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns5__RecipientConfigurationNotFoundFault, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns5__RecipientConfigurationNotFoundFault::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns5__RecipientConfigurationNotFoundFault(soap, tag ? tag : "ns5:RecipientConfigurationNotFoundFault", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns5__RecipientConfigurationNotFoundFault::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns5__RecipientConfigurationNotFoundFault(soap, this, tag, type);
}

SOAP_FMAC3 _ns5__RecipientConfigurationNotFoundFault * SOAP_FMAC4 soap_get__ns5__RecipientConfigurationNotFoundFault(struct soap *soap, _ns5__RecipientConfigurationNotFoundFault *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns5__RecipientConfigurationNotFoundFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns5__ActionTemplateNotFoundFault::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns5__ActionTemplateNotFoundFault::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns5__ActionTemplateNotFoundFault::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns5__ActionTemplateNotFoundFault(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns5__ActionTemplateNotFoundFault(struct soap *soap, const char *tag, int id, const _ns5__ActionTemplateNotFoundFault *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns5__ActionTemplateNotFoundFault), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns5__ActionTemplateNotFoundFault::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns5__ActionTemplateNotFoundFault(soap, tag, this, type);
}

SOAP_FMAC3 _ns5__ActionTemplateNotFoundFault * SOAP_FMAC4 soap_in__ns5__ActionTemplateNotFoundFault(struct soap *soap, const char *tag, _ns5__ActionTemplateNotFoundFault *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns5__ActionTemplateNotFoundFault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__ActionTemplateNotFoundFault, sizeof(_ns5__ActionTemplateNotFoundFault), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns5__ActionTemplateNotFoundFault)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns5__ActionTemplateNotFoundFault *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns5__ActionTemplateNotFoundFault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__ActionTemplateNotFoundFault, SOAP_TYPE__ns5__ActionTemplateNotFoundFault, sizeof(_ns5__ActionTemplateNotFoundFault), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns5__ActionTemplateNotFoundFault * SOAP_FMAC2 soap_instantiate__ns5__ActionTemplateNotFoundFault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns5__ActionTemplateNotFoundFault(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns5__ActionTemplateNotFoundFault *p;
	size_t k = sizeof(_ns5__ActionTemplateNotFoundFault);
	if (n < 0)
	{	p = SOAP_NEW(_ns5__ActionTemplateNotFoundFault);
		if (p)
			((_ns5__ActionTemplateNotFoundFault*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns5__ActionTemplateNotFoundFault, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns5__ActionTemplateNotFoundFault*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns5__ActionTemplateNotFoundFault location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns5__ActionTemplateNotFoundFault, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns5__ActionTemplateNotFoundFault::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns5__ActionTemplateNotFoundFault(soap, tag ? tag : "ns5:ActionTemplateNotFoundFault", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns5__ActionTemplateNotFoundFault::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns5__ActionTemplateNotFoundFault(soap, this, tag, type);
}

SOAP_FMAC3 _ns5__ActionTemplateNotFoundFault * SOAP_FMAC4 soap_get__ns5__ActionTemplateNotFoundFault(struct soap *soap, _ns5__ActionTemplateNotFoundFault *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns5__ActionTemplateNotFoundFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns5__RemoveActionRuleResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns5__RemoveActionRuleResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns5__RemoveActionRuleResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns5__RemoveActionRuleResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns5__RemoveActionRuleResponse(struct soap *soap, const char *tag, int id, const _ns5__RemoveActionRuleResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns5__RemoveActionRuleResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns5__RemoveActionRuleResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns5__RemoveActionRuleResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns5__RemoveActionRuleResponse * SOAP_FMAC4 soap_in__ns5__RemoveActionRuleResponse(struct soap *soap, const char *tag, _ns5__RemoveActionRuleResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns5__RemoveActionRuleResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__RemoveActionRuleResponse, sizeof(_ns5__RemoveActionRuleResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns5__RemoveActionRuleResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns5__RemoveActionRuleResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns5__RemoveActionRuleResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__RemoveActionRuleResponse, SOAP_TYPE__ns5__RemoveActionRuleResponse, sizeof(_ns5__RemoveActionRuleResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns5__RemoveActionRuleResponse * SOAP_FMAC2 soap_instantiate__ns5__RemoveActionRuleResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns5__RemoveActionRuleResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns5__RemoveActionRuleResponse *p;
	size_t k = sizeof(_ns5__RemoveActionRuleResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns5__RemoveActionRuleResponse);
		if (p)
			((_ns5__RemoveActionRuleResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns5__RemoveActionRuleResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns5__RemoveActionRuleResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns5__RemoveActionRuleResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns5__RemoveActionRuleResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns5__RemoveActionRuleResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns5__RemoveActionRuleResponse(soap, tag ? tag : "ns5:RemoveActionRuleResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns5__RemoveActionRuleResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns5__RemoveActionRuleResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns5__RemoveActionRuleResponse * SOAP_FMAC4 soap_get__ns5__RemoveActionRuleResponse(struct soap *soap, _ns5__RemoveActionRuleResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns5__RemoveActionRuleResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns5__RemoveActionRule::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__integer(soap, &this->_ns5__RemoveActionRule::RuleID);
	/* transient soap skipped */
}

void _ns5__RemoveActionRule::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_ns5__RemoveActionRule::RuleID, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &this->_ns5__RemoveActionRule::RuleID);
#endif
}

int _ns5__RemoveActionRule::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns5__RemoveActionRule(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns5__RemoveActionRule(struct soap *soap, const char *tag, int id, const _ns5__RemoveActionRule *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns5__RemoveActionRule), type))
		return soap->error;
	if (soap_out_xsd__integer(soap, "ns5:RuleID", -1, &a->_ns5__RemoveActionRule::RuleID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns5__RemoveActionRule::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns5__RemoveActionRule(soap, tag, this, type);
}

SOAP_FMAC3 _ns5__RemoveActionRule * SOAP_FMAC4 soap_in__ns5__RemoveActionRule(struct soap *soap, const char *tag, _ns5__RemoveActionRule *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns5__RemoveActionRule *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__RemoveActionRule, sizeof(_ns5__RemoveActionRule), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns5__RemoveActionRule)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns5__RemoveActionRule *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_RuleID1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RuleID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__integer(soap, "ns5:RuleID", &a->_ns5__RemoveActionRule::RuleID, "xsd:integer"))
				{	soap_flag_RuleID1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RuleID1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns5__RemoveActionRule *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__RemoveActionRule, SOAP_TYPE__ns5__RemoveActionRule, sizeof(_ns5__RemoveActionRule), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns5__RemoveActionRule * SOAP_FMAC2 soap_instantiate__ns5__RemoveActionRule(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns5__RemoveActionRule(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns5__RemoveActionRule *p;
	size_t k = sizeof(_ns5__RemoveActionRule);
	if (n < 0)
	{	p = SOAP_NEW(_ns5__RemoveActionRule);
		if (p)
			((_ns5__RemoveActionRule*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns5__RemoveActionRule, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns5__RemoveActionRule*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns5__RemoveActionRule location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns5__RemoveActionRule, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns5__RemoveActionRule::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns5__RemoveActionRule(soap, tag ? tag : "ns5:RemoveActionRule", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns5__RemoveActionRule::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns5__RemoveActionRule(soap, this, tag, type);
}

SOAP_FMAC3 _ns5__RemoveActionRule * SOAP_FMAC4 soap_get__ns5__RemoveActionRule(struct soap *soap, _ns5__RemoveActionRule *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns5__RemoveActionRule(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns5__GetActionRulesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns5__GetActionRulesResponse::ActionRules = NULL;
	/* transient soap skipped */
}

void _ns5__GetActionRulesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons5__ActionRules(soap, &this->_ns5__GetActionRulesResponse::ActionRules);
#endif
}

int _ns5__GetActionRulesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns5__GetActionRulesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns5__GetActionRulesResponse(struct soap *soap, const char *tag, int id, const _ns5__GetActionRulesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns5__GetActionRulesResponse), type))
		return soap->error;
	if (a->ActionRules)
		soap_element_result(soap, "ns5:ActionRules");
	if (!a->_ns5__GetActionRulesResponse::ActionRules)
	{	if (soap_element_empty(soap, "ns5:ActionRules"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons5__ActionRules(soap, "ns5:ActionRules", -1, &a->_ns5__GetActionRulesResponse::ActionRules, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns5__GetActionRulesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns5__GetActionRulesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns5__GetActionRulesResponse * SOAP_FMAC4 soap_in__ns5__GetActionRulesResponse(struct soap *soap, const char *tag, _ns5__GetActionRulesResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns5__GetActionRulesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__GetActionRulesResponse, sizeof(_ns5__GetActionRulesResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns5__GetActionRulesResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns5__GetActionRulesResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ActionRules1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ActionRules1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons5__ActionRules(soap, "ns5:ActionRules", &a->_ns5__GetActionRulesResponse::ActionRules, "ns5:ActionRules"))
				{	soap_flag_ActionRules1--;
					continue;
				}
			}
			soap_check_result(soap, "ns5:ActionRules");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_ns5__GetActionRulesResponse::ActionRules))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns5__GetActionRulesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__GetActionRulesResponse, SOAP_TYPE__ns5__GetActionRulesResponse, sizeof(_ns5__GetActionRulesResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns5__GetActionRulesResponse * SOAP_FMAC2 soap_instantiate__ns5__GetActionRulesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns5__GetActionRulesResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns5__GetActionRulesResponse *p;
	size_t k = sizeof(_ns5__GetActionRulesResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns5__GetActionRulesResponse);
		if (p)
			((_ns5__GetActionRulesResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns5__GetActionRulesResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns5__GetActionRulesResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns5__GetActionRulesResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns5__GetActionRulesResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns5__GetActionRulesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns5__GetActionRulesResponse(soap, tag ? tag : "ns5:GetActionRulesResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns5__GetActionRulesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns5__GetActionRulesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns5__GetActionRulesResponse * SOAP_FMAC4 soap_get__ns5__GetActionRulesResponse(struct soap *soap, _ns5__GetActionRulesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns5__GetActionRulesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns5__GetActionRules::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns5__GetActionRules::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns5__GetActionRules::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns5__GetActionRules(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns5__GetActionRules(struct soap *soap, const char *tag, int id, const _ns5__GetActionRules *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns5__GetActionRules), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns5__GetActionRules::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns5__GetActionRules(soap, tag, this, type);
}

SOAP_FMAC3 _ns5__GetActionRules * SOAP_FMAC4 soap_in__ns5__GetActionRules(struct soap *soap, const char *tag, _ns5__GetActionRules *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns5__GetActionRules *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__GetActionRules, sizeof(_ns5__GetActionRules), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns5__GetActionRules)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns5__GetActionRules *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns5__GetActionRules *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__GetActionRules, SOAP_TYPE__ns5__GetActionRules, sizeof(_ns5__GetActionRules), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns5__GetActionRules * SOAP_FMAC2 soap_instantiate__ns5__GetActionRules(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns5__GetActionRules(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns5__GetActionRules *p;
	size_t k = sizeof(_ns5__GetActionRules);
	if (n < 0)
	{	p = SOAP_NEW(_ns5__GetActionRules);
		if (p)
			((_ns5__GetActionRules*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns5__GetActionRules, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns5__GetActionRules*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns5__GetActionRules location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns5__GetActionRules, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns5__GetActionRules::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns5__GetActionRules(soap, tag ? tag : "ns5:GetActionRules", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns5__GetActionRules::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns5__GetActionRules(soap, this, tag, type);
}

SOAP_FMAC3 _ns5__GetActionRules * SOAP_FMAC4 soap_get__ns5__GetActionRules(struct soap *soap, _ns5__GetActionRules *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns5__GetActionRules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns5__AddActionRuleResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__integer(soap, &this->_ns5__AddActionRuleResponse::RuleID);
	/* transient soap skipped */
}

void _ns5__AddActionRuleResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_ns5__AddActionRuleResponse::RuleID, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &this->_ns5__AddActionRuleResponse::RuleID);
#endif
}

int _ns5__AddActionRuleResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns5__AddActionRuleResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns5__AddActionRuleResponse(struct soap *soap, const char *tag, int id, const _ns5__AddActionRuleResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns5__AddActionRuleResponse), type))
		return soap->error;
	soap_element_result(soap, "ns5:RuleID");
	if (soap_out_xsd__integer(soap, "ns5:RuleID", -1, &a->_ns5__AddActionRuleResponse::RuleID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns5__AddActionRuleResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns5__AddActionRuleResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns5__AddActionRuleResponse * SOAP_FMAC4 soap_in__ns5__AddActionRuleResponse(struct soap *soap, const char *tag, _ns5__AddActionRuleResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns5__AddActionRuleResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__AddActionRuleResponse, sizeof(_ns5__AddActionRuleResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns5__AddActionRuleResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns5__AddActionRuleResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_RuleID1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RuleID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__integer(soap, "ns5:RuleID", &a->_ns5__AddActionRuleResponse::RuleID, "xsd:integer"))
				{	soap_flag_RuleID1--;
					continue;
				}
			}
			soap_check_result(soap, "ns5:RuleID");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RuleID1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns5__AddActionRuleResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__AddActionRuleResponse, SOAP_TYPE__ns5__AddActionRuleResponse, sizeof(_ns5__AddActionRuleResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns5__AddActionRuleResponse * SOAP_FMAC2 soap_instantiate__ns5__AddActionRuleResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns5__AddActionRuleResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns5__AddActionRuleResponse *p;
	size_t k = sizeof(_ns5__AddActionRuleResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns5__AddActionRuleResponse);
		if (p)
			((_ns5__AddActionRuleResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns5__AddActionRuleResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns5__AddActionRuleResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns5__AddActionRuleResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns5__AddActionRuleResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns5__AddActionRuleResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns5__AddActionRuleResponse(soap, tag ? tag : "ns5:AddActionRuleResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns5__AddActionRuleResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns5__AddActionRuleResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns5__AddActionRuleResponse * SOAP_FMAC4 soap_get__ns5__AddActionRuleResponse(struct soap *soap, _ns5__AddActionRuleResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns5__AddActionRuleResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns5__AddActionRule::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns5__AddActionRule::NewActionRule = NULL;
	/* transient soap skipped */
}

void _ns5__AddActionRule::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons5__NewActionRule(soap, &this->_ns5__AddActionRule::NewActionRule);
#endif
}

int _ns5__AddActionRule::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns5__AddActionRule(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns5__AddActionRule(struct soap *soap, const char *tag, int id, const _ns5__AddActionRule *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns5__AddActionRule), type))
		return soap->error;
	if (!a->_ns5__AddActionRule::NewActionRule)
	{	if (soap_element_empty(soap, "ns5:NewActionRule"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons5__NewActionRule(soap, "ns5:NewActionRule", -1, &a->_ns5__AddActionRule::NewActionRule, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns5__AddActionRule::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns5__AddActionRule(soap, tag, this, type);
}

SOAP_FMAC3 _ns5__AddActionRule * SOAP_FMAC4 soap_in__ns5__AddActionRule(struct soap *soap, const char *tag, _ns5__AddActionRule *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns5__AddActionRule *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__AddActionRule, sizeof(_ns5__AddActionRule), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns5__AddActionRule)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns5__AddActionRule *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_NewActionRule1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_NewActionRule1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons5__NewActionRule(soap, "ns5:NewActionRule", &a->_ns5__AddActionRule::NewActionRule, "ns5:NewActionRule"))
				{	soap_flag_NewActionRule1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_ns5__AddActionRule::NewActionRule))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns5__AddActionRule *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__AddActionRule, SOAP_TYPE__ns5__AddActionRule, sizeof(_ns5__AddActionRule), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns5__AddActionRule * SOAP_FMAC2 soap_instantiate__ns5__AddActionRule(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns5__AddActionRule(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns5__AddActionRule *p;
	size_t k = sizeof(_ns5__AddActionRule);
	if (n < 0)
	{	p = SOAP_NEW(_ns5__AddActionRule);
		if (p)
			((_ns5__AddActionRule*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns5__AddActionRule, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns5__AddActionRule*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns5__AddActionRule location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns5__AddActionRule, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns5__AddActionRule::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns5__AddActionRule(soap, tag ? tag : "ns5:AddActionRule", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns5__AddActionRule::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns5__AddActionRule(soap, this, tag, type);
}

SOAP_FMAC3 _ns5__AddActionRule * SOAP_FMAC4 soap_get__ns5__AddActionRule(struct soap *soap, _ns5__AddActionRule *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns5__AddActionRule(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns5__GetRecipientConfigurationsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns5__GetRecipientConfigurationsResponse::RecipientConfigurations = NULL;
	/* transient soap skipped */
}

void _ns5__GetRecipientConfigurationsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons5__RecipientConfigurations(soap, &this->_ns5__GetRecipientConfigurationsResponse::RecipientConfigurations);
#endif
}

int _ns5__GetRecipientConfigurationsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns5__GetRecipientConfigurationsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns5__GetRecipientConfigurationsResponse(struct soap *soap, const char *tag, int id, const _ns5__GetRecipientConfigurationsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns5__GetRecipientConfigurationsResponse), type))
		return soap->error;
	if (a->RecipientConfigurations)
		soap_element_result(soap, "ns5:RecipientConfigurations");
	if (!a->_ns5__GetRecipientConfigurationsResponse::RecipientConfigurations)
	{	if (soap_element_empty(soap, "ns5:RecipientConfigurations"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons5__RecipientConfigurations(soap, "ns5:RecipientConfigurations", -1, &a->_ns5__GetRecipientConfigurationsResponse::RecipientConfigurations, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns5__GetRecipientConfigurationsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns5__GetRecipientConfigurationsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns5__GetRecipientConfigurationsResponse * SOAP_FMAC4 soap_in__ns5__GetRecipientConfigurationsResponse(struct soap *soap, const char *tag, _ns5__GetRecipientConfigurationsResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns5__GetRecipientConfigurationsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__GetRecipientConfigurationsResponse, sizeof(_ns5__GetRecipientConfigurationsResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns5__GetRecipientConfigurationsResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns5__GetRecipientConfigurationsResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_RecipientConfigurations1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RecipientConfigurations1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons5__RecipientConfigurations(soap, "ns5:RecipientConfigurations", &a->_ns5__GetRecipientConfigurationsResponse::RecipientConfigurations, "ns5:RecipientConfigurations"))
				{	soap_flag_RecipientConfigurations1--;
					continue;
				}
			}
			soap_check_result(soap, "ns5:RecipientConfigurations");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_ns5__GetRecipientConfigurationsResponse::RecipientConfigurations))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns5__GetRecipientConfigurationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__GetRecipientConfigurationsResponse, SOAP_TYPE__ns5__GetRecipientConfigurationsResponse, sizeof(_ns5__GetRecipientConfigurationsResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns5__GetRecipientConfigurationsResponse * SOAP_FMAC2 soap_instantiate__ns5__GetRecipientConfigurationsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns5__GetRecipientConfigurationsResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns5__GetRecipientConfigurationsResponse *p;
	size_t k = sizeof(_ns5__GetRecipientConfigurationsResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns5__GetRecipientConfigurationsResponse);
		if (p)
			((_ns5__GetRecipientConfigurationsResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns5__GetRecipientConfigurationsResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns5__GetRecipientConfigurationsResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns5__GetRecipientConfigurationsResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns5__GetRecipientConfigurationsResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns5__GetRecipientConfigurationsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns5__GetRecipientConfigurationsResponse(soap, tag ? tag : "ns5:GetRecipientConfigurationsResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns5__GetRecipientConfigurationsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns5__GetRecipientConfigurationsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns5__GetRecipientConfigurationsResponse * SOAP_FMAC4 soap_get__ns5__GetRecipientConfigurationsResponse(struct soap *soap, _ns5__GetRecipientConfigurationsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns5__GetRecipientConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns5__GetRecipientConfigurations::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns5__GetRecipientConfigurations::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns5__GetRecipientConfigurations::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns5__GetRecipientConfigurations(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns5__GetRecipientConfigurations(struct soap *soap, const char *tag, int id, const _ns5__GetRecipientConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns5__GetRecipientConfigurations), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns5__GetRecipientConfigurations::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns5__GetRecipientConfigurations(soap, tag, this, type);
}

SOAP_FMAC3 _ns5__GetRecipientConfigurations * SOAP_FMAC4 soap_in__ns5__GetRecipientConfigurations(struct soap *soap, const char *tag, _ns5__GetRecipientConfigurations *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns5__GetRecipientConfigurations *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__GetRecipientConfigurations, sizeof(_ns5__GetRecipientConfigurations), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns5__GetRecipientConfigurations)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns5__GetRecipientConfigurations *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns5__GetRecipientConfigurations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__GetRecipientConfigurations, SOAP_TYPE__ns5__GetRecipientConfigurations, sizeof(_ns5__GetRecipientConfigurations), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns5__GetRecipientConfigurations * SOAP_FMAC2 soap_instantiate__ns5__GetRecipientConfigurations(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns5__GetRecipientConfigurations(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns5__GetRecipientConfigurations *p;
	size_t k = sizeof(_ns5__GetRecipientConfigurations);
	if (n < 0)
	{	p = SOAP_NEW(_ns5__GetRecipientConfigurations);
		if (p)
			((_ns5__GetRecipientConfigurations*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns5__GetRecipientConfigurations, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns5__GetRecipientConfigurations*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns5__GetRecipientConfigurations location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns5__GetRecipientConfigurations, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns5__GetRecipientConfigurations::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns5__GetRecipientConfigurations(soap, tag ? tag : "ns5:GetRecipientConfigurations", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns5__GetRecipientConfigurations::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns5__GetRecipientConfigurations(soap, this, tag, type);
}

SOAP_FMAC3 _ns5__GetRecipientConfigurations * SOAP_FMAC4 soap_get__ns5__GetRecipientConfigurations(struct soap *soap, _ns5__GetRecipientConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns5__GetRecipientConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns5__RemoveRecipientConfigurationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns5__RemoveRecipientConfigurationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns5__RemoveRecipientConfigurationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns5__RemoveRecipientConfigurationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns5__RemoveRecipientConfigurationResponse(struct soap *soap, const char *tag, int id, const _ns5__RemoveRecipientConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns5__RemoveRecipientConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns5__RemoveRecipientConfigurationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns5__RemoveRecipientConfigurationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns5__RemoveRecipientConfigurationResponse * SOAP_FMAC4 soap_in__ns5__RemoveRecipientConfigurationResponse(struct soap *soap, const char *tag, _ns5__RemoveRecipientConfigurationResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns5__RemoveRecipientConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__RemoveRecipientConfigurationResponse, sizeof(_ns5__RemoveRecipientConfigurationResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns5__RemoveRecipientConfigurationResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns5__RemoveRecipientConfigurationResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns5__RemoveRecipientConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__RemoveRecipientConfigurationResponse, SOAP_TYPE__ns5__RemoveRecipientConfigurationResponse, sizeof(_ns5__RemoveRecipientConfigurationResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns5__RemoveRecipientConfigurationResponse * SOAP_FMAC2 soap_instantiate__ns5__RemoveRecipientConfigurationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns5__RemoveRecipientConfigurationResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns5__RemoveRecipientConfigurationResponse *p;
	size_t k = sizeof(_ns5__RemoveRecipientConfigurationResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns5__RemoveRecipientConfigurationResponse);
		if (p)
			((_ns5__RemoveRecipientConfigurationResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns5__RemoveRecipientConfigurationResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns5__RemoveRecipientConfigurationResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns5__RemoveRecipientConfigurationResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns5__RemoveRecipientConfigurationResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns5__RemoveRecipientConfigurationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns5__RemoveRecipientConfigurationResponse(soap, tag ? tag : "ns5:RemoveRecipientConfigurationResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns5__RemoveRecipientConfigurationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns5__RemoveRecipientConfigurationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns5__RemoveRecipientConfigurationResponse * SOAP_FMAC4 soap_get__ns5__RemoveRecipientConfigurationResponse(struct soap *soap, _ns5__RemoveRecipientConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns5__RemoveRecipientConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns5__RemoveRecipientConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__integer(soap, &this->_ns5__RemoveRecipientConfiguration::ConfigurationID);
	/* transient soap skipped */
}

void _ns5__RemoveRecipientConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_ns5__RemoveRecipientConfiguration::ConfigurationID, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &this->_ns5__RemoveRecipientConfiguration::ConfigurationID);
#endif
}

int _ns5__RemoveRecipientConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns5__RemoveRecipientConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns5__RemoveRecipientConfiguration(struct soap *soap, const char *tag, int id, const _ns5__RemoveRecipientConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns5__RemoveRecipientConfiguration), type))
		return soap->error;
	if (soap_out_xsd__integer(soap, "ns5:ConfigurationID", -1, &a->_ns5__RemoveRecipientConfiguration::ConfigurationID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns5__RemoveRecipientConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns5__RemoveRecipientConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 _ns5__RemoveRecipientConfiguration * SOAP_FMAC4 soap_in__ns5__RemoveRecipientConfiguration(struct soap *soap, const char *tag, _ns5__RemoveRecipientConfiguration *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns5__RemoveRecipientConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__RemoveRecipientConfiguration, sizeof(_ns5__RemoveRecipientConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns5__RemoveRecipientConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns5__RemoveRecipientConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ConfigurationID1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConfigurationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__integer(soap, "ns5:ConfigurationID", &a->_ns5__RemoveRecipientConfiguration::ConfigurationID, "xsd:integer"))
				{	soap_flag_ConfigurationID1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ConfigurationID1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns5__RemoveRecipientConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__RemoveRecipientConfiguration, SOAP_TYPE__ns5__RemoveRecipientConfiguration, sizeof(_ns5__RemoveRecipientConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns5__RemoveRecipientConfiguration * SOAP_FMAC2 soap_instantiate__ns5__RemoveRecipientConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns5__RemoveRecipientConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns5__RemoveRecipientConfiguration *p;
	size_t k = sizeof(_ns5__RemoveRecipientConfiguration);
	if (n < 0)
	{	p = SOAP_NEW(_ns5__RemoveRecipientConfiguration);
		if (p)
			((_ns5__RemoveRecipientConfiguration*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns5__RemoveRecipientConfiguration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns5__RemoveRecipientConfiguration*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns5__RemoveRecipientConfiguration location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns5__RemoveRecipientConfiguration, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns5__RemoveRecipientConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns5__RemoveRecipientConfiguration(soap, tag ? tag : "ns5:RemoveRecipientConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns5__RemoveRecipientConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns5__RemoveRecipientConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 _ns5__RemoveRecipientConfiguration * SOAP_FMAC4 soap_get__ns5__RemoveRecipientConfiguration(struct soap *soap, _ns5__RemoveRecipientConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns5__RemoveRecipientConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns5__AddRecipientConfigurationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__integer(soap, &this->_ns5__AddRecipientConfigurationResponse::ConfigurationID);
	/* transient soap skipped */
}

void _ns5__AddRecipientConfigurationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_ns5__AddRecipientConfigurationResponse::ConfigurationID, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &this->_ns5__AddRecipientConfigurationResponse::ConfigurationID);
#endif
}

int _ns5__AddRecipientConfigurationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns5__AddRecipientConfigurationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns5__AddRecipientConfigurationResponse(struct soap *soap, const char *tag, int id, const _ns5__AddRecipientConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns5__AddRecipientConfigurationResponse), type))
		return soap->error;
	soap_element_result(soap, "ns5:ConfigurationID");
	if (soap_out_xsd__integer(soap, "ns5:ConfigurationID", -1, &a->_ns5__AddRecipientConfigurationResponse::ConfigurationID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns5__AddRecipientConfigurationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns5__AddRecipientConfigurationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns5__AddRecipientConfigurationResponse * SOAP_FMAC4 soap_in__ns5__AddRecipientConfigurationResponse(struct soap *soap, const char *tag, _ns5__AddRecipientConfigurationResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns5__AddRecipientConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__AddRecipientConfigurationResponse, sizeof(_ns5__AddRecipientConfigurationResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns5__AddRecipientConfigurationResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns5__AddRecipientConfigurationResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ConfigurationID1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConfigurationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__integer(soap, "ns5:ConfigurationID", &a->_ns5__AddRecipientConfigurationResponse::ConfigurationID, "xsd:integer"))
				{	soap_flag_ConfigurationID1--;
					continue;
				}
			}
			soap_check_result(soap, "ns5:ConfigurationID");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ConfigurationID1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns5__AddRecipientConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__AddRecipientConfigurationResponse, SOAP_TYPE__ns5__AddRecipientConfigurationResponse, sizeof(_ns5__AddRecipientConfigurationResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns5__AddRecipientConfigurationResponse * SOAP_FMAC2 soap_instantiate__ns5__AddRecipientConfigurationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns5__AddRecipientConfigurationResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns5__AddRecipientConfigurationResponse *p;
	size_t k = sizeof(_ns5__AddRecipientConfigurationResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns5__AddRecipientConfigurationResponse);
		if (p)
			((_ns5__AddRecipientConfigurationResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns5__AddRecipientConfigurationResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns5__AddRecipientConfigurationResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns5__AddRecipientConfigurationResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns5__AddRecipientConfigurationResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns5__AddRecipientConfigurationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns5__AddRecipientConfigurationResponse(soap, tag ? tag : "ns5:AddRecipientConfigurationResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns5__AddRecipientConfigurationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns5__AddRecipientConfigurationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns5__AddRecipientConfigurationResponse * SOAP_FMAC4 soap_get__ns5__AddRecipientConfigurationResponse(struct soap *soap, _ns5__AddRecipientConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns5__AddRecipientConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns5__AddRecipientConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns5__AddRecipientConfiguration::NewRecipientConfiguration = NULL;
	/* transient soap skipped */
}

void _ns5__AddRecipientConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons5__NewRecipientConfiguration(soap, &this->_ns5__AddRecipientConfiguration::NewRecipientConfiguration);
#endif
}

int _ns5__AddRecipientConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns5__AddRecipientConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns5__AddRecipientConfiguration(struct soap *soap, const char *tag, int id, const _ns5__AddRecipientConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns5__AddRecipientConfiguration), type))
		return soap->error;
	if (!a->_ns5__AddRecipientConfiguration::NewRecipientConfiguration)
	{	if (soap_element_empty(soap, "ns5:NewRecipientConfiguration"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons5__NewRecipientConfiguration(soap, "ns5:NewRecipientConfiguration", -1, &a->_ns5__AddRecipientConfiguration::NewRecipientConfiguration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns5__AddRecipientConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns5__AddRecipientConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 _ns5__AddRecipientConfiguration * SOAP_FMAC4 soap_in__ns5__AddRecipientConfiguration(struct soap *soap, const char *tag, _ns5__AddRecipientConfiguration *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns5__AddRecipientConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__AddRecipientConfiguration, sizeof(_ns5__AddRecipientConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns5__AddRecipientConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns5__AddRecipientConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_NewRecipientConfiguration1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_NewRecipientConfiguration1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons5__NewRecipientConfiguration(soap, "ns5:NewRecipientConfiguration", &a->_ns5__AddRecipientConfiguration::NewRecipientConfiguration, "ns5:NewRecipientConfiguration"))
				{	soap_flag_NewRecipientConfiguration1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_ns5__AddRecipientConfiguration::NewRecipientConfiguration))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns5__AddRecipientConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__AddRecipientConfiguration, SOAP_TYPE__ns5__AddRecipientConfiguration, sizeof(_ns5__AddRecipientConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns5__AddRecipientConfiguration * SOAP_FMAC2 soap_instantiate__ns5__AddRecipientConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns5__AddRecipientConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns5__AddRecipientConfiguration *p;
	size_t k = sizeof(_ns5__AddRecipientConfiguration);
	if (n < 0)
	{	p = SOAP_NEW(_ns5__AddRecipientConfiguration);
		if (p)
			((_ns5__AddRecipientConfiguration*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns5__AddRecipientConfiguration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns5__AddRecipientConfiguration*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns5__AddRecipientConfiguration location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns5__AddRecipientConfiguration, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns5__AddRecipientConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns5__AddRecipientConfiguration(soap, tag ? tag : "ns5:AddRecipientConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns5__AddRecipientConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns5__AddRecipientConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 _ns5__AddRecipientConfiguration * SOAP_FMAC4 soap_get__ns5__AddRecipientConfiguration(struct soap *soap, _ns5__AddRecipientConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns5__AddRecipientConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns5__GetRecipientTemplatesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns5__GetRecipientTemplatesResponse::RecipientTemplates = NULL;
	/* transient soap skipped */
}

void _ns5__GetRecipientTemplatesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons5__RecipientTemplates(soap, &this->_ns5__GetRecipientTemplatesResponse::RecipientTemplates);
#endif
}

int _ns5__GetRecipientTemplatesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns5__GetRecipientTemplatesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns5__GetRecipientTemplatesResponse(struct soap *soap, const char *tag, int id, const _ns5__GetRecipientTemplatesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns5__GetRecipientTemplatesResponse), type))
		return soap->error;
	if (a->RecipientTemplates)
		soap_element_result(soap, "ns5:RecipientTemplates");
	if (!a->_ns5__GetRecipientTemplatesResponse::RecipientTemplates)
	{	if (soap_element_empty(soap, "ns5:RecipientTemplates"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons5__RecipientTemplates(soap, "ns5:RecipientTemplates", -1, &a->_ns5__GetRecipientTemplatesResponse::RecipientTemplates, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns5__GetRecipientTemplatesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns5__GetRecipientTemplatesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns5__GetRecipientTemplatesResponse * SOAP_FMAC4 soap_in__ns5__GetRecipientTemplatesResponse(struct soap *soap, const char *tag, _ns5__GetRecipientTemplatesResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns5__GetRecipientTemplatesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__GetRecipientTemplatesResponse, sizeof(_ns5__GetRecipientTemplatesResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns5__GetRecipientTemplatesResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns5__GetRecipientTemplatesResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_RecipientTemplates1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RecipientTemplates1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons5__RecipientTemplates(soap, "ns5:RecipientTemplates", &a->_ns5__GetRecipientTemplatesResponse::RecipientTemplates, "ns5:RecipientTemplates"))
				{	soap_flag_RecipientTemplates1--;
					continue;
				}
			}
			soap_check_result(soap, "ns5:RecipientTemplates");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_ns5__GetRecipientTemplatesResponse::RecipientTemplates))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns5__GetRecipientTemplatesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__GetRecipientTemplatesResponse, SOAP_TYPE__ns5__GetRecipientTemplatesResponse, sizeof(_ns5__GetRecipientTemplatesResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns5__GetRecipientTemplatesResponse * SOAP_FMAC2 soap_instantiate__ns5__GetRecipientTemplatesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns5__GetRecipientTemplatesResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns5__GetRecipientTemplatesResponse *p;
	size_t k = sizeof(_ns5__GetRecipientTemplatesResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns5__GetRecipientTemplatesResponse);
		if (p)
			((_ns5__GetRecipientTemplatesResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns5__GetRecipientTemplatesResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns5__GetRecipientTemplatesResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns5__GetRecipientTemplatesResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns5__GetRecipientTemplatesResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns5__GetRecipientTemplatesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns5__GetRecipientTemplatesResponse(soap, tag ? tag : "ns5:GetRecipientTemplatesResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns5__GetRecipientTemplatesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns5__GetRecipientTemplatesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns5__GetRecipientTemplatesResponse * SOAP_FMAC4 soap_get__ns5__GetRecipientTemplatesResponse(struct soap *soap, _ns5__GetRecipientTemplatesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns5__GetRecipientTemplatesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns5__GetRecipientTemplates::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns5__GetRecipientTemplates::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns5__GetRecipientTemplates::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns5__GetRecipientTemplates(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns5__GetRecipientTemplates(struct soap *soap, const char *tag, int id, const _ns5__GetRecipientTemplates *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns5__GetRecipientTemplates), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns5__GetRecipientTemplates::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns5__GetRecipientTemplates(soap, tag, this, type);
}

SOAP_FMAC3 _ns5__GetRecipientTemplates * SOAP_FMAC4 soap_in__ns5__GetRecipientTemplates(struct soap *soap, const char *tag, _ns5__GetRecipientTemplates *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns5__GetRecipientTemplates *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__GetRecipientTemplates, sizeof(_ns5__GetRecipientTemplates), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns5__GetRecipientTemplates)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns5__GetRecipientTemplates *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns5__GetRecipientTemplates *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__GetRecipientTemplates, SOAP_TYPE__ns5__GetRecipientTemplates, sizeof(_ns5__GetRecipientTemplates), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns5__GetRecipientTemplates * SOAP_FMAC2 soap_instantiate__ns5__GetRecipientTemplates(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns5__GetRecipientTemplates(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns5__GetRecipientTemplates *p;
	size_t k = sizeof(_ns5__GetRecipientTemplates);
	if (n < 0)
	{	p = SOAP_NEW(_ns5__GetRecipientTemplates);
		if (p)
			((_ns5__GetRecipientTemplates*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns5__GetRecipientTemplates, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns5__GetRecipientTemplates*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns5__GetRecipientTemplates location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns5__GetRecipientTemplates, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns5__GetRecipientTemplates::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns5__GetRecipientTemplates(soap, tag ? tag : "ns5:GetRecipientTemplates", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns5__GetRecipientTemplates::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns5__GetRecipientTemplates(soap, this, tag, type);
}

SOAP_FMAC3 _ns5__GetRecipientTemplates * SOAP_FMAC4 soap_get__ns5__GetRecipientTemplates(struct soap *soap, _ns5__GetRecipientTemplates *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns5__GetRecipientTemplates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns5__GetActionConfigurationsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns5__GetActionConfigurationsResponse::ActionConfigurations = NULL;
	/* transient soap skipped */
}

void _ns5__GetActionConfigurationsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons5__ActionConfigurations(soap, &this->_ns5__GetActionConfigurationsResponse::ActionConfigurations);
#endif
}

int _ns5__GetActionConfigurationsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns5__GetActionConfigurationsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns5__GetActionConfigurationsResponse(struct soap *soap, const char *tag, int id, const _ns5__GetActionConfigurationsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns5__GetActionConfigurationsResponse), type))
		return soap->error;
	if (a->ActionConfigurations)
		soap_element_result(soap, "ns5:ActionConfigurations");
	if (!a->_ns5__GetActionConfigurationsResponse::ActionConfigurations)
	{	if (soap_element_empty(soap, "ns5:ActionConfigurations"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons5__ActionConfigurations(soap, "ns5:ActionConfigurations", -1, &a->_ns5__GetActionConfigurationsResponse::ActionConfigurations, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns5__GetActionConfigurationsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns5__GetActionConfigurationsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns5__GetActionConfigurationsResponse * SOAP_FMAC4 soap_in__ns5__GetActionConfigurationsResponse(struct soap *soap, const char *tag, _ns5__GetActionConfigurationsResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns5__GetActionConfigurationsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__GetActionConfigurationsResponse, sizeof(_ns5__GetActionConfigurationsResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns5__GetActionConfigurationsResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns5__GetActionConfigurationsResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ActionConfigurations1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ActionConfigurations1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons5__ActionConfigurations(soap, "ns5:ActionConfigurations", &a->_ns5__GetActionConfigurationsResponse::ActionConfigurations, "ns5:ActionConfigurations"))
				{	soap_flag_ActionConfigurations1--;
					continue;
				}
			}
			soap_check_result(soap, "ns5:ActionConfigurations");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_ns5__GetActionConfigurationsResponse::ActionConfigurations))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns5__GetActionConfigurationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__GetActionConfigurationsResponse, SOAP_TYPE__ns5__GetActionConfigurationsResponse, sizeof(_ns5__GetActionConfigurationsResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns5__GetActionConfigurationsResponse * SOAP_FMAC2 soap_instantiate__ns5__GetActionConfigurationsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns5__GetActionConfigurationsResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns5__GetActionConfigurationsResponse *p;
	size_t k = sizeof(_ns5__GetActionConfigurationsResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns5__GetActionConfigurationsResponse);
		if (p)
			((_ns5__GetActionConfigurationsResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns5__GetActionConfigurationsResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns5__GetActionConfigurationsResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns5__GetActionConfigurationsResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns5__GetActionConfigurationsResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns5__GetActionConfigurationsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns5__GetActionConfigurationsResponse(soap, tag ? tag : "ns5:GetActionConfigurationsResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns5__GetActionConfigurationsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns5__GetActionConfigurationsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns5__GetActionConfigurationsResponse * SOAP_FMAC4 soap_get__ns5__GetActionConfigurationsResponse(struct soap *soap, _ns5__GetActionConfigurationsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns5__GetActionConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns5__GetActionConfigurations::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns5__GetActionConfigurations::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns5__GetActionConfigurations::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns5__GetActionConfigurations(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns5__GetActionConfigurations(struct soap *soap, const char *tag, int id, const _ns5__GetActionConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns5__GetActionConfigurations), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns5__GetActionConfigurations::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns5__GetActionConfigurations(soap, tag, this, type);
}

SOAP_FMAC3 _ns5__GetActionConfigurations * SOAP_FMAC4 soap_in__ns5__GetActionConfigurations(struct soap *soap, const char *tag, _ns5__GetActionConfigurations *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns5__GetActionConfigurations *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__GetActionConfigurations, sizeof(_ns5__GetActionConfigurations), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns5__GetActionConfigurations)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns5__GetActionConfigurations *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns5__GetActionConfigurations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__GetActionConfigurations, SOAP_TYPE__ns5__GetActionConfigurations, sizeof(_ns5__GetActionConfigurations), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns5__GetActionConfigurations * SOAP_FMAC2 soap_instantiate__ns5__GetActionConfigurations(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns5__GetActionConfigurations(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns5__GetActionConfigurations *p;
	size_t k = sizeof(_ns5__GetActionConfigurations);
	if (n < 0)
	{	p = SOAP_NEW(_ns5__GetActionConfigurations);
		if (p)
			((_ns5__GetActionConfigurations*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns5__GetActionConfigurations, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns5__GetActionConfigurations*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns5__GetActionConfigurations location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns5__GetActionConfigurations, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns5__GetActionConfigurations::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns5__GetActionConfigurations(soap, tag ? tag : "ns5:GetActionConfigurations", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns5__GetActionConfigurations::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns5__GetActionConfigurations(soap, this, tag, type);
}

SOAP_FMAC3 _ns5__GetActionConfigurations * SOAP_FMAC4 soap_get__ns5__GetActionConfigurations(struct soap *soap, _ns5__GetActionConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns5__GetActionConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns5__RemoveActionConfigurationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns5__RemoveActionConfigurationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns5__RemoveActionConfigurationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns5__RemoveActionConfigurationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns5__RemoveActionConfigurationResponse(struct soap *soap, const char *tag, int id, const _ns5__RemoveActionConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns5__RemoveActionConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns5__RemoveActionConfigurationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns5__RemoveActionConfigurationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns5__RemoveActionConfigurationResponse * SOAP_FMAC4 soap_in__ns5__RemoveActionConfigurationResponse(struct soap *soap, const char *tag, _ns5__RemoveActionConfigurationResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns5__RemoveActionConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__RemoveActionConfigurationResponse, sizeof(_ns5__RemoveActionConfigurationResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns5__RemoveActionConfigurationResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns5__RemoveActionConfigurationResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns5__RemoveActionConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__RemoveActionConfigurationResponse, SOAP_TYPE__ns5__RemoveActionConfigurationResponse, sizeof(_ns5__RemoveActionConfigurationResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns5__RemoveActionConfigurationResponse * SOAP_FMAC2 soap_instantiate__ns5__RemoveActionConfigurationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns5__RemoveActionConfigurationResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns5__RemoveActionConfigurationResponse *p;
	size_t k = sizeof(_ns5__RemoveActionConfigurationResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns5__RemoveActionConfigurationResponse);
		if (p)
			((_ns5__RemoveActionConfigurationResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns5__RemoveActionConfigurationResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns5__RemoveActionConfigurationResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns5__RemoveActionConfigurationResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns5__RemoveActionConfigurationResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns5__RemoveActionConfigurationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns5__RemoveActionConfigurationResponse(soap, tag ? tag : "ns5:RemoveActionConfigurationResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns5__RemoveActionConfigurationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns5__RemoveActionConfigurationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns5__RemoveActionConfigurationResponse * SOAP_FMAC4 soap_get__ns5__RemoveActionConfigurationResponse(struct soap *soap, _ns5__RemoveActionConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns5__RemoveActionConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns5__RemoveActionConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__integer(soap, &this->_ns5__RemoveActionConfiguration::ConfigurationID);
	/* transient soap skipped */
}

void _ns5__RemoveActionConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_ns5__RemoveActionConfiguration::ConfigurationID, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &this->_ns5__RemoveActionConfiguration::ConfigurationID);
#endif
}

int _ns5__RemoveActionConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns5__RemoveActionConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns5__RemoveActionConfiguration(struct soap *soap, const char *tag, int id, const _ns5__RemoveActionConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns5__RemoveActionConfiguration), type))
		return soap->error;
	if (soap_out_xsd__integer(soap, "ns5:ConfigurationID", -1, &a->_ns5__RemoveActionConfiguration::ConfigurationID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns5__RemoveActionConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns5__RemoveActionConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 _ns5__RemoveActionConfiguration * SOAP_FMAC4 soap_in__ns5__RemoveActionConfiguration(struct soap *soap, const char *tag, _ns5__RemoveActionConfiguration *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns5__RemoveActionConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__RemoveActionConfiguration, sizeof(_ns5__RemoveActionConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns5__RemoveActionConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns5__RemoveActionConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ConfigurationID1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConfigurationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__integer(soap, "ns5:ConfigurationID", &a->_ns5__RemoveActionConfiguration::ConfigurationID, "xsd:integer"))
				{	soap_flag_ConfigurationID1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ConfigurationID1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns5__RemoveActionConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__RemoveActionConfiguration, SOAP_TYPE__ns5__RemoveActionConfiguration, sizeof(_ns5__RemoveActionConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns5__RemoveActionConfiguration * SOAP_FMAC2 soap_instantiate__ns5__RemoveActionConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns5__RemoveActionConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns5__RemoveActionConfiguration *p;
	size_t k = sizeof(_ns5__RemoveActionConfiguration);
	if (n < 0)
	{	p = SOAP_NEW(_ns5__RemoveActionConfiguration);
		if (p)
			((_ns5__RemoveActionConfiguration*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns5__RemoveActionConfiguration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns5__RemoveActionConfiguration*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns5__RemoveActionConfiguration location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns5__RemoveActionConfiguration, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns5__RemoveActionConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns5__RemoveActionConfiguration(soap, tag ? tag : "ns5:RemoveActionConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns5__RemoveActionConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns5__RemoveActionConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 _ns5__RemoveActionConfiguration * SOAP_FMAC4 soap_get__ns5__RemoveActionConfiguration(struct soap *soap, _ns5__RemoveActionConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns5__RemoveActionConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns5__AddActionConfigurationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__integer(soap, &this->_ns5__AddActionConfigurationResponse::ConfigurationID);
	/* transient soap skipped */
}

void _ns5__AddActionConfigurationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_ns5__AddActionConfigurationResponse::ConfigurationID, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &this->_ns5__AddActionConfigurationResponse::ConfigurationID);
#endif
}

int _ns5__AddActionConfigurationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns5__AddActionConfigurationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns5__AddActionConfigurationResponse(struct soap *soap, const char *tag, int id, const _ns5__AddActionConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns5__AddActionConfigurationResponse), type))
		return soap->error;
	soap_element_result(soap, "ns5:ConfigurationID");
	if (soap_out_xsd__integer(soap, "ns5:ConfigurationID", -1, &a->_ns5__AddActionConfigurationResponse::ConfigurationID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns5__AddActionConfigurationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns5__AddActionConfigurationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns5__AddActionConfigurationResponse * SOAP_FMAC4 soap_in__ns5__AddActionConfigurationResponse(struct soap *soap, const char *tag, _ns5__AddActionConfigurationResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns5__AddActionConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__AddActionConfigurationResponse, sizeof(_ns5__AddActionConfigurationResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns5__AddActionConfigurationResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns5__AddActionConfigurationResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ConfigurationID1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConfigurationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__integer(soap, "ns5:ConfigurationID", &a->_ns5__AddActionConfigurationResponse::ConfigurationID, "xsd:integer"))
				{	soap_flag_ConfigurationID1--;
					continue;
				}
			}
			soap_check_result(soap, "ns5:ConfigurationID");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ConfigurationID1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns5__AddActionConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__AddActionConfigurationResponse, SOAP_TYPE__ns5__AddActionConfigurationResponse, sizeof(_ns5__AddActionConfigurationResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns5__AddActionConfigurationResponse * SOAP_FMAC2 soap_instantiate__ns5__AddActionConfigurationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns5__AddActionConfigurationResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns5__AddActionConfigurationResponse *p;
	size_t k = sizeof(_ns5__AddActionConfigurationResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns5__AddActionConfigurationResponse);
		if (p)
			((_ns5__AddActionConfigurationResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns5__AddActionConfigurationResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns5__AddActionConfigurationResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns5__AddActionConfigurationResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns5__AddActionConfigurationResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns5__AddActionConfigurationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns5__AddActionConfigurationResponse(soap, tag ? tag : "ns5:AddActionConfigurationResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns5__AddActionConfigurationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns5__AddActionConfigurationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns5__AddActionConfigurationResponse * SOAP_FMAC4 soap_get__ns5__AddActionConfigurationResponse(struct soap *soap, _ns5__AddActionConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns5__AddActionConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns5__AddActionConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns5__AddActionConfiguration::NewActionConfiguration = NULL;
	/* transient soap skipped */
}

void _ns5__AddActionConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons5__NewActionConfiguration(soap, &this->_ns5__AddActionConfiguration::NewActionConfiguration);
#endif
}

int _ns5__AddActionConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns5__AddActionConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns5__AddActionConfiguration(struct soap *soap, const char *tag, int id, const _ns5__AddActionConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns5__AddActionConfiguration), type))
		return soap->error;
	if (!a->_ns5__AddActionConfiguration::NewActionConfiguration)
	{	if (soap_element_empty(soap, "ns5:NewActionConfiguration"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons5__NewActionConfiguration(soap, "ns5:NewActionConfiguration", -1, &a->_ns5__AddActionConfiguration::NewActionConfiguration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns5__AddActionConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns5__AddActionConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 _ns5__AddActionConfiguration * SOAP_FMAC4 soap_in__ns5__AddActionConfiguration(struct soap *soap, const char *tag, _ns5__AddActionConfiguration *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns5__AddActionConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__AddActionConfiguration, sizeof(_ns5__AddActionConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns5__AddActionConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns5__AddActionConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_NewActionConfiguration1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_NewActionConfiguration1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons5__NewActionConfiguration(soap, "ns5:NewActionConfiguration", &a->_ns5__AddActionConfiguration::NewActionConfiguration, "ns5:NewActionConfiguration"))
				{	soap_flag_NewActionConfiguration1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_ns5__AddActionConfiguration::NewActionConfiguration))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns5__AddActionConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__AddActionConfiguration, SOAP_TYPE__ns5__AddActionConfiguration, sizeof(_ns5__AddActionConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns5__AddActionConfiguration * SOAP_FMAC2 soap_instantiate__ns5__AddActionConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns5__AddActionConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns5__AddActionConfiguration *p;
	size_t k = sizeof(_ns5__AddActionConfiguration);
	if (n < 0)
	{	p = SOAP_NEW(_ns5__AddActionConfiguration);
		if (p)
			((_ns5__AddActionConfiguration*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns5__AddActionConfiguration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns5__AddActionConfiguration*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns5__AddActionConfiguration location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns5__AddActionConfiguration, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns5__AddActionConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns5__AddActionConfiguration(soap, tag ? tag : "ns5:AddActionConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns5__AddActionConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns5__AddActionConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 _ns5__AddActionConfiguration * SOAP_FMAC4 soap_get__ns5__AddActionConfiguration(struct soap *soap, _ns5__AddActionConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns5__AddActionConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns5__GetActionTemplatesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns5__GetActionTemplatesResponse::ActionTemplates = NULL;
	/* transient soap skipped */
}

void _ns5__GetActionTemplatesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons5__ActionTemplates(soap, &this->_ns5__GetActionTemplatesResponse::ActionTemplates);
#endif
}

int _ns5__GetActionTemplatesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns5__GetActionTemplatesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns5__GetActionTemplatesResponse(struct soap *soap, const char *tag, int id, const _ns5__GetActionTemplatesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns5__GetActionTemplatesResponse), type))
		return soap->error;
	if (a->ActionTemplates)
		soap_element_result(soap, "ns5:ActionTemplates");
	if (!a->_ns5__GetActionTemplatesResponse::ActionTemplates)
	{	if (soap_element_empty(soap, "ns5:ActionTemplates"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons5__ActionTemplates(soap, "ns5:ActionTemplates", -1, &a->_ns5__GetActionTemplatesResponse::ActionTemplates, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns5__GetActionTemplatesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns5__GetActionTemplatesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns5__GetActionTemplatesResponse * SOAP_FMAC4 soap_in__ns5__GetActionTemplatesResponse(struct soap *soap, const char *tag, _ns5__GetActionTemplatesResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns5__GetActionTemplatesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__GetActionTemplatesResponse, sizeof(_ns5__GetActionTemplatesResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns5__GetActionTemplatesResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns5__GetActionTemplatesResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ActionTemplates1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ActionTemplates1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons5__ActionTemplates(soap, "ns5:ActionTemplates", &a->_ns5__GetActionTemplatesResponse::ActionTemplates, "ns5:ActionTemplates"))
				{	soap_flag_ActionTemplates1--;
					continue;
				}
			}
			soap_check_result(soap, "ns5:ActionTemplates");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_ns5__GetActionTemplatesResponse::ActionTemplates))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns5__GetActionTemplatesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__GetActionTemplatesResponse, SOAP_TYPE__ns5__GetActionTemplatesResponse, sizeof(_ns5__GetActionTemplatesResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns5__GetActionTemplatesResponse * SOAP_FMAC2 soap_instantiate__ns5__GetActionTemplatesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns5__GetActionTemplatesResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns5__GetActionTemplatesResponse *p;
	size_t k = sizeof(_ns5__GetActionTemplatesResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns5__GetActionTemplatesResponse);
		if (p)
			((_ns5__GetActionTemplatesResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns5__GetActionTemplatesResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns5__GetActionTemplatesResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns5__GetActionTemplatesResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns5__GetActionTemplatesResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns5__GetActionTemplatesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns5__GetActionTemplatesResponse(soap, tag ? tag : "ns5:GetActionTemplatesResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns5__GetActionTemplatesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns5__GetActionTemplatesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns5__GetActionTemplatesResponse * SOAP_FMAC4 soap_get__ns5__GetActionTemplatesResponse(struct soap *soap, _ns5__GetActionTemplatesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns5__GetActionTemplatesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns5__GetActionTemplates::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns5__GetActionTemplates::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns5__GetActionTemplates::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns5__GetActionTemplates(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns5__GetActionTemplates(struct soap *soap, const char *tag, int id, const _ns5__GetActionTemplates *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns5__GetActionTemplates), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns5__GetActionTemplates::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns5__GetActionTemplates(soap, tag, this, type);
}

SOAP_FMAC3 _ns5__GetActionTemplates * SOAP_FMAC4 soap_in__ns5__GetActionTemplates(struct soap *soap, const char *tag, _ns5__GetActionTemplates *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns5__GetActionTemplates *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__GetActionTemplates, sizeof(_ns5__GetActionTemplates), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns5__GetActionTemplates)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns5__GetActionTemplates *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns5__GetActionTemplates *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__GetActionTemplates, SOAP_TYPE__ns5__GetActionTemplates, sizeof(_ns5__GetActionTemplates), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns5__GetActionTemplates * SOAP_FMAC2 soap_instantiate__ns5__GetActionTemplates(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns5__GetActionTemplates(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns5__GetActionTemplates *p;
	size_t k = sizeof(_ns5__GetActionTemplates);
	if (n < 0)
	{	p = SOAP_NEW(_ns5__GetActionTemplates);
		if (p)
			((_ns5__GetActionTemplates*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns5__GetActionTemplates, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns5__GetActionTemplates*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns5__GetActionTemplates location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns5__GetActionTemplates, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns5__GetActionTemplates::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns5__GetActionTemplates(soap, tag ? tag : "ns5:GetActionTemplates", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns5__GetActionTemplates::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns5__GetActionTemplates(soap, this, tag, type);
}

SOAP_FMAC3 _ns5__GetActionTemplates * SOAP_FMAC4 soap_get__ns5__GetActionTemplates(struct soap *soap, _ns5__GetActionTemplates *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns5__GetActionTemplates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns5__UsedActionRule::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__integer(soap, &this->ns5__UsedActionRule::ActionRuleID);
	this->ns5__UsedActionRule::ActionRuleName = NULL;
}

void ns5__UsedActionRule::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns5__UsedActionRule::ActionRuleID, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &this->ns5__UsedActionRule::ActionRuleID);
	soap_serialize_PointerTostd__string(soap, &this->ns5__UsedActionRule::ActionRuleName);
#endif
}

int ns5__UsedActionRule::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__UsedActionRule(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__UsedActionRule(struct soap *soap, const char *tag, int id, const ns5__UsedActionRule *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__UsedActionRule), type))
		return soap->error;
	if (soap_out_xsd__integer(soap, "ns5:ActionRuleID", -1, &a->ns5__UsedActionRule::ActionRuleID, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns5:ActionRuleName", -1, &a->ns5__UsedActionRule::ActionRuleName, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__UsedActionRule::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__UsedActionRule(soap, tag, this, type);
}

SOAP_FMAC3 ns5__UsedActionRule * SOAP_FMAC4 soap_in_ns5__UsedActionRule(struct soap *soap, const char *tag, ns5__UsedActionRule *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__UsedActionRule *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__UsedActionRule, sizeof(ns5__UsedActionRule), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns5__UsedActionRule)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns5__UsedActionRule *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_ActionRuleID1 = 1;
	size_t soap_flag_ActionRuleName1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ActionRuleID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__integer(soap, "ns5:ActionRuleID", &a->ns5__UsedActionRule::ActionRuleID, "xsd:integer"))
				{	soap_flag_ActionRuleID1--;
					continue;
				}
			}
			if (soap_flag_ActionRuleName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns5:ActionRuleName", &a->ns5__UsedActionRule::ActionRuleName, "xsd:string"))
				{	soap_flag_ActionRuleName1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ActionRuleID1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns5__UsedActionRule *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__UsedActionRule, SOAP_TYPE_ns5__UsedActionRule, sizeof(ns5__UsedActionRule), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns5__UsedActionRule * SOAP_FMAC2 soap_instantiate_ns5__UsedActionRule(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__UsedActionRule(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns5__UsedActionRule *p;
	size_t k = sizeof(ns5__UsedActionRule);
	if (n < 0)
	{	p = SOAP_NEW(ns5__UsedActionRule);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns5__UsedActionRule, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns5__UsedActionRule location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns5__UsedActionRule, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns5__UsedActionRule::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns5__UsedActionRule(soap, tag ? tag : "ns5:UsedActionRule", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__UsedActionRule::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__UsedActionRule(soap, this, tag, type);
}

SOAP_FMAC3 ns5__UsedActionRule * SOAP_FMAC4 soap_get_ns5__UsedActionRule(struct soap *soap, ns5__UsedActionRule *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__UsedActionRule(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns5__UsedByActionRules::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfPointerTons5__UsedActionRule(soap, &this->ns5__UsedByActionRules::ActionRule);
}

void ns5__UsedByActionRules::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons5__UsedActionRule(soap, &this->ns5__UsedByActionRules::ActionRule);
#endif
}

int ns5__UsedByActionRules::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__UsedByActionRules(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__UsedByActionRules(struct soap *soap, const char *tag, int id, const ns5__UsedByActionRules *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__UsedByActionRules), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons5__UsedActionRule(soap, "ns5:ActionRule", -1, &a->ns5__UsedByActionRules::ActionRule, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__UsedByActionRules::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__UsedByActionRules(soap, tag, this, type);
}

SOAP_FMAC3 ns5__UsedByActionRules * SOAP_FMAC4 soap_in_ns5__UsedByActionRules(struct soap *soap, const char *tag, ns5__UsedByActionRules *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__UsedByActionRules *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__UsedByActionRules, sizeof(ns5__UsedByActionRules), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns5__UsedByActionRules)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns5__UsedByActionRules *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons5__UsedActionRule(soap, "ns5:ActionRule", &a->ns5__UsedByActionRules::ActionRule, "ns5:UsedActionRule"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__UsedByActionRules *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__UsedByActionRules, SOAP_TYPE_ns5__UsedByActionRules, sizeof(ns5__UsedByActionRules), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns5__UsedByActionRules * SOAP_FMAC2 soap_instantiate_ns5__UsedByActionRules(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__UsedByActionRules(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns5__UsedByActionRules *p;
	size_t k = sizeof(ns5__UsedByActionRules);
	if (n < 0)
	{	p = SOAP_NEW(ns5__UsedByActionRules);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns5__UsedByActionRules, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns5__UsedByActionRules location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns5__UsedByActionRules, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns5__UsedByActionRules::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns5__UsedByActionRules(soap, tag ? tag : "ns5:UsedByActionRules", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__UsedByActionRules::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__UsedByActionRules(soap, this, tag, type);
}

SOAP_FMAC3 ns5__UsedByActionRules * SOAP_FMAC4 soap_get_ns5__UsedByActionRules(struct soap *soap, ns5__UsedByActionRules *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__UsedByActionRules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns5__UsedActionConfiguration::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__integer(soap, &this->ns5__UsedActionConfiguration::ActionConfigurationID);
	this->ns5__UsedActionConfiguration::ActionConfigurationName = NULL;
}

void ns5__UsedActionConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns5__UsedActionConfiguration::ActionConfigurationID, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &this->ns5__UsedActionConfiguration::ActionConfigurationID);
	soap_serialize_PointerTostd__string(soap, &this->ns5__UsedActionConfiguration::ActionConfigurationName);
#endif
}

int ns5__UsedActionConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__UsedActionConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__UsedActionConfiguration(struct soap *soap, const char *tag, int id, const ns5__UsedActionConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__UsedActionConfiguration), type))
		return soap->error;
	if (soap_out_xsd__integer(soap, "ns5:ActionConfigurationID", -1, &a->ns5__UsedActionConfiguration::ActionConfigurationID, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns5:ActionConfigurationName", -1, &a->ns5__UsedActionConfiguration::ActionConfigurationName, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__UsedActionConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__UsedActionConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 ns5__UsedActionConfiguration * SOAP_FMAC4 soap_in_ns5__UsedActionConfiguration(struct soap *soap, const char *tag, ns5__UsedActionConfiguration *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__UsedActionConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__UsedActionConfiguration, sizeof(ns5__UsedActionConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns5__UsedActionConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns5__UsedActionConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_ActionConfigurationID1 = 1;
	size_t soap_flag_ActionConfigurationName1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ActionConfigurationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__integer(soap, "ns5:ActionConfigurationID", &a->ns5__UsedActionConfiguration::ActionConfigurationID, "xsd:integer"))
				{	soap_flag_ActionConfigurationID1--;
					continue;
				}
			}
			if (soap_flag_ActionConfigurationName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns5:ActionConfigurationName", &a->ns5__UsedActionConfiguration::ActionConfigurationName, "xsd:string"))
				{	soap_flag_ActionConfigurationName1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ActionConfigurationID1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns5__UsedActionConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__UsedActionConfiguration, SOAP_TYPE_ns5__UsedActionConfiguration, sizeof(ns5__UsedActionConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns5__UsedActionConfiguration * SOAP_FMAC2 soap_instantiate_ns5__UsedActionConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__UsedActionConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns5__UsedActionConfiguration *p;
	size_t k = sizeof(ns5__UsedActionConfiguration);
	if (n < 0)
	{	p = SOAP_NEW(ns5__UsedActionConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns5__UsedActionConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns5__UsedActionConfiguration location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns5__UsedActionConfiguration, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns5__UsedActionConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns5__UsedActionConfiguration(soap, tag ? tag : "ns5:UsedActionConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__UsedActionConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__UsedActionConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 ns5__UsedActionConfiguration * SOAP_FMAC4 soap_get_ns5__UsedActionConfiguration(struct soap *soap, ns5__UsedActionConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__UsedActionConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns5__UsedByActionConfigurations::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfPointerTons5__UsedActionConfiguration(soap, &this->ns5__UsedByActionConfigurations::ActionConfiguration);
}

void ns5__UsedByActionConfigurations::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons5__UsedActionConfiguration(soap, &this->ns5__UsedByActionConfigurations::ActionConfiguration);
#endif
}

int ns5__UsedByActionConfigurations::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__UsedByActionConfigurations(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__UsedByActionConfigurations(struct soap *soap, const char *tag, int id, const ns5__UsedByActionConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__UsedByActionConfigurations), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons5__UsedActionConfiguration(soap, "ns5:ActionConfiguration", -1, &a->ns5__UsedByActionConfigurations::ActionConfiguration, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__UsedByActionConfigurations::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__UsedByActionConfigurations(soap, tag, this, type);
}

SOAP_FMAC3 ns5__UsedByActionConfigurations * SOAP_FMAC4 soap_in_ns5__UsedByActionConfigurations(struct soap *soap, const char *tag, ns5__UsedByActionConfigurations *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__UsedByActionConfigurations *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__UsedByActionConfigurations, sizeof(ns5__UsedByActionConfigurations), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns5__UsedByActionConfigurations)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns5__UsedByActionConfigurations *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons5__UsedActionConfiguration(soap, "ns5:ActionConfiguration", &a->ns5__UsedByActionConfigurations::ActionConfiguration, "ns5:UsedActionConfiguration"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__UsedByActionConfigurations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__UsedByActionConfigurations, SOAP_TYPE_ns5__UsedByActionConfigurations, sizeof(ns5__UsedByActionConfigurations), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns5__UsedByActionConfigurations * SOAP_FMAC2 soap_instantiate_ns5__UsedByActionConfigurations(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__UsedByActionConfigurations(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns5__UsedByActionConfigurations *p;
	size_t k = sizeof(ns5__UsedByActionConfigurations);
	if (n < 0)
	{	p = SOAP_NEW(ns5__UsedByActionConfigurations);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns5__UsedByActionConfigurations, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns5__UsedByActionConfigurations location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns5__UsedByActionConfigurations, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns5__UsedByActionConfigurations::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns5__UsedByActionConfigurations(soap, tag ? tag : "ns5:UsedByActionConfigurations", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__UsedByActionConfigurations::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__UsedByActionConfigurations(soap, this, tag, type);
}

SOAP_FMAC3 ns5__UsedByActionConfigurations * SOAP_FMAC4 soap_get_ns5__UsedByActionConfigurations(struct soap *soap, ns5__UsedByActionConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__UsedByActionConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns5__ActionTemplateParameter::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__string(soap, &this->ns5__ActionTemplateParameter::Name);
	soap_default_std__string(soap, &this->ns5__ActionTemplateParameter::Type);
}

void ns5__ActionTemplateParameter::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns5__ActionTemplateParameter::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__ActionTemplateParameter(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__ActionTemplateParameter(struct soap *soap, const char *tag, int id, const ns5__ActionTemplateParameter *a, const char *type)
{
	soap_set_attr(soap, "Name", soap_std__string2s(soap, ((ns5__ActionTemplateParameter*)a)->Name), 1);
	soap_set_attr(soap, "Type", soap_std__string2s(soap, ((ns5__ActionTemplateParameter*)a)->Type), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__ActionTemplateParameter), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__ActionTemplateParameter::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__ActionTemplateParameter(soap, tag, this, type);
}

SOAP_FMAC3 ns5__ActionTemplateParameter * SOAP_FMAC4 soap_in_ns5__ActionTemplateParameter(struct soap *soap, const char *tag, ns5__ActionTemplateParameter *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__ActionTemplateParameter *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__ActionTemplateParameter, sizeof(ns5__ActionTemplateParameter), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns5__ActionTemplateParameter)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns5__ActionTemplateParameter *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2std__string(soap, soap_attr_value(soap, "Name", 1, 1), &((ns5__ActionTemplateParameter*)a)->Name))
		return NULL;
	if (soap_s2std__string(soap, soap_attr_value(soap, "Type", 1, 1), &((ns5__ActionTemplateParameter*)a)->Type))
		return NULL;
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__ActionTemplateParameter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__ActionTemplateParameter, SOAP_TYPE_ns5__ActionTemplateParameter, sizeof(ns5__ActionTemplateParameter), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns5__ActionTemplateParameter * SOAP_FMAC2 soap_instantiate_ns5__ActionTemplateParameter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__ActionTemplateParameter(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns5__ActionTemplateParameter *p;
	size_t k = sizeof(ns5__ActionTemplateParameter);
	if (n < 0)
	{	p = SOAP_NEW(ns5__ActionTemplateParameter);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns5__ActionTemplateParameter, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns5__ActionTemplateParameter location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns5__ActionTemplateParameter, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns5__ActionTemplateParameter::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns5__ActionTemplateParameter(soap, tag ? tag : "ns5:ActionTemplateParameter", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__ActionTemplateParameter::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__ActionTemplateParameter(soap, this, tag, type);
}

SOAP_FMAC3 ns5__ActionTemplateParameter * SOAP_FMAC4 soap_get_ns5__ActionTemplateParameter(struct soap *soap, ns5__ActionTemplateParameter *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__ActionTemplateParameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns5__ActionTemplateParameters::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfPointerTons5__ActionTemplateParameter(soap, &this->ns5__ActionTemplateParameters::Parameter);
}

void ns5__ActionTemplateParameters::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons5__ActionTemplateParameter(soap, &this->ns5__ActionTemplateParameters::Parameter);
#endif
}

int ns5__ActionTemplateParameters::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__ActionTemplateParameters(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__ActionTemplateParameters(struct soap *soap, const char *tag, int id, const ns5__ActionTemplateParameters *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__ActionTemplateParameters), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons5__ActionTemplateParameter(soap, "ns5:Parameter", -1, &a->ns5__ActionTemplateParameters::Parameter, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__ActionTemplateParameters::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__ActionTemplateParameters(soap, tag, this, type);
}

SOAP_FMAC3 ns5__ActionTemplateParameters * SOAP_FMAC4 soap_in_ns5__ActionTemplateParameters(struct soap *soap, const char *tag, ns5__ActionTemplateParameters *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__ActionTemplateParameters *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__ActionTemplateParameters, sizeof(ns5__ActionTemplateParameters), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns5__ActionTemplateParameters)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns5__ActionTemplateParameters *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons5__ActionTemplateParameter(soap, "ns5:Parameter", &a->ns5__ActionTemplateParameters::Parameter, "ns5:ActionTemplateParameter"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->ns5__ActionTemplateParameters::Parameter.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns5__ActionTemplateParameters *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__ActionTemplateParameters, SOAP_TYPE_ns5__ActionTemplateParameters, sizeof(ns5__ActionTemplateParameters), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns5__ActionTemplateParameters * SOAP_FMAC2 soap_instantiate_ns5__ActionTemplateParameters(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__ActionTemplateParameters(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns5__ActionTemplateParameters *p;
	size_t k = sizeof(ns5__ActionTemplateParameters);
	if (n < 0)
	{	p = SOAP_NEW(ns5__ActionTemplateParameters);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns5__ActionTemplateParameters, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns5__ActionTemplateParameters location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns5__ActionTemplateParameters, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns5__ActionTemplateParameters::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns5__ActionTemplateParameters(soap, tag ? tag : "ns5:ActionTemplateParameters", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__ActionTemplateParameters::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__ActionTemplateParameters(soap, this, tag, type);
}

SOAP_FMAC3 ns5__ActionTemplateParameters * SOAP_FMAC4 soap_get_ns5__ActionTemplateParameters(struct soap *soap, ns5__ActionTemplateParameters *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__ActionTemplateParameters(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns5__ActionTemplate::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__string(soap, &this->ns5__ActionTemplate::TemplateToken);
	this->ns5__ActionTemplate::RecipientTemplate = NULL;
	this->ns5__ActionTemplate::Parameters = NULL;
}

void ns5__ActionTemplate::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns5__ActionTemplate::TemplateToken, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns5__ActionTemplate::TemplateToken);
	soap_serialize_PointerTostd__string(soap, &this->ns5__ActionTemplate::RecipientTemplate);
	soap_serialize_PointerTons5__ActionTemplateParameters(soap, &this->ns5__ActionTemplate::Parameters);
#endif
}

int ns5__ActionTemplate::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__ActionTemplate(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__ActionTemplate(struct soap *soap, const char *tag, int id, const ns5__ActionTemplate *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__ActionTemplate), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns5:TemplateToken", -1, &a->ns5__ActionTemplate::TemplateToken, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns5:RecipientTemplate", -1, &a->ns5__ActionTemplate::RecipientTemplate, ""))
		return soap->error;
	if (soap_out_PointerTons5__ActionTemplateParameters(soap, "ns5:Parameters", -1, &a->ns5__ActionTemplate::Parameters, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__ActionTemplate::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__ActionTemplate(soap, tag, this, type);
}

SOAP_FMAC3 ns5__ActionTemplate * SOAP_FMAC4 soap_in_ns5__ActionTemplate(struct soap *soap, const char *tag, ns5__ActionTemplate *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__ActionTemplate *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__ActionTemplate, sizeof(ns5__ActionTemplate), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns5__ActionTemplate)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns5__ActionTemplate *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_TemplateToken1 = 1;
	size_t soap_flag_RecipientTemplate1 = 1;
	size_t soap_flag_Parameters1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TemplateToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns5:TemplateToken", &a->ns5__ActionTemplate::TemplateToken, "xsd:string"))
				{	soap_flag_TemplateToken1--;
					continue;
				}
			}
			if (soap_flag_RecipientTemplate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns5:RecipientTemplate", &a->ns5__ActionTemplate::RecipientTemplate, "xsd:string"))
				{	soap_flag_RecipientTemplate1--;
					continue;
				}
			}
			if (soap_flag_Parameters1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons5__ActionTemplateParameters(soap, "ns5:Parameters", &a->ns5__ActionTemplate::Parameters, "ns5:ActionTemplateParameters"))
				{	soap_flag_Parameters1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TemplateToken1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns5__ActionTemplate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__ActionTemplate, SOAP_TYPE_ns5__ActionTemplate, sizeof(ns5__ActionTemplate), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns5__ActionTemplate * SOAP_FMAC2 soap_instantiate_ns5__ActionTemplate(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__ActionTemplate(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns5__ActionTemplate *p;
	size_t k = sizeof(ns5__ActionTemplate);
	if (n < 0)
	{	p = SOAP_NEW(ns5__ActionTemplate);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns5__ActionTemplate, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns5__ActionTemplate location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns5__ActionTemplate, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns5__ActionTemplate::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns5__ActionTemplate(soap, tag ? tag : "ns5:ActionTemplate", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__ActionTemplate::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__ActionTemplate(soap, this, tag, type);
}

SOAP_FMAC3 ns5__ActionTemplate * SOAP_FMAC4 soap_get_ns5__ActionTemplate(struct soap *soap, ns5__ActionTemplate *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__ActionTemplate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns5__ActionParameter::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__string(soap, &this->ns5__ActionParameter::Name);
	soap_default_std__string(soap, &this->ns5__ActionParameter::Value);
}

void ns5__ActionParameter::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns5__ActionParameter::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__ActionParameter(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__ActionParameter(struct soap *soap, const char *tag, int id, const ns5__ActionParameter *a, const char *type)
{
	soap_set_attr(soap, "Name", soap_std__string2s(soap, ((ns5__ActionParameter*)a)->Name), 1);
	soap_set_attr(soap, "Value", soap_std__string2s(soap, ((ns5__ActionParameter*)a)->Value), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__ActionParameter), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__ActionParameter::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__ActionParameter(soap, tag, this, type);
}

SOAP_FMAC3 ns5__ActionParameter * SOAP_FMAC4 soap_in_ns5__ActionParameter(struct soap *soap, const char *tag, ns5__ActionParameter *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__ActionParameter *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__ActionParameter, sizeof(ns5__ActionParameter), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns5__ActionParameter)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns5__ActionParameter *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2std__string(soap, soap_attr_value(soap, "Name", 1, 1), &((ns5__ActionParameter*)a)->Name))
		return NULL;
	if (soap_s2std__string(soap, soap_attr_value(soap, "Value", 1, 1), &((ns5__ActionParameter*)a)->Value))
		return NULL;
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__ActionParameter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__ActionParameter, SOAP_TYPE_ns5__ActionParameter, sizeof(ns5__ActionParameter), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns5__ActionParameter * SOAP_FMAC2 soap_instantiate_ns5__ActionParameter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__ActionParameter(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns5__ActionParameter *p;
	size_t k = sizeof(ns5__ActionParameter);
	if (n < 0)
	{	p = SOAP_NEW(ns5__ActionParameter);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns5__ActionParameter, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns5__ActionParameter location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns5__ActionParameter, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns5__ActionParameter::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns5__ActionParameter(soap, tag ? tag : "ns5:ActionParameter", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__ActionParameter::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__ActionParameter(soap, this, tag, type);
}

SOAP_FMAC3 ns5__ActionParameter * SOAP_FMAC4 soap_get_ns5__ActionParameter(struct soap *soap, ns5__ActionParameter *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__ActionParameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns5__ActionTemplates::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfPointerTons5__ActionTemplate(soap, &this->ns5__ActionTemplates::ActionTemplate);
}

void ns5__ActionTemplates::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons5__ActionTemplate(soap, &this->ns5__ActionTemplates::ActionTemplate);
#endif
}

int ns5__ActionTemplates::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__ActionTemplates(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__ActionTemplates(struct soap *soap, const char *tag, int id, const ns5__ActionTemplates *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__ActionTemplates), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons5__ActionTemplate(soap, "ns5:ActionTemplate", -1, &a->ns5__ActionTemplates::ActionTemplate, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__ActionTemplates::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__ActionTemplates(soap, tag, this, type);
}

SOAP_FMAC3 ns5__ActionTemplates * SOAP_FMAC4 soap_in_ns5__ActionTemplates(struct soap *soap, const char *tag, ns5__ActionTemplates *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__ActionTemplates *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__ActionTemplates, sizeof(ns5__ActionTemplates), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns5__ActionTemplates)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns5__ActionTemplates *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons5__ActionTemplate(soap, "ns5:ActionTemplate", &a->ns5__ActionTemplates::ActionTemplate, "ns5:ActionTemplate"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__ActionTemplates *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__ActionTemplates, SOAP_TYPE_ns5__ActionTemplates, sizeof(ns5__ActionTemplates), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns5__ActionTemplates * SOAP_FMAC2 soap_instantiate_ns5__ActionTemplates(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__ActionTemplates(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns5__ActionTemplates *p;
	size_t k = sizeof(ns5__ActionTemplates);
	if (n < 0)
	{	p = SOAP_NEW(ns5__ActionTemplates);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns5__ActionTemplates, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns5__ActionTemplates location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns5__ActionTemplates, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns5__ActionTemplates::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns5__ActionTemplates(soap, tag ? tag : "ns5:ActionTemplates", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__ActionTemplates::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__ActionTemplates(soap, this, tag, type);
}

SOAP_FMAC3 ns5__ActionTemplates * SOAP_FMAC4 soap_get_ns5__ActionTemplates(struct soap *soap, ns5__ActionTemplates *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__ActionTemplates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns5__ActionParameters::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfPointerTons5__ActionParameter(soap, &this->ns5__ActionParameters::Parameter);
	soap_default_xsd__anyAttribute(soap, &this->ns5__ActionParameters::__anyAttribute);
}

void ns5__ActionParameters::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons5__ActionParameter(soap, &this->ns5__ActionParameters::Parameter);
#endif
}

int ns5__ActionParameters::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__ActionParameters(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__ActionParameters(struct soap *soap, const char *tag, int id, const ns5__ActionParameters *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((ns5__ActionParameters*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__ActionParameters), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons5__ActionParameter(soap, "ns5:Parameter", -1, &a->ns5__ActionParameters::Parameter, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__ActionParameters::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__ActionParameters(soap, tag, this, type);
}

SOAP_FMAC3 ns5__ActionParameters * SOAP_FMAC4 soap_in_ns5__ActionParameters(struct soap *soap, const char *tag, ns5__ActionParameters *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__ActionParameters *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__ActionParameters, sizeof(ns5__ActionParameters), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns5__ActionParameters)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns5__ActionParameters *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((ns5__ActionParameters*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons5__ActionParameter(soap, "ns5:Parameter", &a->ns5__ActionParameters::Parameter, "ns5:ActionParameter"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__ActionParameters *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__ActionParameters, SOAP_TYPE_ns5__ActionParameters, sizeof(ns5__ActionParameters), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns5__ActionParameters * SOAP_FMAC2 soap_instantiate_ns5__ActionParameters(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__ActionParameters(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns5__ActionParameters *p;
	size_t k = sizeof(ns5__ActionParameters);
	if (n < 0)
	{	p = SOAP_NEW(ns5__ActionParameters);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns5__ActionParameters, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns5__ActionParameters location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns5__ActionParameters, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns5__ActionParameters::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns5__ActionParameters(soap, tag ? tag : "ns5:ActionParameters", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__ActionParameters::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__ActionParameters(soap, this, tag, type);
}

SOAP_FMAC3 ns5__ActionParameters * SOAP_FMAC4 soap_get_ns5__ActionParameters(struct soap *soap, ns5__ActionParameters *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__ActionParameters(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns5__ActionConfiguration::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__integer(soap, &this->ns5__ActionConfiguration::ConfigurationID);
	this->ns5__ActionConfiguration::Name = NULL;
	soap_default_std__string(soap, &this->ns5__ActionConfiguration::TemplateToken);
	this->ns5__ActionConfiguration::Parameters = NULL;
}

void ns5__ActionConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns5__ActionConfiguration::ConfigurationID, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &this->ns5__ActionConfiguration::ConfigurationID);
	soap_serialize_PointerTostd__string(soap, &this->ns5__ActionConfiguration::Name);
	soap_embedded(soap, &this->ns5__ActionConfiguration::TemplateToken, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns5__ActionConfiguration::TemplateToken);
	soap_serialize_PointerTons5__ActionParameters(soap, &this->ns5__ActionConfiguration::Parameters);
#endif
}

int ns5__ActionConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__ActionConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__ActionConfiguration(struct soap *soap, const char *tag, int id, const ns5__ActionConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__ActionConfiguration), type))
		return soap->error;
	if (soap_out_xsd__integer(soap, "ns5:ConfigurationID", -1, &a->ns5__ActionConfiguration::ConfigurationID, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns5:Name", -1, &a->ns5__ActionConfiguration::Name, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns5:TemplateToken", -1, &a->ns5__ActionConfiguration::TemplateToken, ""))
		return soap->error;
	if (soap_out_PointerTons5__ActionParameters(soap, "ns5:Parameters", -1, &a->ns5__ActionConfiguration::Parameters, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__ActionConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__ActionConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 ns5__ActionConfiguration * SOAP_FMAC4 soap_in_ns5__ActionConfiguration(struct soap *soap, const char *tag, ns5__ActionConfiguration *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__ActionConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__ActionConfiguration, sizeof(ns5__ActionConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns5__ActionConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns5__ActionConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_ConfigurationID1 = 1;
	size_t soap_flag_Name1 = 1;
	size_t soap_flag_TemplateToken1 = 1;
	size_t soap_flag_Parameters1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConfigurationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__integer(soap, "ns5:ConfigurationID", &a->ns5__ActionConfiguration::ConfigurationID, "xsd:integer"))
				{	soap_flag_ConfigurationID1--;
					continue;
				}
			}
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns5:Name", &a->ns5__ActionConfiguration::Name, "xsd:string"))
				{	soap_flag_Name1--;
					continue;
				}
			}
			if (soap_flag_TemplateToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns5:TemplateToken", &a->ns5__ActionConfiguration::TemplateToken, "xsd:string"))
				{	soap_flag_TemplateToken1--;
					continue;
				}
			}
			if (soap_flag_Parameters1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons5__ActionParameters(soap, "ns5:Parameters", &a->ns5__ActionConfiguration::Parameters, "ns5:ActionParameters"))
				{	soap_flag_Parameters1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ConfigurationID1 > 0 || soap_flag_TemplateToken1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns5__ActionConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__ActionConfiguration, SOAP_TYPE_ns5__ActionConfiguration, sizeof(ns5__ActionConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns5__ActionConfiguration * SOAP_FMAC2 soap_instantiate_ns5__ActionConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__ActionConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns5__ActionConfiguration *p;
	size_t k = sizeof(ns5__ActionConfiguration);
	if (n < 0)
	{	p = SOAP_NEW(ns5__ActionConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns5__ActionConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns5__ActionConfiguration location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns5__ActionConfiguration, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns5__ActionConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns5__ActionConfiguration(soap, tag ? tag : "ns5:ActionConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__ActionConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__ActionConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 ns5__ActionConfiguration * SOAP_FMAC4 soap_get_ns5__ActionConfiguration(struct soap *soap, ns5__ActionConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__ActionConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns5__NewActionConfiguration::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns5__NewActionConfiguration::Name = NULL;
	soap_default_std__string(soap, &this->ns5__NewActionConfiguration::TemplateToken);
	this->ns5__NewActionConfiguration::Parameters = NULL;
}

void ns5__NewActionConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns5__NewActionConfiguration::Name);
	soap_embedded(soap, &this->ns5__NewActionConfiguration::TemplateToken, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns5__NewActionConfiguration::TemplateToken);
	soap_serialize_PointerTons5__ActionParameters(soap, &this->ns5__NewActionConfiguration::Parameters);
#endif
}

int ns5__NewActionConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__NewActionConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__NewActionConfiguration(struct soap *soap, const char *tag, int id, const ns5__NewActionConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__NewActionConfiguration), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns5:Name", -1, &a->ns5__NewActionConfiguration::Name, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns5:TemplateToken", -1, &a->ns5__NewActionConfiguration::TemplateToken, ""))
		return soap->error;
	if (soap_out_PointerTons5__ActionParameters(soap, "ns5:Parameters", -1, &a->ns5__NewActionConfiguration::Parameters, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__NewActionConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__NewActionConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 ns5__NewActionConfiguration * SOAP_FMAC4 soap_in_ns5__NewActionConfiguration(struct soap *soap, const char *tag, ns5__NewActionConfiguration *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__NewActionConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__NewActionConfiguration, sizeof(ns5__NewActionConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns5__NewActionConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns5__NewActionConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Name1 = 1;
	size_t soap_flag_TemplateToken1 = 1;
	size_t soap_flag_Parameters1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns5:Name", &a->ns5__NewActionConfiguration::Name, "xsd:string"))
				{	soap_flag_Name1--;
					continue;
				}
			}
			if (soap_flag_TemplateToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns5:TemplateToken", &a->ns5__NewActionConfiguration::TemplateToken, "xsd:string"))
				{	soap_flag_TemplateToken1--;
					continue;
				}
			}
			if (soap_flag_Parameters1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons5__ActionParameters(soap, "ns5:Parameters", &a->ns5__NewActionConfiguration::Parameters, "ns5:ActionParameters"))
				{	soap_flag_Parameters1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TemplateToken1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns5__NewActionConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__NewActionConfiguration, SOAP_TYPE_ns5__NewActionConfiguration, sizeof(ns5__NewActionConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns5__NewActionConfiguration * SOAP_FMAC2 soap_instantiate_ns5__NewActionConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__NewActionConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns5__NewActionConfiguration *p;
	size_t k = sizeof(ns5__NewActionConfiguration);
	if (n < 0)
	{	p = SOAP_NEW(ns5__NewActionConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns5__NewActionConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns5__NewActionConfiguration location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns5__NewActionConfiguration, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns5__NewActionConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns5__NewActionConfiguration(soap, tag ? tag : "ns5:NewActionConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__NewActionConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__NewActionConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 ns5__NewActionConfiguration * SOAP_FMAC4 soap_get_ns5__NewActionConfiguration(struct soap *soap, ns5__NewActionConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__NewActionConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns5__ActionConfigurations::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfPointerTons5__ActionConfiguration(soap, &this->ns5__ActionConfigurations::ActionConfiguration);
}

void ns5__ActionConfigurations::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons5__ActionConfiguration(soap, &this->ns5__ActionConfigurations::ActionConfiguration);
#endif
}

int ns5__ActionConfigurations::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__ActionConfigurations(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__ActionConfigurations(struct soap *soap, const char *tag, int id, const ns5__ActionConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__ActionConfigurations), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons5__ActionConfiguration(soap, "ns5:ActionConfiguration", -1, &a->ns5__ActionConfigurations::ActionConfiguration, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__ActionConfigurations::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__ActionConfigurations(soap, tag, this, type);
}

SOAP_FMAC3 ns5__ActionConfigurations * SOAP_FMAC4 soap_in_ns5__ActionConfigurations(struct soap *soap, const char *tag, ns5__ActionConfigurations *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__ActionConfigurations *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__ActionConfigurations, sizeof(ns5__ActionConfigurations), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns5__ActionConfigurations)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns5__ActionConfigurations *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons5__ActionConfiguration(soap, "ns5:ActionConfiguration", &a->ns5__ActionConfigurations::ActionConfiguration, "ns5:ActionConfiguration"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__ActionConfigurations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__ActionConfigurations, SOAP_TYPE_ns5__ActionConfigurations, sizeof(ns5__ActionConfigurations), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns5__ActionConfigurations * SOAP_FMAC2 soap_instantiate_ns5__ActionConfigurations(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__ActionConfigurations(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns5__ActionConfigurations *p;
	size_t k = sizeof(ns5__ActionConfigurations);
	if (n < 0)
	{	p = SOAP_NEW(ns5__ActionConfigurations);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns5__ActionConfigurations, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns5__ActionConfigurations location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns5__ActionConfigurations, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns5__ActionConfigurations::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns5__ActionConfigurations(soap, tag ? tag : "ns5:ActionConfigurations", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__ActionConfigurations::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__ActionConfigurations(soap, this, tag, type);
}

SOAP_FMAC3 ns5__ActionConfigurations * SOAP_FMAC4 soap_get_ns5__ActionConfigurations(struct soap *soap, ns5__ActionConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__ActionConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns5__RecipientTemplate::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__string(soap, &this->ns5__RecipientTemplate::TemplateToken);
	this->ns5__RecipientTemplate::Parameters = NULL;
}

void ns5__RecipientTemplate::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns5__RecipientTemplate::TemplateToken, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns5__RecipientTemplate::TemplateToken);
	soap_serialize_PointerTons5__ActionTemplateParameters(soap, &this->ns5__RecipientTemplate::Parameters);
#endif
}

int ns5__RecipientTemplate::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__RecipientTemplate(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__RecipientTemplate(struct soap *soap, const char *tag, int id, const ns5__RecipientTemplate *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__RecipientTemplate), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns5:TemplateToken", -1, &a->ns5__RecipientTemplate::TemplateToken, ""))
		return soap->error;
	if (soap_out_PointerTons5__ActionTemplateParameters(soap, "ns5:Parameters", -1, &a->ns5__RecipientTemplate::Parameters, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__RecipientTemplate::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__RecipientTemplate(soap, tag, this, type);
}

SOAP_FMAC3 ns5__RecipientTemplate * SOAP_FMAC4 soap_in_ns5__RecipientTemplate(struct soap *soap, const char *tag, ns5__RecipientTemplate *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__RecipientTemplate *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__RecipientTemplate, sizeof(ns5__RecipientTemplate), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns5__RecipientTemplate)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns5__RecipientTemplate *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_TemplateToken1 = 1;
	size_t soap_flag_Parameters1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TemplateToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns5:TemplateToken", &a->ns5__RecipientTemplate::TemplateToken, "xsd:string"))
				{	soap_flag_TemplateToken1--;
					continue;
				}
			}
			if (soap_flag_Parameters1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons5__ActionTemplateParameters(soap, "ns5:Parameters", &a->ns5__RecipientTemplate::Parameters, "ns5:ActionTemplateParameters"))
				{	soap_flag_Parameters1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TemplateToken1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns5__RecipientTemplate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__RecipientTemplate, SOAP_TYPE_ns5__RecipientTemplate, sizeof(ns5__RecipientTemplate), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns5__RecipientTemplate * SOAP_FMAC2 soap_instantiate_ns5__RecipientTemplate(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__RecipientTemplate(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns5__RecipientTemplate *p;
	size_t k = sizeof(ns5__RecipientTemplate);
	if (n < 0)
	{	p = SOAP_NEW(ns5__RecipientTemplate);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns5__RecipientTemplate, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns5__RecipientTemplate location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns5__RecipientTemplate, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns5__RecipientTemplate::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns5__RecipientTemplate(soap, tag ? tag : "ns5:RecipientTemplate", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__RecipientTemplate::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__RecipientTemplate(soap, this, tag, type);
}

SOAP_FMAC3 ns5__RecipientTemplate * SOAP_FMAC4 soap_get_ns5__RecipientTemplate(struct soap *soap, ns5__RecipientTemplate *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__RecipientTemplate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns5__RecipientTemplates::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfPointerTons5__RecipientTemplate(soap, &this->ns5__RecipientTemplates::RecipientTemplate);
}

void ns5__RecipientTemplates::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons5__RecipientTemplate(soap, &this->ns5__RecipientTemplates::RecipientTemplate);
#endif
}

int ns5__RecipientTemplates::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__RecipientTemplates(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__RecipientTemplates(struct soap *soap, const char *tag, int id, const ns5__RecipientTemplates *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__RecipientTemplates), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons5__RecipientTemplate(soap, "ns5:RecipientTemplate", -1, &a->ns5__RecipientTemplates::RecipientTemplate, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__RecipientTemplates::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__RecipientTemplates(soap, tag, this, type);
}

SOAP_FMAC3 ns5__RecipientTemplates * SOAP_FMAC4 soap_in_ns5__RecipientTemplates(struct soap *soap, const char *tag, ns5__RecipientTemplates *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__RecipientTemplates *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__RecipientTemplates, sizeof(ns5__RecipientTemplates), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns5__RecipientTemplates)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns5__RecipientTemplates *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons5__RecipientTemplate(soap, "ns5:RecipientTemplate", &a->ns5__RecipientTemplates::RecipientTemplate, "ns5:RecipientTemplate"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__RecipientTemplates *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__RecipientTemplates, SOAP_TYPE_ns5__RecipientTemplates, sizeof(ns5__RecipientTemplates), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns5__RecipientTemplates * SOAP_FMAC2 soap_instantiate_ns5__RecipientTemplates(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__RecipientTemplates(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns5__RecipientTemplates *p;
	size_t k = sizeof(ns5__RecipientTemplates);
	if (n < 0)
	{	p = SOAP_NEW(ns5__RecipientTemplates);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns5__RecipientTemplates, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns5__RecipientTemplates location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns5__RecipientTemplates, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns5__RecipientTemplates::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns5__RecipientTemplates(soap, tag ? tag : "ns5:RecipientTemplates", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__RecipientTemplates::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__RecipientTemplates(soap, this, tag, type);
}

SOAP_FMAC3 ns5__RecipientTemplates * SOAP_FMAC4 soap_get_ns5__RecipientTemplates(struct soap *soap, ns5__RecipientTemplates *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__RecipientTemplates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns5__RecipientConfigurations::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfPointerTons5__RecipientConfiguration(soap, &this->ns5__RecipientConfigurations::RecipientConfiguration);
}

void ns5__RecipientConfigurations::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons5__RecipientConfiguration(soap, &this->ns5__RecipientConfigurations::RecipientConfiguration);
#endif
}

int ns5__RecipientConfigurations::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__RecipientConfigurations(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__RecipientConfigurations(struct soap *soap, const char *tag, int id, const ns5__RecipientConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__RecipientConfigurations), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons5__RecipientConfiguration(soap, "ns5:RecipientConfiguration", -1, &a->ns5__RecipientConfigurations::RecipientConfiguration, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__RecipientConfigurations::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__RecipientConfigurations(soap, tag, this, type);
}

SOAP_FMAC3 ns5__RecipientConfigurations * SOAP_FMAC4 soap_in_ns5__RecipientConfigurations(struct soap *soap, const char *tag, ns5__RecipientConfigurations *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__RecipientConfigurations *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__RecipientConfigurations, sizeof(ns5__RecipientConfigurations), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns5__RecipientConfigurations)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns5__RecipientConfigurations *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons5__RecipientConfiguration(soap, "ns5:RecipientConfiguration", &a->ns5__RecipientConfigurations::RecipientConfiguration, "ns5:RecipientConfiguration"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__RecipientConfigurations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__RecipientConfigurations, SOAP_TYPE_ns5__RecipientConfigurations, sizeof(ns5__RecipientConfigurations), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns5__RecipientConfigurations * SOAP_FMAC2 soap_instantiate_ns5__RecipientConfigurations(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__RecipientConfigurations(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns5__RecipientConfigurations *p;
	size_t k = sizeof(ns5__RecipientConfigurations);
	if (n < 0)
	{	p = SOAP_NEW(ns5__RecipientConfigurations);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns5__RecipientConfigurations, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns5__RecipientConfigurations location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns5__RecipientConfigurations, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns5__RecipientConfigurations::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns5__RecipientConfigurations(soap, tag ? tag : "ns5:RecipientConfigurations", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__RecipientConfigurations::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__RecipientConfigurations(soap, this, tag, type);
}

SOAP_FMAC3 ns5__RecipientConfigurations * SOAP_FMAC4 soap_get_ns5__RecipientConfigurations(struct soap *soap, ns5__RecipientConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__RecipientConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns5__RecipientConfiguration::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__integer(soap, &this->ns5__RecipientConfiguration::ConfigurationID);
	soap_default_std__string(soap, &this->ns5__RecipientConfiguration::TemplateToken);
	this->ns5__RecipientConfiguration::Name = NULL;
	this->ns5__RecipientConfiguration::Parameters = NULL;
}

void ns5__RecipientConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns5__RecipientConfiguration::ConfigurationID, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &this->ns5__RecipientConfiguration::ConfigurationID);
	soap_embedded(soap, &this->ns5__RecipientConfiguration::TemplateToken, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns5__RecipientConfiguration::TemplateToken);
	soap_serialize_PointerTostd__string(soap, &this->ns5__RecipientConfiguration::Name);
	soap_serialize_PointerTons5__ActionParameters(soap, &this->ns5__RecipientConfiguration::Parameters);
#endif
}

int ns5__RecipientConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__RecipientConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__RecipientConfiguration(struct soap *soap, const char *tag, int id, const ns5__RecipientConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__RecipientConfiguration), type))
		return soap->error;
	if (soap_out_xsd__integer(soap, "ns5:ConfigurationID", -1, &a->ns5__RecipientConfiguration::ConfigurationID, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns5:TemplateToken", -1, &a->ns5__RecipientConfiguration::TemplateToken, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns5:Name", -1, &a->ns5__RecipientConfiguration::Name, ""))
		return soap->error;
	if (soap_out_PointerTons5__ActionParameters(soap, "ns5:Parameters", -1, &a->ns5__RecipientConfiguration::Parameters, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__RecipientConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__RecipientConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 ns5__RecipientConfiguration * SOAP_FMAC4 soap_in_ns5__RecipientConfiguration(struct soap *soap, const char *tag, ns5__RecipientConfiguration *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__RecipientConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__RecipientConfiguration, sizeof(ns5__RecipientConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns5__RecipientConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns5__RecipientConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_ConfigurationID1 = 1;
	size_t soap_flag_TemplateToken1 = 1;
	size_t soap_flag_Name1 = 1;
	size_t soap_flag_Parameters1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConfigurationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__integer(soap, "ns5:ConfigurationID", &a->ns5__RecipientConfiguration::ConfigurationID, "xsd:integer"))
				{	soap_flag_ConfigurationID1--;
					continue;
				}
			}
			if (soap_flag_TemplateToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns5:TemplateToken", &a->ns5__RecipientConfiguration::TemplateToken, "xsd:string"))
				{	soap_flag_TemplateToken1--;
					continue;
				}
			}
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns5:Name", &a->ns5__RecipientConfiguration::Name, "xsd:string"))
				{	soap_flag_Name1--;
					continue;
				}
			}
			if (soap_flag_Parameters1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons5__ActionParameters(soap, "ns5:Parameters", &a->ns5__RecipientConfiguration::Parameters, "ns5:ActionParameters"))
				{	soap_flag_Parameters1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ConfigurationID1 > 0 || soap_flag_TemplateToken1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns5__RecipientConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__RecipientConfiguration, SOAP_TYPE_ns5__RecipientConfiguration, sizeof(ns5__RecipientConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns5__RecipientConfiguration * SOAP_FMAC2 soap_instantiate_ns5__RecipientConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__RecipientConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns5__RecipientConfiguration *p;
	size_t k = sizeof(ns5__RecipientConfiguration);
	if (n < 0)
	{	p = SOAP_NEW(ns5__RecipientConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns5__RecipientConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns5__RecipientConfiguration location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns5__RecipientConfiguration, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns5__RecipientConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns5__RecipientConfiguration(soap, tag ? tag : "ns5:RecipientConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__RecipientConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__RecipientConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 ns5__RecipientConfiguration * SOAP_FMAC4 soap_get_ns5__RecipientConfiguration(struct soap *soap, ns5__RecipientConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__RecipientConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns5__NewRecipientConfiguration::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns5__NewRecipientConfiguration::Name = NULL;
	soap_default_std__string(soap, &this->ns5__NewRecipientConfiguration::TemplateToken);
	this->ns5__NewRecipientConfiguration::Parameters = NULL;
}

void ns5__NewRecipientConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns5__NewRecipientConfiguration::Name);
	soap_embedded(soap, &this->ns5__NewRecipientConfiguration::TemplateToken, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns5__NewRecipientConfiguration::TemplateToken);
	soap_serialize_PointerTons5__ActionParameters(soap, &this->ns5__NewRecipientConfiguration::Parameters);
#endif
}

int ns5__NewRecipientConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__NewRecipientConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__NewRecipientConfiguration(struct soap *soap, const char *tag, int id, const ns5__NewRecipientConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__NewRecipientConfiguration), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns5:Name", -1, &a->ns5__NewRecipientConfiguration::Name, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns5:TemplateToken", -1, &a->ns5__NewRecipientConfiguration::TemplateToken, ""))
		return soap->error;
	if (soap_out_PointerTons5__ActionParameters(soap, "ns5:Parameters", -1, &a->ns5__NewRecipientConfiguration::Parameters, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__NewRecipientConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__NewRecipientConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 ns5__NewRecipientConfiguration * SOAP_FMAC4 soap_in_ns5__NewRecipientConfiguration(struct soap *soap, const char *tag, ns5__NewRecipientConfiguration *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__NewRecipientConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__NewRecipientConfiguration, sizeof(ns5__NewRecipientConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns5__NewRecipientConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns5__NewRecipientConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Name1 = 1;
	size_t soap_flag_TemplateToken1 = 1;
	size_t soap_flag_Parameters1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns5:Name", &a->ns5__NewRecipientConfiguration::Name, "xsd:string"))
				{	soap_flag_Name1--;
					continue;
				}
			}
			if (soap_flag_TemplateToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns5:TemplateToken", &a->ns5__NewRecipientConfiguration::TemplateToken, "xsd:string"))
				{	soap_flag_TemplateToken1--;
					continue;
				}
			}
			if (soap_flag_Parameters1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons5__ActionParameters(soap, "ns5:Parameters", &a->ns5__NewRecipientConfiguration::Parameters, "ns5:ActionParameters"))
				{	soap_flag_Parameters1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TemplateToken1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns5__NewRecipientConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__NewRecipientConfiguration, SOAP_TYPE_ns5__NewRecipientConfiguration, sizeof(ns5__NewRecipientConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns5__NewRecipientConfiguration * SOAP_FMAC2 soap_instantiate_ns5__NewRecipientConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__NewRecipientConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns5__NewRecipientConfiguration *p;
	size_t k = sizeof(ns5__NewRecipientConfiguration);
	if (n < 0)
	{	p = SOAP_NEW(ns5__NewRecipientConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns5__NewRecipientConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns5__NewRecipientConfiguration location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns5__NewRecipientConfiguration, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns5__NewRecipientConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns5__NewRecipientConfiguration(soap, tag ? tag : "ns5:NewRecipientConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__NewRecipientConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__NewRecipientConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 ns5__NewRecipientConfiguration * SOAP_FMAC4 soap_get_ns5__NewRecipientConfiguration(struct soap *soap, ns5__NewRecipientConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__NewRecipientConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns5__ActionRule::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__integer(soap, &this->ns5__ActionRule::RuleID);
	this->ns5__ActionRule::Name = NULL;
	soap_default_bool(soap, &this->ns5__ActionRule::Enabled);
	this->ns5__ActionRule::StartEvent = NULL;
	this->ns5__ActionRule::Conditions = NULL;
	this->ns5__ActionRule::ActivationTimeout = NULL;
	soap_default_xsd__integer(soap, &this->ns5__ActionRule::PrimaryAction);
	this->ns5__ActionRule::FailoverAction = NULL;
}

void ns5__ActionRule::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns5__ActionRule::RuleID, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &this->ns5__ActionRule::RuleID);
	soap_serialize_PointerTostd__string(soap, &this->ns5__ActionRule::Name);
	soap_embedded(soap, &this->ns5__ActionRule::Enabled, SOAP_TYPE_bool);
	soap_serialize_PointerTons3__FilterType(soap, &this->ns5__ActionRule::StartEvent);
	soap_serialize_PointerTons5__Conditions(soap, &this->ns5__ActionRule::Conditions);
	soap_serialize_PointerToxsd__duration(soap, &this->ns5__ActionRule::ActivationTimeout);
	soap_embedded(soap, &this->ns5__ActionRule::PrimaryAction, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &this->ns5__ActionRule::PrimaryAction);
	soap_serialize_PointerToxsd__integer(soap, &this->ns5__ActionRule::FailoverAction);
#endif
}

int ns5__ActionRule::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__ActionRule(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__ActionRule(struct soap *soap, const char *tag, int id, const ns5__ActionRule *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__ActionRule), type))
		return soap->error;
	if (soap_out_xsd__integer(soap, "ns5:RuleID", -1, &a->ns5__ActionRule::RuleID, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns5:Name", -1, &a->ns5__ActionRule::Name, ""))
		return soap->error;
	if (soap_out_bool(soap, "ns5:Enabled", -1, &a->ns5__ActionRule::Enabled, ""))
		return soap->error;
	if (soap_out_PointerTons3__FilterType(soap, "ns5:StartEvent", -1, &a->ns5__ActionRule::StartEvent, ""))
		return soap->error;
	if (soap_out_PointerTons5__Conditions(soap, "ns5:Conditions", -1, &a->ns5__ActionRule::Conditions, ""))
		return soap->error;
	if (soap_out_PointerToxsd__duration(soap, "ns5:ActivationTimeout", -1, &a->ns5__ActionRule::ActivationTimeout, ""))
		return soap->error;
	if (soap_out_xsd__integer(soap, "ns5:PrimaryAction", -1, &a->ns5__ActionRule::PrimaryAction, ""))
		return soap->error;
	if (soap_out_PointerToxsd__integer(soap, "ns5:FailoverAction", -1, &a->ns5__ActionRule::FailoverAction, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__ActionRule::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__ActionRule(soap, tag, this, type);
}

SOAP_FMAC3 ns5__ActionRule * SOAP_FMAC4 soap_in_ns5__ActionRule(struct soap *soap, const char *tag, ns5__ActionRule *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__ActionRule *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__ActionRule, sizeof(ns5__ActionRule), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns5__ActionRule)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns5__ActionRule *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_RuleID1 = 1;
	size_t soap_flag_Name1 = 1;
	size_t soap_flag_Enabled1 = 1;
	size_t soap_flag_StartEvent1 = 1;
	size_t soap_flag_Conditions1 = 1;
	size_t soap_flag_ActivationTimeout1 = 1;
	size_t soap_flag_PrimaryAction1 = 1;
	size_t soap_flag_FailoverAction1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RuleID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__integer(soap, "ns5:RuleID", &a->ns5__ActionRule::RuleID, "xsd:integer"))
				{	soap_flag_RuleID1--;
					continue;
				}
			}
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns5:Name", &a->ns5__ActionRule::Name, "xsd:string"))
				{	soap_flag_Name1--;
					continue;
				}
			}
			if (soap_flag_Enabled1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "ns5:Enabled", &a->ns5__ActionRule::Enabled, "xsd:boolean"))
				{	soap_flag_Enabled1--;
					continue;
				}
			}
			if (soap_flag_StartEvent1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__FilterType(soap, "ns5:StartEvent", &a->ns5__ActionRule::StartEvent, "ns3:FilterType"))
				{	soap_flag_StartEvent1--;
					continue;
				}
			}
			if (soap_flag_Conditions1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons5__Conditions(soap, "ns5:Conditions", &a->ns5__ActionRule::Conditions, "ns5:Conditions"))
				{	soap_flag_Conditions1--;
					continue;
				}
			}
			if (soap_flag_ActivationTimeout1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__duration(soap, "ns5:ActivationTimeout", &a->ns5__ActionRule::ActivationTimeout, "xsd:duration"))
				{	soap_flag_ActivationTimeout1--;
					continue;
				}
			}
			if (soap_flag_PrimaryAction1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__integer(soap, "ns5:PrimaryAction", &a->ns5__ActionRule::PrimaryAction, "xsd:integer"))
				{	soap_flag_PrimaryAction1--;
					continue;
				}
			}
			if (soap_flag_FailoverAction1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__integer(soap, "ns5:FailoverAction", &a->ns5__ActionRule::FailoverAction, "xsd:integer"))
				{	soap_flag_FailoverAction1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RuleID1 > 0 || soap_flag_Enabled1 > 0 || soap_flag_PrimaryAction1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns5__ActionRule *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__ActionRule, SOAP_TYPE_ns5__ActionRule, sizeof(ns5__ActionRule), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns5__ActionRule * SOAP_FMAC2 soap_instantiate_ns5__ActionRule(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__ActionRule(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns5__ActionRule *p;
	size_t k = sizeof(ns5__ActionRule);
	if (n < 0)
	{	p = SOAP_NEW(ns5__ActionRule);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns5__ActionRule, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns5__ActionRule location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns5__ActionRule, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns5__ActionRule::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns5__ActionRule(soap, tag ? tag : "ns5:ActionRule", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__ActionRule::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__ActionRule(soap, this, tag, type);
}

SOAP_FMAC3 ns5__ActionRule * SOAP_FMAC4 soap_get_ns5__ActionRule(struct soap *soap, ns5__ActionRule *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__ActionRule(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns5__ActionRules::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfPointerTons5__ActionRule(soap, &this->ns5__ActionRules::ActionRule);
}

void ns5__ActionRules::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons5__ActionRule(soap, &this->ns5__ActionRules::ActionRule);
#endif
}

int ns5__ActionRules::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__ActionRules(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__ActionRules(struct soap *soap, const char *tag, int id, const ns5__ActionRules *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__ActionRules), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons5__ActionRule(soap, "ns5:ActionRule", -1, &a->ns5__ActionRules::ActionRule, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__ActionRules::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__ActionRules(soap, tag, this, type);
}

SOAP_FMAC3 ns5__ActionRules * SOAP_FMAC4 soap_in_ns5__ActionRules(struct soap *soap, const char *tag, ns5__ActionRules *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__ActionRules *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__ActionRules, sizeof(ns5__ActionRules), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns5__ActionRules)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns5__ActionRules *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons5__ActionRule(soap, "ns5:ActionRule", &a->ns5__ActionRules::ActionRule, "ns5:ActionRule"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__ActionRules *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__ActionRules, SOAP_TYPE_ns5__ActionRules, sizeof(ns5__ActionRules), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns5__ActionRules * SOAP_FMAC2 soap_instantiate_ns5__ActionRules(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__ActionRules(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns5__ActionRules *p;
	size_t k = sizeof(ns5__ActionRules);
	if (n < 0)
	{	p = SOAP_NEW(ns5__ActionRules);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns5__ActionRules, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns5__ActionRules location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns5__ActionRules, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns5__ActionRules::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns5__ActionRules(soap, tag ? tag : "ns5:ActionRules", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__ActionRules::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__ActionRules(soap, this, tag, type);
}

SOAP_FMAC3 ns5__ActionRules * SOAP_FMAC4 soap_get_ns5__ActionRules(struct soap *soap, ns5__ActionRules *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__ActionRules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns5__Conditions::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfPointerTons3__FilterType(soap, &this->ns5__Conditions::Condition);
}

void ns5__Conditions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons3__FilterType(soap, &this->ns5__Conditions::Condition);
#endif
}

int ns5__Conditions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__Conditions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__Conditions(struct soap *soap, const char *tag, int id, const ns5__Conditions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__Conditions), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons3__FilterType(soap, "ns5:Condition", -1, &a->ns5__Conditions::Condition, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__Conditions::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__Conditions(soap, tag, this, type);
}

SOAP_FMAC3 ns5__Conditions * SOAP_FMAC4 soap_in_ns5__Conditions(struct soap *soap, const char *tag, ns5__Conditions *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__Conditions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__Conditions, sizeof(ns5__Conditions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns5__Conditions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns5__Conditions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons3__FilterType(soap, "ns5:Condition", &a->ns5__Conditions::Condition, "ns3:FilterType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->ns5__Conditions::Condition.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns5__Conditions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__Conditions, SOAP_TYPE_ns5__Conditions, sizeof(ns5__Conditions), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns5__Conditions * SOAP_FMAC2 soap_instantiate_ns5__Conditions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__Conditions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns5__Conditions *p;
	size_t k = sizeof(ns5__Conditions);
	if (n < 0)
	{	p = SOAP_NEW(ns5__Conditions);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns5__Conditions, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns5__Conditions location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns5__Conditions, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns5__Conditions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns5__Conditions(soap, tag ? tag : "ns5:Conditions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__Conditions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__Conditions(soap, this, tag, type);
}

SOAP_FMAC3 ns5__Conditions * SOAP_FMAC4 soap_get_ns5__Conditions(struct soap *soap, ns5__Conditions *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__Conditions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns5__NewActionRule::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns5__NewActionRule::Name = NULL;
	soap_default_bool(soap, &this->ns5__NewActionRule::Enabled);
	this->ns5__NewActionRule::StartEvent = NULL;
	this->ns5__NewActionRule::Conditions = NULL;
	this->ns5__NewActionRule::ActivationTimeout = NULL;
	soap_default_xsd__integer(soap, &this->ns5__NewActionRule::PrimaryAction);
	this->ns5__NewActionRule::FailoverAction = NULL;
}

void ns5__NewActionRule::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns5__NewActionRule::Name);
	soap_embedded(soap, &this->ns5__NewActionRule::Enabled, SOAP_TYPE_bool);
	soap_serialize_PointerTons3__FilterType(soap, &this->ns5__NewActionRule::StartEvent);
	soap_serialize_PointerTons5__Conditions(soap, &this->ns5__NewActionRule::Conditions);
	soap_serialize_PointerToxsd__duration(soap, &this->ns5__NewActionRule::ActivationTimeout);
	soap_embedded(soap, &this->ns5__NewActionRule::PrimaryAction, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &this->ns5__NewActionRule::PrimaryAction);
	soap_serialize_PointerToxsd__integer(soap, &this->ns5__NewActionRule::FailoverAction);
#endif
}

int ns5__NewActionRule::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__NewActionRule(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__NewActionRule(struct soap *soap, const char *tag, int id, const ns5__NewActionRule *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__NewActionRule), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns5:Name", -1, &a->ns5__NewActionRule::Name, ""))
		return soap->error;
	if (soap_out_bool(soap, "ns5:Enabled", -1, &a->ns5__NewActionRule::Enabled, ""))
		return soap->error;
	if (soap_out_PointerTons3__FilterType(soap, "ns5:StartEvent", -1, &a->ns5__NewActionRule::StartEvent, ""))
		return soap->error;
	if (soap_out_PointerTons5__Conditions(soap, "ns5:Conditions", -1, &a->ns5__NewActionRule::Conditions, ""))
		return soap->error;
	if (soap_out_PointerToxsd__duration(soap, "ns5:ActivationTimeout", -1, &a->ns5__NewActionRule::ActivationTimeout, ""))
		return soap->error;
	if (soap_out_xsd__integer(soap, "ns5:PrimaryAction", -1, &a->ns5__NewActionRule::PrimaryAction, ""))
		return soap->error;
	if (soap_out_PointerToxsd__integer(soap, "ns5:FailoverAction", -1, &a->ns5__NewActionRule::FailoverAction, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__NewActionRule::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__NewActionRule(soap, tag, this, type);
}

SOAP_FMAC3 ns5__NewActionRule * SOAP_FMAC4 soap_in_ns5__NewActionRule(struct soap *soap, const char *tag, ns5__NewActionRule *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__NewActionRule *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__NewActionRule, sizeof(ns5__NewActionRule), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns5__NewActionRule)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns5__NewActionRule *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Name1 = 1;
	size_t soap_flag_Enabled1 = 1;
	size_t soap_flag_StartEvent1 = 1;
	size_t soap_flag_Conditions1 = 1;
	size_t soap_flag_ActivationTimeout1 = 1;
	size_t soap_flag_PrimaryAction1 = 1;
	size_t soap_flag_FailoverAction1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns5:Name", &a->ns5__NewActionRule::Name, "xsd:string"))
				{	soap_flag_Name1--;
					continue;
				}
			}
			if (soap_flag_Enabled1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "ns5:Enabled", &a->ns5__NewActionRule::Enabled, "xsd:boolean"))
				{	soap_flag_Enabled1--;
					continue;
				}
			}
			if (soap_flag_StartEvent1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__FilterType(soap, "ns5:StartEvent", &a->ns5__NewActionRule::StartEvent, "ns3:FilterType"))
				{	soap_flag_StartEvent1--;
					continue;
				}
			}
			if (soap_flag_Conditions1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons5__Conditions(soap, "ns5:Conditions", &a->ns5__NewActionRule::Conditions, "ns5:Conditions"))
				{	soap_flag_Conditions1--;
					continue;
				}
			}
			if (soap_flag_ActivationTimeout1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__duration(soap, "ns5:ActivationTimeout", &a->ns5__NewActionRule::ActivationTimeout, "xsd:duration"))
				{	soap_flag_ActivationTimeout1--;
					continue;
				}
			}
			if (soap_flag_PrimaryAction1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__integer(soap, "ns5:PrimaryAction", &a->ns5__NewActionRule::PrimaryAction, "xsd:integer"))
				{	soap_flag_PrimaryAction1--;
					continue;
				}
			}
			if (soap_flag_FailoverAction1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__integer(soap, "ns5:FailoverAction", &a->ns5__NewActionRule::FailoverAction, "xsd:integer"))
				{	soap_flag_FailoverAction1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Enabled1 > 0 || soap_flag_PrimaryAction1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns5__NewActionRule *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__NewActionRule, SOAP_TYPE_ns5__NewActionRule, sizeof(ns5__NewActionRule), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns5__NewActionRule * SOAP_FMAC2 soap_instantiate_ns5__NewActionRule(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__NewActionRule(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns5__NewActionRule *p;
	size_t k = sizeof(ns5__NewActionRule);
	if (n < 0)
	{	p = SOAP_NEW(ns5__NewActionRule);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns5__NewActionRule, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns5__NewActionRule location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns5__NewActionRule, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns5__NewActionRule::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns5__NewActionRule(soap, tag ? tag : "ns5:NewActionRule", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__NewActionRule::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__NewActionRule(soap, this, tag, type);
}

SOAP_FMAC3 ns5__NewActionRule * SOAP_FMAC4 soap_get_ns5__NewActionRule(struct soap *soap, ns5__NewActionRule *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__NewActionRule(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns4__BaseFaultType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->ns4__BaseFaultType::__any);
	soap_default_dateTime(soap, &this->ns4__BaseFaultType::Timestamp);
	this->ns4__BaseFaultType::Originator = NULL;
	this->ns4__BaseFaultType::ErrorCode = NULL;
	soap_default_std__vectorTemplateOf_ns4__BaseFaultType_Description(soap, &this->ns4__BaseFaultType::Description);
	this->ns4__BaseFaultType::FaultCause = NULL;
	soap_default_xsd__anyAttribute(soap, &this->ns4__BaseFaultType::__anyAttribute);
}

void ns4__BaseFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->ns4__BaseFaultType::__any);
	soap_embedded(soap, &this->ns4__BaseFaultType::Timestamp, SOAP_TYPE_dateTime);
	soap_serialize_PointerTons6__EndpointReferenceType(soap, &this->ns4__BaseFaultType::Originator);
	soap_serialize_PointerTo_ns4__BaseFaultType_ErrorCode(soap, &this->ns4__BaseFaultType::ErrorCode);
	soap_serialize_std__vectorTemplateOf_ns4__BaseFaultType_Description(soap, &this->ns4__BaseFaultType::Description);
	soap_serialize_PointerTo_ns4__BaseFaultType_FaultCause(soap, &this->ns4__BaseFaultType::FaultCause);
#endif
}

int ns4__BaseFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__BaseFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__BaseFaultType(struct soap *soap, const char *tag, int id, const ns4__BaseFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((ns4__BaseFaultType*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__BaseFaultType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->ns4__BaseFaultType::__any, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "ns4:Timestamp", -1, &a->ns4__BaseFaultType::Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTons6__EndpointReferenceType(soap, "ns4:Originator", -1, &a->ns4__BaseFaultType::Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_ns4__BaseFaultType_ErrorCode(soap, "ns4:ErrorCode", -1, &a->ns4__BaseFaultType::ErrorCode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_ns4__BaseFaultType_Description(soap, "ns4:Description", -1, &a->ns4__BaseFaultType::Description, ""))
		return soap->error;
	if (soap_out_PointerTo_ns4__BaseFaultType_FaultCause(soap, "ns4:FaultCause", -1, &a->ns4__BaseFaultType::FaultCause, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns4__BaseFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__BaseFaultType(soap, tag, this, type);
}

SOAP_FMAC3 ns4__BaseFaultType * SOAP_FMAC4 soap_in_ns4__BaseFaultType(struct soap *soap, const char *tag, ns4__BaseFaultType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__BaseFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__BaseFaultType, sizeof(ns4__BaseFaultType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns4__BaseFaultType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns4__BaseFaultType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((ns4__BaseFaultType*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Timestamp1 = 1;
	size_t soap_flag_Originator1 = 1;
	size_t soap_flag_ErrorCode1 = 1;
	size_t soap_flag_FaultCause1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "ns4:Timestamp", &a->ns4__BaseFaultType::Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp1--;
					continue;
				}
			}
			if (soap_flag_Originator1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons6__EndpointReferenceType(soap, "ns4:Originator", &a->ns4__BaseFaultType::Originator, "ns6:EndpointReferenceType"))
				{	soap_flag_Originator1--;
					continue;
				}
			}
			if (soap_flag_ErrorCode1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns4__BaseFaultType_ErrorCode(soap, "ns4:ErrorCode", &a->ns4__BaseFaultType::ErrorCode, ""))
				{	soap_flag_ErrorCode1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_ns4__BaseFaultType_Description(soap, "ns4:Description", &a->ns4__BaseFaultType::Description, ""))
					continue;
			}
			if (soap_flag_FaultCause1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns4__BaseFaultType_FaultCause(soap, "ns4:FaultCause", &a->ns4__BaseFaultType::FaultCause, ""))
				{	soap_flag_FaultCause1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->ns4__BaseFaultType::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns4__BaseFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__BaseFaultType, SOAP_TYPE_ns4__BaseFaultType, sizeof(ns4__BaseFaultType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns4__BaseFaultType * SOAP_FMAC2 soap_instantiate_ns4__BaseFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__BaseFaultType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (soap && type && !soap_match_tag(soap, type, "ns3:SubscribeCreationFailedFaultType"))
		return soap_instantiate_ns3__SubscribeCreationFailedFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns3:InvalidFilterFaultType"))
		return soap_instantiate_ns3__InvalidFilterFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns3:TopicExpressionDialectUnknownFaultType"))
		return soap_instantiate_ns3__TopicExpressionDialectUnknownFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns3:InvalidTopicExpressionFaultType"))
		return soap_instantiate_ns3__InvalidTopicExpressionFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns3:TopicNotSupportedFaultType"))
		return soap_instantiate_ns3__TopicNotSupportedFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns3:MultipleTopicsSpecifiedFaultType"))
		return soap_instantiate_ns3__MultipleTopicsSpecifiedFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns3:InvalidProducerPropertiesExpressionFaultType"))
		return soap_instantiate_ns3__InvalidProducerPropertiesExpressionFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns3:InvalidMessageContentExpressionFaultType"))
		return soap_instantiate_ns3__InvalidMessageContentExpressionFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns3:UnrecognizedPolicyRequestFaultType"))
		return soap_instantiate_ns3__UnrecognizedPolicyRequestFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns3:UnsupportedPolicyRequestFaultType"))
		return soap_instantiate_ns3__UnsupportedPolicyRequestFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns3:NotifyMessageNotSupportedFaultType"))
		return soap_instantiate_ns3__NotifyMessageNotSupportedFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns3:UnacceptableInitialTerminationTimeFaultType"))
		return soap_instantiate_ns3__UnacceptableInitialTerminationTimeFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns3:NoCurrentMessageOnTopicFaultType"))
		return soap_instantiate_ns3__NoCurrentMessageOnTopicFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns3:UnableToGetMessagesFaultType"))
		return soap_instantiate_ns3__UnableToGetMessagesFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns3:UnableToDestroyPullPointFaultType"))
		return soap_instantiate_ns3__UnableToDestroyPullPointFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns3:UnableToCreatePullPointFaultType"))
		return soap_instantiate_ns3__UnableToCreatePullPointFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns3:UnacceptableTerminationTimeFaultType"))
		return soap_instantiate_ns3__UnacceptableTerminationTimeFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns3:UnableToDestroySubscriptionFaultType"))
		return soap_instantiate_ns3__UnableToDestroySubscriptionFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns3:PauseFailedFaultType"))
		return soap_instantiate_ns3__PauseFailedFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns3:ResumeFailedFaultType"))
		return soap_instantiate_ns3__ResumeFailedFaultType(soap, n, NULL, NULL, size);
	ns4__BaseFaultType *p;
	size_t k = sizeof(ns4__BaseFaultType);
	if (n < 0)
	{	p = SOAP_NEW(ns4__BaseFaultType);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns4__BaseFaultType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns4__BaseFaultType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns4__BaseFaultType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns4__BaseFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns4__BaseFaultType(soap, tag ? tag : "ns4:BaseFaultType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns4__BaseFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__BaseFaultType(soap, this, tag, type);
}

SOAP_FMAC3 ns4__BaseFaultType * SOAP_FMAC4 soap_get_ns4__BaseFaultType(struct soap *soap, ns4__BaseFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__BaseFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns3__ResumeSubscriptionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->_ns3__ResumeSubscriptionResponse::__any);
	/* transient soap skipped */
}

void _ns3__ResumeSubscriptionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->_ns3__ResumeSubscriptionResponse::__any);
#endif
}

int _ns3__ResumeSubscriptionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__ResumeSubscriptionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__ResumeSubscriptionResponse(struct soap *soap, const char *tag, int id, const _ns3__ResumeSubscriptionResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__ResumeSubscriptionResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->_ns3__ResumeSubscriptionResponse::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns3__ResumeSubscriptionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__ResumeSubscriptionResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__ResumeSubscriptionResponse * SOAP_FMAC4 soap_in__ns3__ResumeSubscriptionResponse(struct soap *soap, const char *tag, _ns3__ResumeSubscriptionResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__ResumeSubscriptionResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__ResumeSubscriptionResponse, sizeof(_ns3__ResumeSubscriptionResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns3__ResumeSubscriptionResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns3__ResumeSubscriptionResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->_ns3__ResumeSubscriptionResponse::__any, "xsd:anyType"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__ResumeSubscriptionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__ResumeSubscriptionResponse, SOAP_TYPE__ns3__ResumeSubscriptionResponse, sizeof(_ns3__ResumeSubscriptionResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns3__ResumeSubscriptionResponse * SOAP_FMAC2 soap_instantiate__ns3__ResumeSubscriptionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__ResumeSubscriptionResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns3__ResumeSubscriptionResponse *p;
	size_t k = sizeof(_ns3__ResumeSubscriptionResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns3__ResumeSubscriptionResponse);
		if (p)
			((_ns3__ResumeSubscriptionResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns3__ResumeSubscriptionResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns3__ResumeSubscriptionResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns3__ResumeSubscriptionResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns3__ResumeSubscriptionResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns3__ResumeSubscriptionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns3__ResumeSubscriptionResponse(soap, tag ? tag : "ns3:ResumeSubscriptionResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__ResumeSubscriptionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__ResumeSubscriptionResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__ResumeSubscriptionResponse * SOAP_FMAC4 soap_get__ns3__ResumeSubscriptionResponse(struct soap *soap, _ns3__ResumeSubscriptionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__ResumeSubscriptionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns3__ResumeSubscription::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->_ns3__ResumeSubscription::__any);
	/* transient soap skipped */
}

void _ns3__ResumeSubscription::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->_ns3__ResumeSubscription::__any);
#endif
}

int _ns3__ResumeSubscription::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__ResumeSubscription(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__ResumeSubscription(struct soap *soap, const char *tag, int id, const _ns3__ResumeSubscription *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__ResumeSubscription), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->_ns3__ResumeSubscription::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns3__ResumeSubscription::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__ResumeSubscription(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__ResumeSubscription * SOAP_FMAC4 soap_in__ns3__ResumeSubscription(struct soap *soap, const char *tag, _ns3__ResumeSubscription *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__ResumeSubscription *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__ResumeSubscription, sizeof(_ns3__ResumeSubscription), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns3__ResumeSubscription)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns3__ResumeSubscription *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->_ns3__ResumeSubscription::__any, "xsd:anyType"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__ResumeSubscription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__ResumeSubscription, SOAP_TYPE__ns3__ResumeSubscription, sizeof(_ns3__ResumeSubscription), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns3__ResumeSubscription * SOAP_FMAC2 soap_instantiate__ns3__ResumeSubscription(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__ResumeSubscription(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns3__ResumeSubscription *p;
	size_t k = sizeof(_ns3__ResumeSubscription);
	if (n < 0)
	{	p = SOAP_NEW(_ns3__ResumeSubscription);
		if (p)
			((_ns3__ResumeSubscription*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns3__ResumeSubscription, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns3__ResumeSubscription*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns3__ResumeSubscription location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns3__ResumeSubscription, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns3__ResumeSubscription::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns3__ResumeSubscription(soap, tag ? tag : "ns3:ResumeSubscription", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__ResumeSubscription::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__ResumeSubscription(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__ResumeSubscription * SOAP_FMAC4 soap_get__ns3__ResumeSubscription(struct soap *soap, _ns3__ResumeSubscription *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__ResumeSubscription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns3__PauseSubscriptionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->_ns3__PauseSubscriptionResponse::__any);
	/* transient soap skipped */
}

void _ns3__PauseSubscriptionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->_ns3__PauseSubscriptionResponse::__any);
#endif
}

int _ns3__PauseSubscriptionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__PauseSubscriptionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__PauseSubscriptionResponse(struct soap *soap, const char *tag, int id, const _ns3__PauseSubscriptionResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__PauseSubscriptionResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->_ns3__PauseSubscriptionResponse::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns3__PauseSubscriptionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__PauseSubscriptionResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__PauseSubscriptionResponse * SOAP_FMAC4 soap_in__ns3__PauseSubscriptionResponse(struct soap *soap, const char *tag, _ns3__PauseSubscriptionResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__PauseSubscriptionResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__PauseSubscriptionResponse, sizeof(_ns3__PauseSubscriptionResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns3__PauseSubscriptionResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns3__PauseSubscriptionResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->_ns3__PauseSubscriptionResponse::__any, "xsd:anyType"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__PauseSubscriptionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__PauseSubscriptionResponse, SOAP_TYPE__ns3__PauseSubscriptionResponse, sizeof(_ns3__PauseSubscriptionResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns3__PauseSubscriptionResponse * SOAP_FMAC2 soap_instantiate__ns3__PauseSubscriptionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__PauseSubscriptionResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns3__PauseSubscriptionResponse *p;
	size_t k = sizeof(_ns3__PauseSubscriptionResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns3__PauseSubscriptionResponse);
		if (p)
			((_ns3__PauseSubscriptionResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns3__PauseSubscriptionResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns3__PauseSubscriptionResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns3__PauseSubscriptionResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns3__PauseSubscriptionResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns3__PauseSubscriptionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns3__PauseSubscriptionResponse(soap, tag ? tag : "ns3:PauseSubscriptionResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__PauseSubscriptionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__PauseSubscriptionResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__PauseSubscriptionResponse * SOAP_FMAC4 soap_get__ns3__PauseSubscriptionResponse(struct soap *soap, _ns3__PauseSubscriptionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__PauseSubscriptionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns3__PauseSubscription::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->_ns3__PauseSubscription::__any);
	/* transient soap skipped */
}

void _ns3__PauseSubscription::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->_ns3__PauseSubscription::__any);
#endif
}

int _ns3__PauseSubscription::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__PauseSubscription(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__PauseSubscription(struct soap *soap, const char *tag, int id, const _ns3__PauseSubscription *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__PauseSubscription), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->_ns3__PauseSubscription::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns3__PauseSubscription::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__PauseSubscription(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__PauseSubscription * SOAP_FMAC4 soap_in__ns3__PauseSubscription(struct soap *soap, const char *tag, _ns3__PauseSubscription *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__PauseSubscription *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__PauseSubscription, sizeof(_ns3__PauseSubscription), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns3__PauseSubscription)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns3__PauseSubscription *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->_ns3__PauseSubscription::__any, "xsd:anyType"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__PauseSubscription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__PauseSubscription, SOAP_TYPE__ns3__PauseSubscription, sizeof(_ns3__PauseSubscription), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns3__PauseSubscription * SOAP_FMAC2 soap_instantiate__ns3__PauseSubscription(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__PauseSubscription(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns3__PauseSubscription *p;
	size_t k = sizeof(_ns3__PauseSubscription);
	if (n < 0)
	{	p = SOAP_NEW(_ns3__PauseSubscription);
		if (p)
			((_ns3__PauseSubscription*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns3__PauseSubscription, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns3__PauseSubscription*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns3__PauseSubscription location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns3__PauseSubscription, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns3__PauseSubscription::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns3__PauseSubscription(soap, tag ? tag : "ns3:PauseSubscription", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__PauseSubscription::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__PauseSubscription(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__PauseSubscription * SOAP_FMAC4 soap_get__ns3__PauseSubscription(struct soap *soap, _ns3__PauseSubscription *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__PauseSubscription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns3__UnsubscribeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->_ns3__UnsubscribeResponse::__any);
	/* transient soap skipped */
}

void _ns3__UnsubscribeResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->_ns3__UnsubscribeResponse::__any);
#endif
}

int _ns3__UnsubscribeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__UnsubscribeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__UnsubscribeResponse(struct soap *soap, const char *tag, int id, const _ns3__UnsubscribeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__UnsubscribeResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->_ns3__UnsubscribeResponse::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns3__UnsubscribeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__UnsubscribeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__UnsubscribeResponse * SOAP_FMAC4 soap_in__ns3__UnsubscribeResponse(struct soap *soap, const char *tag, _ns3__UnsubscribeResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__UnsubscribeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__UnsubscribeResponse, sizeof(_ns3__UnsubscribeResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns3__UnsubscribeResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns3__UnsubscribeResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->_ns3__UnsubscribeResponse::__any, "xsd:anyType"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__UnsubscribeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__UnsubscribeResponse, SOAP_TYPE__ns3__UnsubscribeResponse, sizeof(_ns3__UnsubscribeResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns3__UnsubscribeResponse * SOAP_FMAC2 soap_instantiate__ns3__UnsubscribeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__UnsubscribeResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns3__UnsubscribeResponse *p;
	size_t k = sizeof(_ns3__UnsubscribeResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns3__UnsubscribeResponse);
		if (p)
			((_ns3__UnsubscribeResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns3__UnsubscribeResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns3__UnsubscribeResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns3__UnsubscribeResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns3__UnsubscribeResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns3__UnsubscribeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns3__UnsubscribeResponse(soap, tag ? tag : "ns3:UnsubscribeResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__UnsubscribeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__UnsubscribeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__UnsubscribeResponse * SOAP_FMAC4 soap_get__ns3__UnsubscribeResponse(struct soap *soap, _ns3__UnsubscribeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__UnsubscribeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns3__Unsubscribe::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->_ns3__Unsubscribe::__any);
	/* transient soap skipped */
}

void _ns3__Unsubscribe::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->_ns3__Unsubscribe::__any);
#endif
}

int _ns3__Unsubscribe::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__Unsubscribe(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__Unsubscribe(struct soap *soap, const char *tag, int id, const _ns3__Unsubscribe *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__Unsubscribe), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->_ns3__Unsubscribe::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns3__Unsubscribe::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__Unsubscribe(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__Unsubscribe * SOAP_FMAC4 soap_in__ns3__Unsubscribe(struct soap *soap, const char *tag, _ns3__Unsubscribe *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__Unsubscribe *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__Unsubscribe, sizeof(_ns3__Unsubscribe), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns3__Unsubscribe)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns3__Unsubscribe *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->_ns3__Unsubscribe::__any, "xsd:anyType"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__Unsubscribe *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__Unsubscribe, SOAP_TYPE__ns3__Unsubscribe, sizeof(_ns3__Unsubscribe), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns3__Unsubscribe * SOAP_FMAC2 soap_instantiate__ns3__Unsubscribe(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__Unsubscribe(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns3__Unsubscribe *p;
	size_t k = sizeof(_ns3__Unsubscribe);
	if (n < 0)
	{	p = SOAP_NEW(_ns3__Unsubscribe);
		if (p)
			((_ns3__Unsubscribe*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns3__Unsubscribe, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns3__Unsubscribe*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns3__Unsubscribe location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns3__Unsubscribe, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns3__Unsubscribe::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns3__Unsubscribe(soap, tag ? tag : "ns3:Unsubscribe", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__Unsubscribe::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__Unsubscribe(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__Unsubscribe * SOAP_FMAC4 soap_get__ns3__Unsubscribe(struct soap *soap, _ns3__Unsubscribe *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__Unsubscribe(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns3__RenewResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_dateTime(soap, &this->_ns3__RenewResponse::TerminationTime);
	this->_ns3__RenewResponse::CurrentTime = NULL;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->_ns3__RenewResponse::__any);
	/* transient soap skipped */
}

void _ns3__RenewResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_ns3__RenewResponse::TerminationTime, SOAP_TYPE_dateTime);
	soap_serialize_PointerTodateTime(soap, &this->_ns3__RenewResponse::CurrentTime);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->_ns3__RenewResponse::__any);
#endif
}

int _ns3__RenewResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__RenewResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__RenewResponse(struct soap *soap, const char *tag, int id, const _ns3__RenewResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__RenewResponse), type))
		return soap->error;
	if (soap_out_dateTime(soap, "ns3:TerminationTime", -1, &a->_ns3__RenewResponse::TerminationTime, ""))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "ns3:CurrentTime", -1, &a->_ns3__RenewResponse::CurrentTime, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->_ns3__RenewResponse::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns3__RenewResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__RenewResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__RenewResponse * SOAP_FMAC4 soap_in__ns3__RenewResponse(struct soap *soap, const char *tag, _ns3__RenewResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__RenewResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__RenewResponse, sizeof(_ns3__RenewResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns3__RenewResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns3__RenewResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_TerminationTime1 = 1;
	size_t soap_flag_CurrentTime1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TerminationTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "ns3:TerminationTime", &a->_ns3__RenewResponse::TerminationTime, "xsd:dateTime"))
				{	soap_flag_TerminationTime1--;
					continue;
				}
			}
			if (soap_flag_CurrentTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "ns3:CurrentTime", &a->_ns3__RenewResponse::CurrentTime, "xsd:dateTime"))
				{	soap_flag_CurrentTime1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->_ns3__RenewResponse::__any, "xsd:anyType"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TerminationTime1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns3__RenewResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__RenewResponse, SOAP_TYPE__ns3__RenewResponse, sizeof(_ns3__RenewResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns3__RenewResponse * SOAP_FMAC2 soap_instantiate__ns3__RenewResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__RenewResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns3__RenewResponse *p;
	size_t k = sizeof(_ns3__RenewResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns3__RenewResponse);
		if (p)
			((_ns3__RenewResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns3__RenewResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns3__RenewResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns3__RenewResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns3__RenewResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns3__RenewResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns3__RenewResponse(soap, tag ? tag : "ns3:RenewResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__RenewResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__RenewResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__RenewResponse * SOAP_FMAC4 soap_get__ns3__RenewResponse(struct soap *soap, _ns3__RenewResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__RenewResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns3__Renew::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__Renew::TerminationTime = NULL;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->_ns3__Renew::__any);
	/* transient soap skipped */
}

void _ns3__Renew::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons3__AbsoluteOrRelativeTimeType(soap, &this->_ns3__Renew::TerminationTime);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->_ns3__Renew::__any);
#endif
}

int _ns3__Renew::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__Renew(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__Renew(struct soap *soap, const char *tag, int id, const _ns3__Renew *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__Renew), type))
		return soap->error;
	if (!a->_ns3__Renew::TerminationTime)
	{	if (soap_element_nil(soap, "ns3:TerminationTime"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons3__AbsoluteOrRelativeTimeType(soap, "ns3:TerminationTime", -1, &a->_ns3__Renew::TerminationTime, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->_ns3__Renew::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns3__Renew::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__Renew(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__Renew * SOAP_FMAC4 soap_in__ns3__Renew(struct soap *soap, const char *tag, _ns3__Renew *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__Renew *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__Renew, sizeof(_ns3__Renew), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns3__Renew)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns3__Renew *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_TerminationTime1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TerminationTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons3__AbsoluteOrRelativeTimeType(soap, "ns3:TerminationTime", &a->_ns3__Renew::TerminationTime, "ns3:AbsoluteOrRelativeTimeType"))
				{	soap_flag_TerminationTime1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->_ns3__Renew::__any, "xsd:anyType"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TerminationTime1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns3__Renew *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__Renew, SOAP_TYPE__ns3__Renew, sizeof(_ns3__Renew), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns3__Renew * SOAP_FMAC2 soap_instantiate__ns3__Renew(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__Renew(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns3__Renew *p;
	size_t k = sizeof(_ns3__Renew);
	if (n < 0)
	{	p = SOAP_NEW(_ns3__Renew);
		if (p)
			((_ns3__Renew*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns3__Renew, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns3__Renew*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns3__Renew location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns3__Renew, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns3__Renew::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns3__Renew(soap, tag ? tag : "ns3:Renew", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__Renew::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__Renew(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__Renew * SOAP_FMAC4 soap_get__ns3__Renew(struct soap *soap, _ns3__Renew *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__Renew(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns3__CreatePullPointResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__CreatePullPointResponse::PullPoint = NULL;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->_ns3__CreatePullPointResponse::__any);
	soap_default_xsd__anyAttribute(soap, &this->_ns3__CreatePullPointResponse::__anyAttribute);
	/* transient soap skipped */
}

void _ns3__CreatePullPointResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons6__EndpointReferenceType(soap, &this->_ns3__CreatePullPointResponse::PullPoint);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->_ns3__CreatePullPointResponse::__any);
#endif
}

int _ns3__CreatePullPointResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__CreatePullPointResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__CreatePullPointResponse(struct soap *soap, const char *tag, int id, const _ns3__CreatePullPointResponse *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((_ns3__CreatePullPointResponse*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__CreatePullPointResponse), type))
		return soap->error;
	if (!a->_ns3__CreatePullPointResponse::PullPoint)
	{	if (soap_element_empty(soap, "ns3:PullPoint"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons6__EndpointReferenceType(soap, "ns3:PullPoint", -1, &a->_ns3__CreatePullPointResponse::PullPoint, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->_ns3__CreatePullPointResponse::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns3__CreatePullPointResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__CreatePullPointResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__CreatePullPointResponse * SOAP_FMAC4 soap_in__ns3__CreatePullPointResponse(struct soap *soap, const char *tag, _ns3__CreatePullPointResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__CreatePullPointResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__CreatePullPointResponse, sizeof(_ns3__CreatePullPointResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns3__CreatePullPointResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns3__CreatePullPointResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((_ns3__CreatePullPointResponse*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_PullPoint1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PullPoint1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons6__EndpointReferenceType(soap, "ns3:PullPoint", &a->_ns3__CreatePullPointResponse::PullPoint, "ns6:EndpointReferenceType"))
				{	soap_flag_PullPoint1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->_ns3__CreatePullPointResponse::__any, "xsd:anyType"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_ns3__CreatePullPointResponse::PullPoint))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns3__CreatePullPointResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__CreatePullPointResponse, SOAP_TYPE__ns3__CreatePullPointResponse, sizeof(_ns3__CreatePullPointResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns3__CreatePullPointResponse * SOAP_FMAC2 soap_instantiate__ns3__CreatePullPointResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__CreatePullPointResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns3__CreatePullPointResponse *p;
	size_t k = sizeof(_ns3__CreatePullPointResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns3__CreatePullPointResponse);
		if (p)
			((_ns3__CreatePullPointResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns3__CreatePullPointResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns3__CreatePullPointResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns3__CreatePullPointResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns3__CreatePullPointResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns3__CreatePullPointResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns3__CreatePullPointResponse(soap, tag ? tag : "ns3:CreatePullPointResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__CreatePullPointResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__CreatePullPointResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__CreatePullPointResponse * SOAP_FMAC4 soap_get__ns3__CreatePullPointResponse(struct soap *soap, _ns3__CreatePullPointResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__CreatePullPointResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns3__CreatePullPoint::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->_ns3__CreatePullPoint::__any);
	soap_default_xsd__anyAttribute(soap, &this->_ns3__CreatePullPoint::__anyAttribute);
	/* transient soap skipped */
}

void _ns3__CreatePullPoint::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->_ns3__CreatePullPoint::__any);
#endif
}

int _ns3__CreatePullPoint::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__CreatePullPoint(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__CreatePullPoint(struct soap *soap, const char *tag, int id, const _ns3__CreatePullPoint *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((_ns3__CreatePullPoint*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__CreatePullPoint), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->_ns3__CreatePullPoint::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns3__CreatePullPoint::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__CreatePullPoint(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__CreatePullPoint * SOAP_FMAC4 soap_in__ns3__CreatePullPoint(struct soap *soap, const char *tag, _ns3__CreatePullPoint *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__CreatePullPoint *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__CreatePullPoint, sizeof(_ns3__CreatePullPoint), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns3__CreatePullPoint)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns3__CreatePullPoint *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((_ns3__CreatePullPoint*)a)->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->_ns3__CreatePullPoint::__any, "xsd:anyType"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__CreatePullPoint *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__CreatePullPoint, SOAP_TYPE__ns3__CreatePullPoint, sizeof(_ns3__CreatePullPoint), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns3__CreatePullPoint * SOAP_FMAC2 soap_instantiate__ns3__CreatePullPoint(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__CreatePullPoint(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns3__CreatePullPoint *p;
	size_t k = sizeof(_ns3__CreatePullPoint);
	if (n < 0)
	{	p = SOAP_NEW(_ns3__CreatePullPoint);
		if (p)
			((_ns3__CreatePullPoint*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns3__CreatePullPoint, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns3__CreatePullPoint*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns3__CreatePullPoint location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns3__CreatePullPoint, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns3__CreatePullPoint::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns3__CreatePullPoint(soap, tag ? tag : "ns3:CreatePullPoint", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__CreatePullPoint::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__CreatePullPoint(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__CreatePullPoint * SOAP_FMAC4 soap_get__ns3__CreatePullPoint(struct soap *soap, _ns3__CreatePullPoint *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__CreatePullPoint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns3__DestroyPullPointResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->_ns3__DestroyPullPointResponse::__any);
	soap_default_xsd__anyAttribute(soap, &this->_ns3__DestroyPullPointResponse::__anyAttribute);
	/* transient soap skipped */
}

void _ns3__DestroyPullPointResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->_ns3__DestroyPullPointResponse::__any);
#endif
}

int _ns3__DestroyPullPointResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__DestroyPullPointResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__DestroyPullPointResponse(struct soap *soap, const char *tag, int id, const _ns3__DestroyPullPointResponse *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((_ns3__DestroyPullPointResponse*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__DestroyPullPointResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->_ns3__DestroyPullPointResponse::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns3__DestroyPullPointResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__DestroyPullPointResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__DestroyPullPointResponse * SOAP_FMAC4 soap_in__ns3__DestroyPullPointResponse(struct soap *soap, const char *tag, _ns3__DestroyPullPointResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__DestroyPullPointResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__DestroyPullPointResponse, sizeof(_ns3__DestroyPullPointResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns3__DestroyPullPointResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns3__DestroyPullPointResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((_ns3__DestroyPullPointResponse*)a)->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->_ns3__DestroyPullPointResponse::__any, "xsd:anyType"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__DestroyPullPointResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__DestroyPullPointResponse, SOAP_TYPE__ns3__DestroyPullPointResponse, sizeof(_ns3__DestroyPullPointResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns3__DestroyPullPointResponse * SOAP_FMAC2 soap_instantiate__ns3__DestroyPullPointResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__DestroyPullPointResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns3__DestroyPullPointResponse *p;
	size_t k = sizeof(_ns3__DestroyPullPointResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns3__DestroyPullPointResponse);
		if (p)
			((_ns3__DestroyPullPointResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns3__DestroyPullPointResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns3__DestroyPullPointResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns3__DestroyPullPointResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns3__DestroyPullPointResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns3__DestroyPullPointResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns3__DestroyPullPointResponse(soap, tag ? tag : "ns3:DestroyPullPointResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__DestroyPullPointResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__DestroyPullPointResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__DestroyPullPointResponse * SOAP_FMAC4 soap_get__ns3__DestroyPullPointResponse(struct soap *soap, _ns3__DestroyPullPointResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__DestroyPullPointResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns3__DestroyPullPoint::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->_ns3__DestroyPullPoint::__any);
	soap_default_xsd__anyAttribute(soap, &this->_ns3__DestroyPullPoint::__anyAttribute);
	/* transient soap skipped */
}

void _ns3__DestroyPullPoint::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->_ns3__DestroyPullPoint::__any);
#endif
}

int _ns3__DestroyPullPoint::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__DestroyPullPoint(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__DestroyPullPoint(struct soap *soap, const char *tag, int id, const _ns3__DestroyPullPoint *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((_ns3__DestroyPullPoint*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__DestroyPullPoint), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->_ns3__DestroyPullPoint::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns3__DestroyPullPoint::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__DestroyPullPoint(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__DestroyPullPoint * SOAP_FMAC4 soap_in__ns3__DestroyPullPoint(struct soap *soap, const char *tag, _ns3__DestroyPullPoint *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__DestroyPullPoint *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__DestroyPullPoint, sizeof(_ns3__DestroyPullPoint), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns3__DestroyPullPoint)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns3__DestroyPullPoint *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((_ns3__DestroyPullPoint*)a)->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->_ns3__DestroyPullPoint::__any, "xsd:anyType"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__DestroyPullPoint *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__DestroyPullPoint, SOAP_TYPE__ns3__DestroyPullPoint, sizeof(_ns3__DestroyPullPoint), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns3__DestroyPullPoint * SOAP_FMAC2 soap_instantiate__ns3__DestroyPullPoint(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__DestroyPullPoint(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns3__DestroyPullPoint *p;
	size_t k = sizeof(_ns3__DestroyPullPoint);
	if (n < 0)
	{	p = SOAP_NEW(_ns3__DestroyPullPoint);
		if (p)
			((_ns3__DestroyPullPoint*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns3__DestroyPullPoint, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns3__DestroyPullPoint*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns3__DestroyPullPoint location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns3__DestroyPullPoint, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns3__DestroyPullPoint::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns3__DestroyPullPoint(soap, tag ? tag : "ns3:DestroyPullPoint", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__DestroyPullPoint::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__DestroyPullPoint(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__DestroyPullPoint * SOAP_FMAC4 soap_get__ns3__DestroyPullPoint(struct soap *soap, _ns3__DestroyPullPoint *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__DestroyPullPoint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns3__GetMessagesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons3__NotificationMessageHolderType(soap, &this->_ns3__GetMessagesResponse::NotificationMessage);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->_ns3__GetMessagesResponse::__any);
	soap_default_xsd__anyAttribute(soap, &this->_ns3__GetMessagesResponse::__anyAttribute);
	/* transient soap skipped */
}

void _ns3__GetMessagesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons3__NotificationMessageHolderType(soap, &this->_ns3__GetMessagesResponse::NotificationMessage);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->_ns3__GetMessagesResponse::__any);
#endif
}

int _ns3__GetMessagesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__GetMessagesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__GetMessagesResponse(struct soap *soap, const char *tag, int id, const _ns3__GetMessagesResponse *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((_ns3__GetMessagesResponse*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__GetMessagesResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons3__NotificationMessageHolderType(soap, "ns3:NotificationMessage", -1, &a->_ns3__GetMessagesResponse::NotificationMessage, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->_ns3__GetMessagesResponse::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns3__GetMessagesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__GetMessagesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__GetMessagesResponse * SOAP_FMAC4 soap_in__ns3__GetMessagesResponse(struct soap *soap, const char *tag, _ns3__GetMessagesResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__GetMessagesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__GetMessagesResponse, sizeof(_ns3__GetMessagesResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns3__GetMessagesResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns3__GetMessagesResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((_ns3__GetMessagesResponse*)a)->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons3__NotificationMessageHolderType(soap, "ns3:NotificationMessage", &a->_ns3__GetMessagesResponse::NotificationMessage, "ns3:NotificationMessageHolderType"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->_ns3__GetMessagesResponse::__any, "xsd:anyType"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__GetMessagesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__GetMessagesResponse, SOAP_TYPE__ns3__GetMessagesResponse, sizeof(_ns3__GetMessagesResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns3__GetMessagesResponse * SOAP_FMAC2 soap_instantiate__ns3__GetMessagesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__GetMessagesResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns3__GetMessagesResponse *p;
	size_t k = sizeof(_ns3__GetMessagesResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns3__GetMessagesResponse);
		if (p)
			((_ns3__GetMessagesResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns3__GetMessagesResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns3__GetMessagesResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns3__GetMessagesResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns3__GetMessagesResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns3__GetMessagesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns3__GetMessagesResponse(soap, tag ? tag : "ns3:GetMessagesResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__GetMessagesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__GetMessagesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__GetMessagesResponse * SOAP_FMAC4 soap_get__ns3__GetMessagesResponse(struct soap *soap, _ns3__GetMessagesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__GetMessagesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns3__GetMessages::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__GetMessages::MaximumNumber = NULL;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->_ns3__GetMessages::__any);
	soap_default_xsd__anyAttribute(soap, &this->_ns3__GetMessages::__anyAttribute);
	/* transient soap skipped */
}

void _ns3__GetMessages::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToxsd__nonNegativeInteger(soap, &this->_ns3__GetMessages::MaximumNumber);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->_ns3__GetMessages::__any);
#endif
}

int _ns3__GetMessages::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__GetMessages(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__GetMessages(struct soap *soap, const char *tag, int id, const _ns3__GetMessages *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((_ns3__GetMessages*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__GetMessages), type))
		return soap->error;
	if (soap_out_PointerToxsd__nonNegativeInteger(soap, "ns3:MaximumNumber", -1, &a->_ns3__GetMessages::MaximumNumber, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->_ns3__GetMessages::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns3__GetMessages::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__GetMessages(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__GetMessages * SOAP_FMAC4 soap_in__ns3__GetMessages(struct soap *soap, const char *tag, _ns3__GetMessages *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__GetMessages *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__GetMessages, sizeof(_ns3__GetMessages), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns3__GetMessages)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns3__GetMessages *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((_ns3__GetMessages*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_MaximumNumber1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MaximumNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__nonNegativeInteger(soap, "ns3:MaximumNumber", &a->_ns3__GetMessages::MaximumNumber, "xsd:nonNegativeInteger"))
				{	soap_flag_MaximumNumber1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->_ns3__GetMessages::__any, "xsd:anyType"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__GetMessages *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__GetMessages, SOAP_TYPE__ns3__GetMessages, sizeof(_ns3__GetMessages), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns3__GetMessages * SOAP_FMAC2 soap_instantiate__ns3__GetMessages(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__GetMessages(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns3__GetMessages *p;
	size_t k = sizeof(_ns3__GetMessages);
	if (n < 0)
	{	p = SOAP_NEW(_ns3__GetMessages);
		if (p)
			((_ns3__GetMessages*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns3__GetMessages, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns3__GetMessages*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns3__GetMessages location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns3__GetMessages, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns3__GetMessages::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns3__GetMessages(soap, tag ? tag : "ns3:GetMessages", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__GetMessages::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__GetMessages(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__GetMessages * SOAP_FMAC4 soap_get__ns3__GetMessages(struct soap *soap, _ns3__GetMessages *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__GetMessages(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns3__GetCurrentMessageResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->_ns3__GetCurrentMessageResponse::__any);
	/* transient soap skipped */
}

void _ns3__GetCurrentMessageResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->_ns3__GetCurrentMessageResponse::__any);
#endif
}

int _ns3__GetCurrentMessageResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__GetCurrentMessageResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__GetCurrentMessageResponse(struct soap *soap, const char *tag, int id, const _ns3__GetCurrentMessageResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__GetCurrentMessageResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->_ns3__GetCurrentMessageResponse::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns3__GetCurrentMessageResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__GetCurrentMessageResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__GetCurrentMessageResponse * SOAP_FMAC4 soap_in__ns3__GetCurrentMessageResponse(struct soap *soap, const char *tag, _ns3__GetCurrentMessageResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__GetCurrentMessageResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__GetCurrentMessageResponse, sizeof(_ns3__GetCurrentMessageResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns3__GetCurrentMessageResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns3__GetCurrentMessageResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->_ns3__GetCurrentMessageResponse::__any, "xsd:anyType"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__GetCurrentMessageResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__GetCurrentMessageResponse, SOAP_TYPE__ns3__GetCurrentMessageResponse, sizeof(_ns3__GetCurrentMessageResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns3__GetCurrentMessageResponse * SOAP_FMAC2 soap_instantiate__ns3__GetCurrentMessageResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__GetCurrentMessageResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns3__GetCurrentMessageResponse *p;
	size_t k = sizeof(_ns3__GetCurrentMessageResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns3__GetCurrentMessageResponse);
		if (p)
			((_ns3__GetCurrentMessageResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns3__GetCurrentMessageResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns3__GetCurrentMessageResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns3__GetCurrentMessageResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns3__GetCurrentMessageResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns3__GetCurrentMessageResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns3__GetCurrentMessageResponse(soap, tag ? tag : "ns3:GetCurrentMessageResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__GetCurrentMessageResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__GetCurrentMessageResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__GetCurrentMessageResponse * SOAP_FMAC4 soap_get__ns3__GetCurrentMessageResponse(struct soap *soap, _ns3__GetCurrentMessageResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__GetCurrentMessageResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns3__GetCurrentMessage::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__GetCurrentMessage::Topic = NULL;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->_ns3__GetCurrentMessage::__any);
	/* transient soap skipped */
}

void _ns3__GetCurrentMessage::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons3__TopicExpressionType(soap, &this->_ns3__GetCurrentMessage::Topic);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->_ns3__GetCurrentMessage::__any);
#endif
}

int _ns3__GetCurrentMessage::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__GetCurrentMessage(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__GetCurrentMessage(struct soap *soap, const char *tag, int id, const _ns3__GetCurrentMessage *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__GetCurrentMessage), type))
		return soap->error;
	if (!a->_ns3__GetCurrentMessage::Topic)
	{	if (soap_element_empty(soap, "ns3:Topic"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons3__TopicExpressionType(soap, "ns3:Topic", -1, &a->_ns3__GetCurrentMessage::Topic, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->_ns3__GetCurrentMessage::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns3__GetCurrentMessage::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__GetCurrentMessage(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__GetCurrentMessage * SOAP_FMAC4 soap_in__ns3__GetCurrentMessage(struct soap *soap, const char *tag, _ns3__GetCurrentMessage *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__GetCurrentMessage *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__GetCurrentMessage, sizeof(_ns3__GetCurrentMessage), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns3__GetCurrentMessage)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns3__GetCurrentMessage *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Topic1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Topic1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__TopicExpressionType(soap, "ns3:Topic", &a->_ns3__GetCurrentMessage::Topic, "ns3:TopicExpressionType"))
				{	soap_flag_Topic1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->_ns3__GetCurrentMessage::__any, "xsd:anyType"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_ns3__GetCurrentMessage::Topic))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns3__GetCurrentMessage *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__GetCurrentMessage, SOAP_TYPE__ns3__GetCurrentMessage, sizeof(_ns3__GetCurrentMessage), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns3__GetCurrentMessage * SOAP_FMAC2 soap_instantiate__ns3__GetCurrentMessage(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__GetCurrentMessage(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns3__GetCurrentMessage *p;
	size_t k = sizeof(_ns3__GetCurrentMessage);
	if (n < 0)
	{	p = SOAP_NEW(_ns3__GetCurrentMessage);
		if (p)
			((_ns3__GetCurrentMessage*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns3__GetCurrentMessage, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns3__GetCurrentMessage*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns3__GetCurrentMessage location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns3__GetCurrentMessage, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns3__GetCurrentMessage::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns3__GetCurrentMessage(soap, tag ? tag : "ns3:GetCurrentMessage", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__GetCurrentMessage::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__GetCurrentMessage(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__GetCurrentMessage * SOAP_FMAC4 soap_get__ns3__GetCurrentMessage(struct soap *soap, _ns3__GetCurrentMessage *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__GetCurrentMessage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns3__SubscribeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__SubscribeResponse::SubscriptionReference = NULL;
	this->_ns3__SubscribeResponse::CurrentTime = NULL;
	this->_ns3__SubscribeResponse::TerminationTime = NULL;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->_ns3__SubscribeResponse::__any);
	/* transient soap skipped */
}

void _ns3__SubscribeResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons6__EndpointReferenceType(soap, &this->_ns3__SubscribeResponse::SubscriptionReference);
	soap_serialize_PointerTodateTime(soap, &this->_ns3__SubscribeResponse::CurrentTime);
	soap_serialize_PointerTodateTime(soap, &this->_ns3__SubscribeResponse::TerminationTime);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->_ns3__SubscribeResponse::__any);
#endif
}

int _ns3__SubscribeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__SubscribeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__SubscribeResponse(struct soap *soap, const char *tag, int id, const _ns3__SubscribeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__SubscribeResponse), type))
		return soap->error;
	if (!a->_ns3__SubscribeResponse::SubscriptionReference)
	{	if (soap_element_empty(soap, "ns3:SubscriptionReference"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons6__EndpointReferenceType(soap, "ns3:SubscriptionReference", -1, &a->_ns3__SubscribeResponse::SubscriptionReference, ""))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "ns3:CurrentTime", -1, &a->_ns3__SubscribeResponse::CurrentTime, ""))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "ns3:TerminationTime", -1, &a->_ns3__SubscribeResponse::TerminationTime, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->_ns3__SubscribeResponse::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns3__SubscribeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__SubscribeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__SubscribeResponse * SOAP_FMAC4 soap_in__ns3__SubscribeResponse(struct soap *soap, const char *tag, _ns3__SubscribeResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__SubscribeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__SubscribeResponse, sizeof(_ns3__SubscribeResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns3__SubscribeResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns3__SubscribeResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SubscriptionReference1 = 1;
	size_t soap_flag_CurrentTime1 = 1;
	size_t soap_flag_TerminationTime1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SubscriptionReference1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons6__EndpointReferenceType(soap, "ns3:SubscriptionReference", &a->_ns3__SubscribeResponse::SubscriptionReference, "ns6:EndpointReferenceType"))
				{	soap_flag_SubscriptionReference1--;
					continue;
				}
			}
			if (soap_flag_CurrentTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "ns3:CurrentTime", &a->_ns3__SubscribeResponse::CurrentTime, "xsd:dateTime"))
				{	soap_flag_CurrentTime1--;
					continue;
				}
			}
			if (soap_flag_TerminationTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "ns3:TerminationTime", &a->_ns3__SubscribeResponse::TerminationTime, "xsd:dateTime"))
				{	soap_flag_TerminationTime1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->_ns3__SubscribeResponse::__any, "xsd:anyType"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_ns3__SubscribeResponse::SubscriptionReference))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns3__SubscribeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__SubscribeResponse, SOAP_TYPE__ns3__SubscribeResponse, sizeof(_ns3__SubscribeResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns3__SubscribeResponse * SOAP_FMAC2 soap_instantiate__ns3__SubscribeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__SubscribeResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns3__SubscribeResponse *p;
	size_t k = sizeof(_ns3__SubscribeResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns3__SubscribeResponse);
		if (p)
			((_ns3__SubscribeResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns3__SubscribeResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns3__SubscribeResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns3__SubscribeResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns3__SubscribeResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns3__SubscribeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns3__SubscribeResponse(soap, tag ? tag : "ns3:SubscribeResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__SubscribeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__SubscribeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__SubscribeResponse * SOAP_FMAC4 soap_get__ns3__SubscribeResponse(struct soap *soap, _ns3__SubscribeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__SubscribeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns3__Subscribe::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__Subscribe::ConsumerReference = NULL;
	this->_ns3__Subscribe::Filter = NULL;
	this->_ns3__Subscribe::InitialTerminationTime = NULL;
	this->_ns3__Subscribe::SubscriptionPolicy = NULL;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->_ns3__Subscribe::__any);
	/* transient soap skipped */
}

void _ns3__Subscribe::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons6__EndpointReferenceType(soap, &this->_ns3__Subscribe::ConsumerReference);
	soap_serialize_PointerTons3__FilterType(soap, &this->_ns3__Subscribe::Filter);
	soap_serialize_PointerTons3__AbsoluteOrRelativeTimeType(soap, &this->_ns3__Subscribe::InitialTerminationTime);
	soap_serialize_PointerTo_ns3__Subscribe_SubscriptionPolicy(soap, &this->_ns3__Subscribe::SubscriptionPolicy);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->_ns3__Subscribe::__any);
#endif
}

int _ns3__Subscribe::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__Subscribe(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__Subscribe(struct soap *soap, const char *tag, int id, const _ns3__Subscribe *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__Subscribe), type))
		return soap->error;
	if (!a->_ns3__Subscribe::ConsumerReference)
	{	if (soap_element_empty(soap, "ns3:ConsumerReference"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons6__EndpointReferenceType(soap, "ns3:ConsumerReference", -1, &a->_ns3__Subscribe::ConsumerReference, ""))
		return soap->error;
	if (soap_out_PointerTons3__FilterType(soap, "ns3:Filter", -1, &a->_ns3__Subscribe::Filter, ""))
		return soap->error;
	if (soap_out_PointerTons3__AbsoluteOrRelativeTimeType(soap, "ns3:InitialTerminationTime", -1, &a->_ns3__Subscribe::InitialTerminationTime, ""))
		return soap->error;
	if (soap_out_PointerTo_ns3__Subscribe_SubscriptionPolicy(soap, "ns3:SubscriptionPolicy", -1, &a->_ns3__Subscribe::SubscriptionPolicy, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->_ns3__Subscribe::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns3__Subscribe::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__Subscribe(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__Subscribe * SOAP_FMAC4 soap_in__ns3__Subscribe(struct soap *soap, const char *tag, _ns3__Subscribe *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__Subscribe *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__Subscribe, sizeof(_ns3__Subscribe), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns3__Subscribe)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns3__Subscribe *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ConsumerReference1 = 1;
	size_t soap_flag_Filter1 = 1;
	size_t soap_flag_InitialTerminationTime1 = 1;
	size_t soap_flag_SubscriptionPolicy1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConsumerReference1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons6__EndpointReferenceType(soap, "ns3:ConsumerReference", &a->_ns3__Subscribe::ConsumerReference, "ns6:EndpointReferenceType"))
				{	soap_flag_ConsumerReference1--;
					continue;
				}
			}
			if (soap_flag_Filter1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__FilterType(soap, "ns3:Filter", &a->_ns3__Subscribe::Filter, "ns3:FilterType"))
				{	soap_flag_Filter1--;
					continue;
				}
			}
			if (soap_flag_InitialTerminationTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons3__AbsoluteOrRelativeTimeType(soap, "ns3:InitialTerminationTime", &a->_ns3__Subscribe::InitialTerminationTime, "ns3:AbsoluteOrRelativeTimeType"))
				{	soap_flag_InitialTerminationTime1--;
					continue;
				}
			}
			if (soap_flag_SubscriptionPolicy1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns3__Subscribe_SubscriptionPolicy(soap, "ns3:SubscriptionPolicy", &a->_ns3__Subscribe::SubscriptionPolicy, ""))
				{	soap_flag_SubscriptionPolicy1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->_ns3__Subscribe::__any, "xsd:anyType"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_ns3__Subscribe::ConsumerReference))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns3__Subscribe *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__Subscribe, SOAP_TYPE__ns3__Subscribe, sizeof(_ns3__Subscribe), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns3__Subscribe * SOAP_FMAC2 soap_instantiate__ns3__Subscribe(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__Subscribe(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns3__Subscribe *p;
	size_t k = sizeof(_ns3__Subscribe);
	if (n < 0)
	{	p = SOAP_NEW(_ns3__Subscribe);
		if (p)
			((_ns3__Subscribe*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns3__Subscribe, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns3__Subscribe*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns3__Subscribe location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns3__Subscribe, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns3__Subscribe::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns3__Subscribe(soap, tag ? tag : "ns3:Subscribe", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__Subscribe::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__Subscribe(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__Subscribe * SOAP_FMAC4 soap_get__ns3__Subscribe(struct soap *soap, _ns3__Subscribe *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__Subscribe(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns3__UseRaw::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns3__UseRaw::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns3__UseRaw::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__UseRaw(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__UseRaw(struct soap *soap, const char *tag, int id, const _ns3__UseRaw *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__UseRaw), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns3__UseRaw::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__UseRaw(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__UseRaw * SOAP_FMAC4 soap_in__ns3__UseRaw(struct soap *soap, const char *tag, _ns3__UseRaw *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__UseRaw *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__UseRaw, sizeof(_ns3__UseRaw), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns3__UseRaw)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns3__UseRaw *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__UseRaw *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__UseRaw, SOAP_TYPE__ns3__UseRaw, sizeof(_ns3__UseRaw), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns3__UseRaw * SOAP_FMAC2 soap_instantiate__ns3__UseRaw(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__UseRaw(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns3__UseRaw *p;
	size_t k = sizeof(_ns3__UseRaw);
	if (n < 0)
	{	p = SOAP_NEW(_ns3__UseRaw);
		if (p)
			((_ns3__UseRaw*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns3__UseRaw, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns3__UseRaw*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns3__UseRaw location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns3__UseRaw, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns3__UseRaw::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns3__UseRaw(soap, tag ? tag : "ns3:UseRaw", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__UseRaw::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__UseRaw(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__UseRaw * SOAP_FMAC4 soap_get__ns3__UseRaw(struct soap *soap, _ns3__UseRaw *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__UseRaw(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns3__Notify::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons3__NotificationMessageHolderType(soap, &this->_ns3__Notify::NotificationMessage);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->_ns3__Notify::__any);
	/* transient soap skipped */
}

void _ns3__Notify::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons3__NotificationMessageHolderType(soap, &this->_ns3__Notify::NotificationMessage);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->_ns3__Notify::__any);
#endif
}

int _ns3__Notify::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__Notify(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__Notify(struct soap *soap, const char *tag, int id, const _ns3__Notify *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__Notify), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons3__NotificationMessageHolderType(soap, "ns3:NotificationMessage", -1, &a->_ns3__Notify::NotificationMessage, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->_ns3__Notify::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns3__Notify::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__Notify(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__Notify * SOAP_FMAC4 soap_in__ns3__Notify(struct soap *soap, const char *tag, _ns3__Notify *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__Notify *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__Notify, sizeof(_ns3__Notify), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns3__Notify)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns3__Notify *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons3__NotificationMessageHolderType(soap, "ns3:NotificationMessage", &a->_ns3__Notify::NotificationMessage, "ns3:NotificationMessageHolderType"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->_ns3__Notify::__any, "xsd:anyType"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->_ns3__Notify::NotificationMessage.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns3__Notify *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__Notify, SOAP_TYPE__ns3__Notify, sizeof(_ns3__Notify), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns3__Notify * SOAP_FMAC2 soap_instantiate__ns3__Notify(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__Notify(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns3__Notify *p;
	size_t k = sizeof(_ns3__Notify);
	if (n < 0)
	{	p = SOAP_NEW(_ns3__Notify);
		if (p)
			((_ns3__Notify*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns3__Notify, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns3__Notify*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns3__Notify location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns3__Notify, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns3__Notify::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns3__Notify(soap, tag ? tag : "ns3:Notify", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__Notify::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__Notify(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__Notify * SOAP_FMAC4 soap_get__ns3__Notify(struct soap *soap, _ns3__Notify *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__Notify(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns3__SubscriptionManagerRP::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__SubscriptionManagerRP::ConsumerReference = NULL;
	this->_ns3__SubscriptionManagerRP::Filter = NULL;
	this->_ns3__SubscriptionManagerRP::SubscriptionPolicy = NULL;
	this->_ns3__SubscriptionManagerRP::CreationTime = NULL;
	/* transient soap skipped */
}

void _ns3__SubscriptionManagerRP::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons6__EndpointReferenceType(soap, &this->_ns3__SubscriptionManagerRP::ConsumerReference);
	soap_serialize_PointerTons3__FilterType(soap, &this->_ns3__SubscriptionManagerRP::Filter);
	soap_serialize_PointerTons3__SubscriptionPolicyType(soap, &this->_ns3__SubscriptionManagerRP::SubscriptionPolicy);
	soap_serialize_PointerTodateTime(soap, &this->_ns3__SubscriptionManagerRP::CreationTime);
#endif
}

int _ns3__SubscriptionManagerRP::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__SubscriptionManagerRP(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__SubscriptionManagerRP(struct soap *soap, const char *tag, int id, const _ns3__SubscriptionManagerRP *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__SubscriptionManagerRP), type))
		return soap->error;
	if (!a->_ns3__SubscriptionManagerRP::ConsumerReference)
	{	if (soap_element_empty(soap, "ns3:ConsumerReference"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons6__EndpointReferenceType(soap, "ns3:ConsumerReference", -1, &a->_ns3__SubscriptionManagerRP::ConsumerReference, ""))
		return soap->error;
	if (soap_out_PointerTons3__FilterType(soap, "ns3:Filter", -1, &a->_ns3__SubscriptionManagerRP::Filter, ""))
		return soap->error;
	if (soap_out_PointerTons3__SubscriptionPolicyType(soap, "ns3:SubscriptionPolicy", -1, &a->_ns3__SubscriptionManagerRP::SubscriptionPolicy, ""))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "ns3:CreationTime", -1, &a->_ns3__SubscriptionManagerRP::CreationTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns3__SubscriptionManagerRP::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__SubscriptionManagerRP(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__SubscriptionManagerRP * SOAP_FMAC4 soap_in__ns3__SubscriptionManagerRP(struct soap *soap, const char *tag, _ns3__SubscriptionManagerRP *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__SubscriptionManagerRP *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__SubscriptionManagerRP, sizeof(_ns3__SubscriptionManagerRP), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns3__SubscriptionManagerRP)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns3__SubscriptionManagerRP *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ConsumerReference1 = 1;
	size_t soap_flag_Filter1 = 1;
	size_t soap_flag_SubscriptionPolicy1 = 1;
	size_t soap_flag_CreationTime1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConsumerReference1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons6__EndpointReferenceType(soap, "ns3:ConsumerReference", &a->_ns3__SubscriptionManagerRP::ConsumerReference, "ns6:EndpointReferenceType"))
				{	soap_flag_ConsumerReference1--;
					continue;
				}
			}
			if (soap_flag_Filter1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__FilterType(soap, "ns3:Filter", &a->_ns3__SubscriptionManagerRP::Filter, "ns3:FilterType"))
				{	soap_flag_Filter1--;
					continue;
				}
			}
			if (soap_flag_SubscriptionPolicy1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__SubscriptionPolicyType(soap, "ns3:SubscriptionPolicy", &a->_ns3__SubscriptionManagerRP::SubscriptionPolicy, "ns3:SubscriptionPolicyType"))
				{	soap_flag_SubscriptionPolicy1--;
					continue;
				}
			}
			if (soap_flag_CreationTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "ns3:CreationTime", &a->_ns3__SubscriptionManagerRP::CreationTime, "xsd:dateTime"))
				{	soap_flag_CreationTime1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_ns3__SubscriptionManagerRP::ConsumerReference))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns3__SubscriptionManagerRP *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__SubscriptionManagerRP, SOAP_TYPE__ns3__SubscriptionManagerRP, sizeof(_ns3__SubscriptionManagerRP), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns3__SubscriptionManagerRP * SOAP_FMAC2 soap_instantiate__ns3__SubscriptionManagerRP(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__SubscriptionManagerRP(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns3__SubscriptionManagerRP *p;
	size_t k = sizeof(_ns3__SubscriptionManagerRP);
	if (n < 0)
	{	p = SOAP_NEW(_ns3__SubscriptionManagerRP);
		if (p)
			((_ns3__SubscriptionManagerRP*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns3__SubscriptionManagerRP, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns3__SubscriptionManagerRP*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns3__SubscriptionManagerRP location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns3__SubscriptionManagerRP, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns3__SubscriptionManagerRP::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns3__SubscriptionManagerRP(soap, tag ? tag : "ns3:SubscriptionManagerRP", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__SubscriptionManagerRP::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__SubscriptionManagerRP(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__SubscriptionManagerRP * SOAP_FMAC4 soap_get__ns3__SubscriptionManagerRP(struct soap *soap, _ns3__SubscriptionManagerRP *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__SubscriptionManagerRP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns3__NotificationProducerRP::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons3__TopicExpressionType(soap, &this->_ns3__NotificationProducerRP::TopicExpression);
	this->_ns3__NotificationProducerRP::FixedTopicSet = NULL;
	soap_default_std__vectorTemplateOfxsd__anyURI(soap, &this->_ns3__NotificationProducerRP::TopicExpressionDialect);
	this->_ns3__NotificationProducerRP::ns2__TopicSet = NULL;
	/* transient soap skipped */
}

void _ns3__NotificationProducerRP::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons3__TopicExpressionType(soap, &this->_ns3__NotificationProducerRP::TopicExpression);
	soap_serialize_PointerTobool(soap, &this->_ns3__NotificationProducerRP::FixedTopicSet);
	soap_serialize_std__vectorTemplateOfxsd__anyURI(soap, &this->_ns3__NotificationProducerRP::TopicExpressionDialect);
	soap_serialize_PointerTons2__TopicSetType(soap, &this->_ns3__NotificationProducerRP::ns2__TopicSet);
#endif
}

int _ns3__NotificationProducerRP::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__NotificationProducerRP(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__NotificationProducerRP(struct soap *soap, const char *tag, int id, const _ns3__NotificationProducerRP *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__NotificationProducerRP), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons3__TopicExpressionType(soap, "ns3:TopicExpression", -1, &a->_ns3__NotificationProducerRP::TopicExpression, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns3:FixedTopicSet", -1, &a->_ns3__NotificationProducerRP::FixedTopicSet, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyURI(soap, "ns3:TopicExpressionDialect", -1, &a->_ns3__NotificationProducerRP::TopicExpressionDialect, ""))
		return soap->error;
	if (soap_out_PointerTons2__TopicSetType(soap, "ns2:TopicSet", -1, &a->_ns3__NotificationProducerRP::ns2__TopicSet, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns3__NotificationProducerRP::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__NotificationProducerRP(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__NotificationProducerRP * SOAP_FMAC4 soap_in__ns3__NotificationProducerRP(struct soap *soap, const char *tag, _ns3__NotificationProducerRP *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__NotificationProducerRP *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__NotificationProducerRP, sizeof(_ns3__NotificationProducerRP), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns3__NotificationProducerRP)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns3__NotificationProducerRP *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_FixedTopicSet1 = 1;
	size_t soap_flag_ns2__TopicSet1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons3__TopicExpressionType(soap, "ns3:TopicExpression", &a->_ns3__NotificationProducerRP::TopicExpression, "ns3:TopicExpressionType"))
					continue;
			}
			if (soap_flag_FixedTopicSet1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "ns3:FixedTopicSet", &a->_ns3__NotificationProducerRP::FixedTopicSet, "xsd:boolean"))
				{	soap_flag_FixedTopicSet1--;
					continue;
				}
				if (soap->error == SOAP_EMPTY)
				{	if (!(a->_ns3__NotificationProducerRP::FixedTopicSet = (bool *)soap_malloc(soap, sizeof(bool))))
						return NULL;
					*a->_ns3__NotificationProducerRP::FixedTopicSet = (bool)1;
					soap->error = SOAP_OK;
					soap_flag_FixedTopicSet1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyURI(soap, "ns3:TopicExpressionDialect", &a->_ns3__NotificationProducerRP::TopicExpressionDialect, "xsd:anyURI"))
					continue;
			}
			if (soap_flag_ns2__TopicSet1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__TopicSetType(soap, "ns2:TopicSet", &a->_ns3__NotificationProducerRP::ns2__TopicSet, "ns2:TopicSetType"))
				{	soap_flag_ns2__TopicSet1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__NotificationProducerRP *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__NotificationProducerRP, SOAP_TYPE__ns3__NotificationProducerRP, sizeof(_ns3__NotificationProducerRP), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns3__NotificationProducerRP * SOAP_FMAC2 soap_instantiate__ns3__NotificationProducerRP(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__NotificationProducerRP(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns3__NotificationProducerRP *p;
	size_t k = sizeof(_ns3__NotificationProducerRP);
	if (n < 0)
	{	p = SOAP_NEW(_ns3__NotificationProducerRP);
		if (p)
			((_ns3__NotificationProducerRP*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns3__NotificationProducerRP, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns3__NotificationProducerRP*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns3__NotificationProducerRP location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns3__NotificationProducerRP, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns3__NotificationProducerRP::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns3__NotificationProducerRP(soap, tag ? tag : "ns3:NotificationProducerRP", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__NotificationProducerRP::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__NotificationProducerRP(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__NotificationProducerRP * SOAP_FMAC4 soap_get__ns3__NotificationProducerRP(struct soap *soap, _ns3__NotificationProducerRP *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__NotificationProducerRP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__ResumeFailedFaultType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns4__BaseFaultType::soap_default(soap);
}

void ns3__ResumeFailedFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->ns4__BaseFaultType::soap_serialize(soap);
#endif
}

int ns3__ResumeFailedFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__ResumeFailedFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__ResumeFailedFaultType(struct soap *soap, const char *tag, int id, const ns3__ResumeFailedFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((ns4__BaseFaultType*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__ResumeFailedFaultType), type ? type : "ns3:ResumeFailedFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->ns4__BaseFaultType::__any, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "ns4:Timestamp", -1, &a->ns4__BaseFaultType::Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTons6__EndpointReferenceType(soap, "ns4:Originator", -1, &a->ns4__BaseFaultType::Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_ns4__BaseFaultType_ErrorCode(soap, "ns4:ErrorCode", -1, &a->ns4__BaseFaultType::ErrorCode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_ns4__BaseFaultType_Description(soap, "ns4:Description", -1, &a->ns4__BaseFaultType::Description, ""))
		return soap->error;
	if (soap_out_PointerTo_ns4__BaseFaultType_FaultCause(soap, "ns4:FaultCause", -1, &a->ns4__BaseFaultType::FaultCause, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__ResumeFailedFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__ResumeFailedFaultType(soap, tag, this, type);
}

SOAP_FMAC3 ns3__ResumeFailedFaultType * SOAP_FMAC4 soap_in_ns3__ResumeFailedFaultType(struct soap *soap, const char *tag, ns3__ResumeFailedFaultType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__ResumeFailedFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__ResumeFailedFaultType, sizeof(ns3__ResumeFailedFaultType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns3__ResumeFailedFaultType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__ResumeFailedFaultType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((ns4__BaseFaultType*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	size_t soap_flag_FaultCause2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "ns4:Timestamp", &a->ns4__BaseFaultType::Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons6__EndpointReferenceType(soap, "ns4:Originator", &a->ns4__BaseFaultType::Originator, "ns6:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns4__BaseFaultType_ErrorCode(soap, "ns4:ErrorCode", &a->ns4__BaseFaultType::ErrorCode, ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_ns4__BaseFaultType_Description(soap, "ns4:Description", &a->ns4__BaseFaultType::Description, ""))
					continue;
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns4__BaseFaultType_FaultCause(soap, "ns4:FaultCause", &a->ns4__BaseFaultType::FaultCause, ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->ns4__BaseFaultType::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns3__ResumeFailedFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__ResumeFailedFaultType, SOAP_TYPE_ns3__ResumeFailedFaultType, sizeof(ns3__ResumeFailedFaultType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__ResumeFailedFaultType * SOAP_FMAC2 soap_instantiate_ns3__ResumeFailedFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__ResumeFailedFaultType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__ResumeFailedFaultType *p;
	size_t k = sizeof(ns3__ResumeFailedFaultType);
	if (n < 0)
	{	p = SOAP_NEW(ns3__ResumeFailedFaultType);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns3__ResumeFailedFaultType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__ResumeFailedFaultType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns3__ResumeFailedFaultType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns3__ResumeFailedFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__ResumeFailedFaultType(soap, tag ? tag : "ns3:ResumeFailedFaultType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__ResumeFailedFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__ResumeFailedFaultType(soap, this, tag, type);
}

SOAP_FMAC3 ns3__ResumeFailedFaultType * SOAP_FMAC4 soap_get_ns3__ResumeFailedFaultType(struct soap *soap, ns3__ResumeFailedFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__ResumeFailedFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__PauseFailedFaultType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns4__BaseFaultType::soap_default(soap);
}

void ns3__PauseFailedFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->ns4__BaseFaultType::soap_serialize(soap);
#endif
}

int ns3__PauseFailedFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__PauseFailedFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__PauseFailedFaultType(struct soap *soap, const char *tag, int id, const ns3__PauseFailedFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((ns4__BaseFaultType*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__PauseFailedFaultType), type ? type : "ns3:PauseFailedFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->ns4__BaseFaultType::__any, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "ns4:Timestamp", -1, &a->ns4__BaseFaultType::Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTons6__EndpointReferenceType(soap, "ns4:Originator", -1, &a->ns4__BaseFaultType::Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_ns4__BaseFaultType_ErrorCode(soap, "ns4:ErrorCode", -1, &a->ns4__BaseFaultType::ErrorCode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_ns4__BaseFaultType_Description(soap, "ns4:Description", -1, &a->ns4__BaseFaultType::Description, ""))
		return soap->error;
	if (soap_out_PointerTo_ns4__BaseFaultType_FaultCause(soap, "ns4:FaultCause", -1, &a->ns4__BaseFaultType::FaultCause, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__PauseFailedFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__PauseFailedFaultType(soap, tag, this, type);
}

SOAP_FMAC3 ns3__PauseFailedFaultType * SOAP_FMAC4 soap_in_ns3__PauseFailedFaultType(struct soap *soap, const char *tag, ns3__PauseFailedFaultType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__PauseFailedFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__PauseFailedFaultType, sizeof(ns3__PauseFailedFaultType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns3__PauseFailedFaultType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__PauseFailedFaultType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((ns4__BaseFaultType*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	size_t soap_flag_FaultCause2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "ns4:Timestamp", &a->ns4__BaseFaultType::Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons6__EndpointReferenceType(soap, "ns4:Originator", &a->ns4__BaseFaultType::Originator, "ns6:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns4__BaseFaultType_ErrorCode(soap, "ns4:ErrorCode", &a->ns4__BaseFaultType::ErrorCode, ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_ns4__BaseFaultType_Description(soap, "ns4:Description", &a->ns4__BaseFaultType::Description, ""))
					continue;
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns4__BaseFaultType_FaultCause(soap, "ns4:FaultCause", &a->ns4__BaseFaultType::FaultCause, ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->ns4__BaseFaultType::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns3__PauseFailedFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__PauseFailedFaultType, SOAP_TYPE_ns3__PauseFailedFaultType, sizeof(ns3__PauseFailedFaultType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__PauseFailedFaultType * SOAP_FMAC2 soap_instantiate_ns3__PauseFailedFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__PauseFailedFaultType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__PauseFailedFaultType *p;
	size_t k = sizeof(ns3__PauseFailedFaultType);
	if (n < 0)
	{	p = SOAP_NEW(ns3__PauseFailedFaultType);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns3__PauseFailedFaultType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__PauseFailedFaultType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns3__PauseFailedFaultType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns3__PauseFailedFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__PauseFailedFaultType(soap, tag ? tag : "ns3:PauseFailedFaultType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__PauseFailedFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__PauseFailedFaultType(soap, this, tag, type);
}

SOAP_FMAC3 ns3__PauseFailedFaultType * SOAP_FMAC4 soap_get_ns3__PauseFailedFaultType(struct soap *soap, ns3__PauseFailedFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__PauseFailedFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__UnableToDestroySubscriptionFaultType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns4__BaseFaultType::soap_default(soap);
}

void ns3__UnableToDestroySubscriptionFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->ns4__BaseFaultType::soap_serialize(soap);
#endif
}

int ns3__UnableToDestroySubscriptionFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__UnableToDestroySubscriptionFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__UnableToDestroySubscriptionFaultType(struct soap *soap, const char *tag, int id, const ns3__UnableToDestroySubscriptionFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((ns4__BaseFaultType*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__UnableToDestroySubscriptionFaultType), type ? type : "ns3:UnableToDestroySubscriptionFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->ns4__BaseFaultType::__any, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "ns4:Timestamp", -1, &a->ns4__BaseFaultType::Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTons6__EndpointReferenceType(soap, "ns4:Originator", -1, &a->ns4__BaseFaultType::Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_ns4__BaseFaultType_ErrorCode(soap, "ns4:ErrorCode", -1, &a->ns4__BaseFaultType::ErrorCode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_ns4__BaseFaultType_Description(soap, "ns4:Description", -1, &a->ns4__BaseFaultType::Description, ""))
		return soap->error;
	if (soap_out_PointerTo_ns4__BaseFaultType_FaultCause(soap, "ns4:FaultCause", -1, &a->ns4__BaseFaultType::FaultCause, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__UnableToDestroySubscriptionFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__UnableToDestroySubscriptionFaultType(soap, tag, this, type);
}

SOAP_FMAC3 ns3__UnableToDestroySubscriptionFaultType * SOAP_FMAC4 soap_in_ns3__UnableToDestroySubscriptionFaultType(struct soap *soap, const char *tag, ns3__UnableToDestroySubscriptionFaultType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__UnableToDestroySubscriptionFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__UnableToDestroySubscriptionFaultType, sizeof(ns3__UnableToDestroySubscriptionFaultType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns3__UnableToDestroySubscriptionFaultType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__UnableToDestroySubscriptionFaultType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((ns4__BaseFaultType*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	size_t soap_flag_FaultCause2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "ns4:Timestamp", &a->ns4__BaseFaultType::Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons6__EndpointReferenceType(soap, "ns4:Originator", &a->ns4__BaseFaultType::Originator, "ns6:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns4__BaseFaultType_ErrorCode(soap, "ns4:ErrorCode", &a->ns4__BaseFaultType::ErrorCode, ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_ns4__BaseFaultType_Description(soap, "ns4:Description", &a->ns4__BaseFaultType::Description, ""))
					continue;
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns4__BaseFaultType_FaultCause(soap, "ns4:FaultCause", &a->ns4__BaseFaultType::FaultCause, ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->ns4__BaseFaultType::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns3__UnableToDestroySubscriptionFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__UnableToDestroySubscriptionFaultType, SOAP_TYPE_ns3__UnableToDestroySubscriptionFaultType, sizeof(ns3__UnableToDestroySubscriptionFaultType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__UnableToDestroySubscriptionFaultType * SOAP_FMAC2 soap_instantiate_ns3__UnableToDestroySubscriptionFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__UnableToDestroySubscriptionFaultType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__UnableToDestroySubscriptionFaultType *p;
	size_t k = sizeof(ns3__UnableToDestroySubscriptionFaultType);
	if (n < 0)
	{	p = SOAP_NEW(ns3__UnableToDestroySubscriptionFaultType);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns3__UnableToDestroySubscriptionFaultType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__UnableToDestroySubscriptionFaultType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns3__UnableToDestroySubscriptionFaultType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns3__UnableToDestroySubscriptionFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__UnableToDestroySubscriptionFaultType(soap, tag ? tag : "ns3:UnableToDestroySubscriptionFaultType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__UnableToDestroySubscriptionFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__UnableToDestroySubscriptionFaultType(soap, this, tag, type);
}

SOAP_FMAC3 ns3__UnableToDestroySubscriptionFaultType * SOAP_FMAC4 soap_get_ns3__UnableToDestroySubscriptionFaultType(struct soap *soap, ns3__UnableToDestroySubscriptionFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__UnableToDestroySubscriptionFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__UnacceptableTerminationTimeFaultType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns4__BaseFaultType::soap_default(soap);
	soap_default_dateTime(soap, &this->ns3__UnacceptableTerminationTimeFaultType::MinimumTime);
	this->ns3__UnacceptableTerminationTimeFaultType::MaximumTime = NULL;
}

void ns3__UnacceptableTerminationTimeFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns3__UnacceptableTerminationTimeFaultType::MinimumTime, SOAP_TYPE_dateTime);
	soap_serialize_PointerTodateTime(soap, &this->ns3__UnacceptableTerminationTimeFaultType::MaximumTime);
	this->ns4__BaseFaultType::soap_serialize(soap);
#endif
}

int ns3__UnacceptableTerminationTimeFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__UnacceptableTerminationTimeFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__UnacceptableTerminationTimeFaultType(struct soap *soap, const char *tag, int id, const ns3__UnacceptableTerminationTimeFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((ns4__BaseFaultType*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__UnacceptableTerminationTimeFaultType), type ? type : "ns3:UnacceptableTerminationTimeFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->ns4__BaseFaultType::__any, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "ns4:Timestamp", -1, &a->ns4__BaseFaultType::Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTons6__EndpointReferenceType(soap, "ns4:Originator", -1, &a->ns4__BaseFaultType::Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_ns4__BaseFaultType_ErrorCode(soap, "ns4:ErrorCode", -1, &a->ns4__BaseFaultType::ErrorCode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_ns4__BaseFaultType_Description(soap, "ns4:Description", -1, &a->ns4__BaseFaultType::Description, ""))
		return soap->error;
	if (soap_out_PointerTo_ns4__BaseFaultType_FaultCause(soap, "ns4:FaultCause", -1, &a->ns4__BaseFaultType::FaultCause, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "ns3:MinimumTime", -1, &a->ns3__UnacceptableTerminationTimeFaultType::MinimumTime, ""))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "ns3:MaximumTime", -1, &a->ns3__UnacceptableTerminationTimeFaultType::MaximumTime, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__UnacceptableTerminationTimeFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__UnacceptableTerminationTimeFaultType(soap, tag, this, type);
}

SOAP_FMAC3 ns3__UnacceptableTerminationTimeFaultType * SOAP_FMAC4 soap_in_ns3__UnacceptableTerminationTimeFaultType(struct soap *soap, const char *tag, ns3__UnacceptableTerminationTimeFaultType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__UnacceptableTerminationTimeFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__UnacceptableTerminationTimeFaultType, sizeof(ns3__UnacceptableTerminationTimeFaultType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns3__UnacceptableTerminationTimeFaultType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__UnacceptableTerminationTimeFaultType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((ns4__BaseFaultType*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	size_t soap_flag_FaultCause2 = 1;
	size_t soap_flag_MinimumTime1 = 1;
	size_t soap_flag_MaximumTime1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "ns4:Timestamp", &a->ns4__BaseFaultType::Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons6__EndpointReferenceType(soap, "ns4:Originator", &a->ns4__BaseFaultType::Originator, "ns6:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns4__BaseFaultType_ErrorCode(soap, "ns4:ErrorCode", &a->ns4__BaseFaultType::ErrorCode, ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_ns4__BaseFaultType_Description(soap, "ns4:Description", &a->ns4__BaseFaultType::Description, ""))
					continue;
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns4__BaseFaultType_FaultCause(soap, "ns4:FaultCause", &a->ns4__BaseFaultType::FaultCause, ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			}
			if (soap_flag_MinimumTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "ns3:MinimumTime", &a->ns3__UnacceptableTerminationTimeFaultType::MinimumTime, "xsd:dateTime"))
				{	soap_flag_MinimumTime1--;
					continue;
				}
			}
			if (soap_flag_MaximumTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "ns3:MaximumTime", &a->ns3__UnacceptableTerminationTimeFaultType::MaximumTime, "xsd:dateTime"))
				{	soap_flag_MaximumTime1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->ns4__BaseFaultType::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0 || soap_flag_MinimumTime1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns3__UnacceptableTerminationTimeFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__UnacceptableTerminationTimeFaultType, SOAP_TYPE_ns3__UnacceptableTerminationTimeFaultType, sizeof(ns3__UnacceptableTerminationTimeFaultType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__UnacceptableTerminationTimeFaultType * SOAP_FMAC2 soap_instantiate_ns3__UnacceptableTerminationTimeFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__UnacceptableTerminationTimeFaultType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__UnacceptableTerminationTimeFaultType *p;
	size_t k = sizeof(ns3__UnacceptableTerminationTimeFaultType);
	if (n < 0)
	{	p = SOAP_NEW(ns3__UnacceptableTerminationTimeFaultType);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns3__UnacceptableTerminationTimeFaultType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__UnacceptableTerminationTimeFaultType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns3__UnacceptableTerminationTimeFaultType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns3__UnacceptableTerminationTimeFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__UnacceptableTerminationTimeFaultType(soap, tag ? tag : "ns3:UnacceptableTerminationTimeFaultType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__UnacceptableTerminationTimeFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__UnacceptableTerminationTimeFaultType(soap, this, tag, type);
}

SOAP_FMAC3 ns3__UnacceptableTerminationTimeFaultType * SOAP_FMAC4 soap_get_ns3__UnacceptableTerminationTimeFaultType(struct soap *soap, ns3__UnacceptableTerminationTimeFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__UnacceptableTerminationTimeFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__UnableToCreatePullPointFaultType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns4__BaseFaultType::soap_default(soap);
}

void ns3__UnableToCreatePullPointFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->ns4__BaseFaultType::soap_serialize(soap);
#endif
}

int ns3__UnableToCreatePullPointFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__UnableToCreatePullPointFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__UnableToCreatePullPointFaultType(struct soap *soap, const char *tag, int id, const ns3__UnableToCreatePullPointFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((ns4__BaseFaultType*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__UnableToCreatePullPointFaultType), type ? type : "ns3:UnableToCreatePullPointFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->ns4__BaseFaultType::__any, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "ns4:Timestamp", -1, &a->ns4__BaseFaultType::Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTons6__EndpointReferenceType(soap, "ns4:Originator", -1, &a->ns4__BaseFaultType::Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_ns4__BaseFaultType_ErrorCode(soap, "ns4:ErrorCode", -1, &a->ns4__BaseFaultType::ErrorCode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_ns4__BaseFaultType_Description(soap, "ns4:Description", -1, &a->ns4__BaseFaultType::Description, ""))
		return soap->error;
	if (soap_out_PointerTo_ns4__BaseFaultType_FaultCause(soap, "ns4:FaultCause", -1, &a->ns4__BaseFaultType::FaultCause, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__UnableToCreatePullPointFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__UnableToCreatePullPointFaultType(soap, tag, this, type);
}

SOAP_FMAC3 ns3__UnableToCreatePullPointFaultType * SOAP_FMAC4 soap_in_ns3__UnableToCreatePullPointFaultType(struct soap *soap, const char *tag, ns3__UnableToCreatePullPointFaultType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__UnableToCreatePullPointFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__UnableToCreatePullPointFaultType, sizeof(ns3__UnableToCreatePullPointFaultType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns3__UnableToCreatePullPointFaultType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__UnableToCreatePullPointFaultType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((ns4__BaseFaultType*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	size_t soap_flag_FaultCause2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "ns4:Timestamp", &a->ns4__BaseFaultType::Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons6__EndpointReferenceType(soap, "ns4:Originator", &a->ns4__BaseFaultType::Originator, "ns6:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns4__BaseFaultType_ErrorCode(soap, "ns4:ErrorCode", &a->ns4__BaseFaultType::ErrorCode, ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_ns4__BaseFaultType_Description(soap, "ns4:Description", &a->ns4__BaseFaultType::Description, ""))
					continue;
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns4__BaseFaultType_FaultCause(soap, "ns4:FaultCause", &a->ns4__BaseFaultType::FaultCause, ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->ns4__BaseFaultType::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns3__UnableToCreatePullPointFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__UnableToCreatePullPointFaultType, SOAP_TYPE_ns3__UnableToCreatePullPointFaultType, sizeof(ns3__UnableToCreatePullPointFaultType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__UnableToCreatePullPointFaultType * SOAP_FMAC2 soap_instantiate_ns3__UnableToCreatePullPointFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__UnableToCreatePullPointFaultType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__UnableToCreatePullPointFaultType *p;
	size_t k = sizeof(ns3__UnableToCreatePullPointFaultType);
	if (n < 0)
	{	p = SOAP_NEW(ns3__UnableToCreatePullPointFaultType);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns3__UnableToCreatePullPointFaultType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__UnableToCreatePullPointFaultType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns3__UnableToCreatePullPointFaultType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns3__UnableToCreatePullPointFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__UnableToCreatePullPointFaultType(soap, tag ? tag : "ns3:UnableToCreatePullPointFaultType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__UnableToCreatePullPointFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__UnableToCreatePullPointFaultType(soap, this, tag, type);
}

SOAP_FMAC3 ns3__UnableToCreatePullPointFaultType * SOAP_FMAC4 soap_get_ns3__UnableToCreatePullPointFaultType(struct soap *soap, ns3__UnableToCreatePullPointFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__UnableToCreatePullPointFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__UnableToDestroyPullPointFaultType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns4__BaseFaultType::soap_default(soap);
}

void ns3__UnableToDestroyPullPointFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->ns4__BaseFaultType::soap_serialize(soap);
#endif
}

int ns3__UnableToDestroyPullPointFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__UnableToDestroyPullPointFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__UnableToDestroyPullPointFaultType(struct soap *soap, const char *tag, int id, const ns3__UnableToDestroyPullPointFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((ns4__BaseFaultType*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__UnableToDestroyPullPointFaultType), type ? type : "ns3:UnableToDestroyPullPointFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->ns4__BaseFaultType::__any, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "ns4:Timestamp", -1, &a->ns4__BaseFaultType::Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTons6__EndpointReferenceType(soap, "ns4:Originator", -1, &a->ns4__BaseFaultType::Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_ns4__BaseFaultType_ErrorCode(soap, "ns4:ErrorCode", -1, &a->ns4__BaseFaultType::ErrorCode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_ns4__BaseFaultType_Description(soap, "ns4:Description", -1, &a->ns4__BaseFaultType::Description, ""))
		return soap->error;
	if (soap_out_PointerTo_ns4__BaseFaultType_FaultCause(soap, "ns4:FaultCause", -1, &a->ns4__BaseFaultType::FaultCause, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__UnableToDestroyPullPointFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__UnableToDestroyPullPointFaultType(soap, tag, this, type);
}

SOAP_FMAC3 ns3__UnableToDestroyPullPointFaultType * SOAP_FMAC4 soap_in_ns3__UnableToDestroyPullPointFaultType(struct soap *soap, const char *tag, ns3__UnableToDestroyPullPointFaultType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__UnableToDestroyPullPointFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__UnableToDestroyPullPointFaultType, sizeof(ns3__UnableToDestroyPullPointFaultType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns3__UnableToDestroyPullPointFaultType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__UnableToDestroyPullPointFaultType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((ns4__BaseFaultType*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	size_t soap_flag_FaultCause2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "ns4:Timestamp", &a->ns4__BaseFaultType::Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons6__EndpointReferenceType(soap, "ns4:Originator", &a->ns4__BaseFaultType::Originator, "ns6:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns4__BaseFaultType_ErrorCode(soap, "ns4:ErrorCode", &a->ns4__BaseFaultType::ErrorCode, ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_ns4__BaseFaultType_Description(soap, "ns4:Description", &a->ns4__BaseFaultType::Description, ""))
					continue;
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns4__BaseFaultType_FaultCause(soap, "ns4:FaultCause", &a->ns4__BaseFaultType::FaultCause, ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->ns4__BaseFaultType::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns3__UnableToDestroyPullPointFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__UnableToDestroyPullPointFaultType, SOAP_TYPE_ns3__UnableToDestroyPullPointFaultType, sizeof(ns3__UnableToDestroyPullPointFaultType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__UnableToDestroyPullPointFaultType * SOAP_FMAC2 soap_instantiate_ns3__UnableToDestroyPullPointFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__UnableToDestroyPullPointFaultType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__UnableToDestroyPullPointFaultType *p;
	size_t k = sizeof(ns3__UnableToDestroyPullPointFaultType);
	if (n < 0)
	{	p = SOAP_NEW(ns3__UnableToDestroyPullPointFaultType);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns3__UnableToDestroyPullPointFaultType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__UnableToDestroyPullPointFaultType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns3__UnableToDestroyPullPointFaultType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns3__UnableToDestroyPullPointFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__UnableToDestroyPullPointFaultType(soap, tag ? tag : "ns3:UnableToDestroyPullPointFaultType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__UnableToDestroyPullPointFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__UnableToDestroyPullPointFaultType(soap, this, tag, type);
}

SOAP_FMAC3 ns3__UnableToDestroyPullPointFaultType * SOAP_FMAC4 soap_get_ns3__UnableToDestroyPullPointFaultType(struct soap *soap, ns3__UnableToDestroyPullPointFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__UnableToDestroyPullPointFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__UnableToGetMessagesFaultType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns4__BaseFaultType::soap_default(soap);
}

void ns3__UnableToGetMessagesFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->ns4__BaseFaultType::soap_serialize(soap);
#endif
}

int ns3__UnableToGetMessagesFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__UnableToGetMessagesFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__UnableToGetMessagesFaultType(struct soap *soap, const char *tag, int id, const ns3__UnableToGetMessagesFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((ns4__BaseFaultType*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__UnableToGetMessagesFaultType), type ? type : "ns3:UnableToGetMessagesFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->ns4__BaseFaultType::__any, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "ns4:Timestamp", -1, &a->ns4__BaseFaultType::Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTons6__EndpointReferenceType(soap, "ns4:Originator", -1, &a->ns4__BaseFaultType::Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_ns4__BaseFaultType_ErrorCode(soap, "ns4:ErrorCode", -1, &a->ns4__BaseFaultType::ErrorCode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_ns4__BaseFaultType_Description(soap, "ns4:Description", -1, &a->ns4__BaseFaultType::Description, ""))
		return soap->error;
	if (soap_out_PointerTo_ns4__BaseFaultType_FaultCause(soap, "ns4:FaultCause", -1, &a->ns4__BaseFaultType::FaultCause, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__UnableToGetMessagesFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__UnableToGetMessagesFaultType(soap, tag, this, type);
}

SOAP_FMAC3 ns3__UnableToGetMessagesFaultType * SOAP_FMAC4 soap_in_ns3__UnableToGetMessagesFaultType(struct soap *soap, const char *tag, ns3__UnableToGetMessagesFaultType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__UnableToGetMessagesFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__UnableToGetMessagesFaultType, sizeof(ns3__UnableToGetMessagesFaultType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns3__UnableToGetMessagesFaultType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__UnableToGetMessagesFaultType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((ns4__BaseFaultType*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	size_t soap_flag_FaultCause2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "ns4:Timestamp", &a->ns4__BaseFaultType::Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons6__EndpointReferenceType(soap, "ns4:Originator", &a->ns4__BaseFaultType::Originator, "ns6:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns4__BaseFaultType_ErrorCode(soap, "ns4:ErrorCode", &a->ns4__BaseFaultType::ErrorCode, ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_ns4__BaseFaultType_Description(soap, "ns4:Description", &a->ns4__BaseFaultType::Description, ""))
					continue;
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns4__BaseFaultType_FaultCause(soap, "ns4:FaultCause", &a->ns4__BaseFaultType::FaultCause, ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->ns4__BaseFaultType::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns3__UnableToGetMessagesFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__UnableToGetMessagesFaultType, SOAP_TYPE_ns3__UnableToGetMessagesFaultType, sizeof(ns3__UnableToGetMessagesFaultType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__UnableToGetMessagesFaultType * SOAP_FMAC2 soap_instantiate_ns3__UnableToGetMessagesFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__UnableToGetMessagesFaultType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__UnableToGetMessagesFaultType *p;
	size_t k = sizeof(ns3__UnableToGetMessagesFaultType);
	if (n < 0)
	{	p = SOAP_NEW(ns3__UnableToGetMessagesFaultType);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns3__UnableToGetMessagesFaultType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__UnableToGetMessagesFaultType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns3__UnableToGetMessagesFaultType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns3__UnableToGetMessagesFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__UnableToGetMessagesFaultType(soap, tag ? tag : "ns3:UnableToGetMessagesFaultType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__UnableToGetMessagesFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__UnableToGetMessagesFaultType(soap, this, tag, type);
}

SOAP_FMAC3 ns3__UnableToGetMessagesFaultType * SOAP_FMAC4 soap_get_ns3__UnableToGetMessagesFaultType(struct soap *soap, ns3__UnableToGetMessagesFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__UnableToGetMessagesFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__NoCurrentMessageOnTopicFaultType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns4__BaseFaultType::soap_default(soap);
}

void ns3__NoCurrentMessageOnTopicFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->ns4__BaseFaultType::soap_serialize(soap);
#endif
}

int ns3__NoCurrentMessageOnTopicFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__NoCurrentMessageOnTopicFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__NoCurrentMessageOnTopicFaultType(struct soap *soap, const char *tag, int id, const ns3__NoCurrentMessageOnTopicFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((ns4__BaseFaultType*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__NoCurrentMessageOnTopicFaultType), type ? type : "ns3:NoCurrentMessageOnTopicFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->ns4__BaseFaultType::__any, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "ns4:Timestamp", -1, &a->ns4__BaseFaultType::Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTons6__EndpointReferenceType(soap, "ns4:Originator", -1, &a->ns4__BaseFaultType::Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_ns4__BaseFaultType_ErrorCode(soap, "ns4:ErrorCode", -1, &a->ns4__BaseFaultType::ErrorCode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_ns4__BaseFaultType_Description(soap, "ns4:Description", -1, &a->ns4__BaseFaultType::Description, ""))
		return soap->error;
	if (soap_out_PointerTo_ns4__BaseFaultType_FaultCause(soap, "ns4:FaultCause", -1, &a->ns4__BaseFaultType::FaultCause, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__NoCurrentMessageOnTopicFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__NoCurrentMessageOnTopicFaultType(soap, tag, this, type);
}

SOAP_FMAC3 ns3__NoCurrentMessageOnTopicFaultType * SOAP_FMAC4 soap_in_ns3__NoCurrentMessageOnTopicFaultType(struct soap *soap, const char *tag, ns3__NoCurrentMessageOnTopicFaultType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__NoCurrentMessageOnTopicFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__NoCurrentMessageOnTopicFaultType, sizeof(ns3__NoCurrentMessageOnTopicFaultType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns3__NoCurrentMessageOnTopicFaultType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__NoCurrentMessageOnTopicFaultType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((ns4__BaseFaultType*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	size_t soap_flag_FaultCause2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "ns4:Timestamp", &a->ns4__BaseFaultType::Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons6__EndpointReferenceType(soap, "ns4:Originator", &a->ns4__BaseFaultType::Originator, "ns6:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns4__BaseFaultType_ErrorCode(soap, "ns4:ErrorCode", &a->ns4__BaseFaultType::ErrorCode, ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_ns4__BaseFaultType_Description(soap, "ns4:Description", &a->ns4__BaseFaultType::Description, ""))
					continue;
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns4__BaseFaultType_FaultCause(soap, "ns4:FaultCause", &a->ns4__BaseFaultType::FaultCause, ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->ns4__BaseFaultType::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns3__NoCurrentMessageOnTopicFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__NoCurrentMessageOnTopicFaultType, SOAP_TYPE_ns3__NoCurrentMessageOnTopicFaultType, sizeof(ns3__NoCurrentMessageOnTopicFaultType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__NoCurrentMessageOnTopicFaultType * SOAP_FMAC2 soap_instantiate_ns3__NoCurrentMessageOnTopicFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__NoCurrentMessageOnTopicFaultType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__NoCurrentMessageOnTopicFaultType *p;
	size_t k = sizeof(ns3__NoCurrentMessageOnTopicFaultType);
	if (n < 0)
	{	p = SOAP_NEW(ns3__NoCurrentMessageOnTopicFaultType);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns3__NoCurrentMessageOnTopicFaultType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__NoCurrentMessageOnTopicFaultType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns3__NoCurrentMessageOnTopicFaultType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns3__NoCurrentMessageOnTopicFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__NoCurrentMessageOnTopicFaultType(soap, tag ? tag : "ns3:NoCurrentMessageOnTopicFaultType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__NoCurrentMessageOnTopicFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__NoCurrentMessageOnTopicFaultType(soap, this, tag, type);
}

SOAP_FMAC3 ns3__NoCurrentMessageOnTopicFaultType * SOAP_FMAC4 soap_get_ns3__NoCurrentMessageOnTopicFaultType(struct soap *soap, ns3__NoCurrentMessageOnTopicFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__NoCurrentMessageOnTopicFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__UnacceptableInitialTerminationTimeFaultType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns4__BaseFaultType::soap_default(soap);
	soap_default_dateTime(soap, &this->ns3__UnacceptableInitialTerminationTimeFaultType::MinimumTime);
	this->ns3__UnacceptableInitialTerminationTimeFaultType::MaximumTime = NULL;
}

void ns3__UnacceptableInitialTerminationTimeFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns3__UnacceptableInitialTerminationTimeFaultType::MinimumTime, SOAP_TYPE_dateTime);
	soap_serialize_PointerTodateTime(soap, &this->ns3__UnacceptableInitialTerminationTimeFaultType::MaximumTime);
	this->ns4__BaseFaultType::soap_serialize(soap);
#endif
}

int ns3__UnacceptableInitialTerminationTimeFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__UnacceptableInitialTerminationTimeFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__UnacceptableInitialTerminationTimeFaultType(struct soap *soap, const char *tag, int id, const ns3__UnacceptableInitialTerminationTimeFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((ns4__BaseFaultType*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__UnacceptableInitialTerminationTimeFaultType), type ? type : "ns3:UnacceptableInitialTerminationTimeFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->ns4__BaseFaultType::__any, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "ns4:Timestamp", -1, &a->ns4__BaseFaultType::Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTons6__EndpointReferenceType(soap, "ns4:Originator", -1, &a->ns4__BaseFaultType::Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_ns4__BaseFaultType_ErrorCode(soap, "ns4:ErrorCode", -1, &a->ns4__BaseFaultType::ErrorCode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_ns4__BaseFaultType_Description(soap, "ns4:Description", -1, &a->ns4__BaseFaultType::Description, ""))
		return soap->error;
	if (soap_out_PointerTo_ns4__BaseFaultType_FaultCause(soap, "ns4:FaultCause", -1, &a->ns4__BaseFaultType::FaultCause, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "ns3:MinimumTime", -1, &a->ns3__UnacceptableInitialTerminationTimeFaultType::MinimumTime, ""))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "ns3:MaximumTime", -1, &a->ns3__UnacceptableInitialTerminationTimeFaultType::MaximumTime, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__UnacceptableInitialTerminationTimeFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__UnacceptableInitialTerminationTimeFaultType(soap, tag, this, type);
}

SOAP_FMAC3 ns3__UnacceptableInitialTerminationTimeFaultType * SOAP_FMAC4 soap_in_ns3__UnacceptableInitialTerminationTimeFaultType(struct soap *soap, const char *tag, ns3__UnacceptableInitialTerminationTimeFaultType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__UnacceptableInitialTerminationTimeFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__UnacceptableInitialTerminationTimeFaultType, sizeof(ns3__UnacceptableInitialTerminationTimeFaultType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns3__UnacceptableInitialTerminationTimeFaultType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__UnacceptableInitialTerminationTimeFaultType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((ns4__BaseFaultType*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	size_t soap_flag_FaultCause2 = 1;
	size_t soap_flag_MinimumTime1 = 1;
	size_t soap_flag_MaximumTime1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "ns4:Timestamp", &a->ns4__BaseFaultType::Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons6__EndpointReferenceType(soap, "ns4:Originator", &a->ns4__BaseFaultType::Originator, "ns6:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns4__BaseFaultType_ErrorCode(soap, "ns4:ErrorCode", &a->ns4__BaseFaultType::ErrorCode, ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_ns4__BaseFaultType_Description(soap, "ns4:Description", &a->ns4__BaseFaultType::Description, ""))
					continue;
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns4__BaseFaultType_FaultCause(soap, "ns4:FaultCause", &a->ns4__BaseFaultType::FaultCause, ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			}
			if (soap_flag_MinimumTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "ns3:MinimumTime", &a->ns3__UnacceptableInitialTerminationTimeFaultType::MinimumTime, "xsd:dateTime"))
				{	soap_flag_MinimumTime1--;
					continue;
				}
			}
			if (soap_flag_MaximumTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "ns3:MaximumTime", &a->ns3__UnacceptableInitialTerminationTimeFaultType::MaximumTime, "xsd:dateTime"))
				{	soap_flag_MaximumTime1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->ns4__BaseFaultType::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0 || soap_flag_MinimumTime1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns3__UnacceptableInitialTerminationTimeFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__UnacceptableInitialTerminationTimeFaultType, SOAP_TYPE_ns3__UnacceptableInitialTerminationTimeFaultType, sizeof(ns3__UnacceptableInitialTerminationTimeFaultType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__UnacceptableInitialTerminationTimeFaultType * SOAP_FMAC2 soap_instantiate_ns3__UnacceptableInitialTerminationTimeFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__UnacceptableInitialTerminationTimeFaultType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__UnacceptableInitialTerminationTimeFaultType *p;
	size_t k = sizeof(ns3__UnacceptableInitialTerminationTimeFaultType);
	if (n < 0)
	{	p = SOAP_NEW(ns3__UnacceptableInitialTerminationTimeFaultType);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns3__UnacceptableInitialTerminationTimeFaultType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__UnacceptableInitialTerminationTimeFaultType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns3__UnacceptableInitialTerminationTimeFaultType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns3__UnacceptableInitialTerminationTimeFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__UnacceptableInitialTerminationTimeFaultType(soap, tag ? tag : "ns3:UnacceptableInitialTerminationTimeFaultType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__UnacceptableInitialTerminationTimeFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__UnacceptableInitialTerminationTimeFaultType(soap, this, tag, type);
}

SOAP_FMAC3 ns3__UnacceptableInitialTerminationTimeFaultType * SOAP_FMAC4 soap_get_ns3__UnacceptableInitialTerminationTimeFaultType(struct soap *soap, ns3__UnacceptableInitialTerminationTimeFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__UnacceptableInitialTerminationTimeFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__NotifyMessageNotSupportedFaultType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns4__BaseFaultType::soap_default(soap);
}

void ns3__NotifyMessageNotSupportedFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->ns4__BaseFaultType::soap_serialize(soap);
#endif
}

int ns3__NotifyMessageNotSupportedFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__NotifyMessageNotSupportedFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__NotifyMessageNotSupportedFaultType(struct soap *soap, const char *tag, int id, const ns3__NotifyMessageNotSupportedFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((ns4__BaseFaultType*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__NotifyMessageNotSupportedFaultType), type ? type : "ns3:NotifyMessageNotSupportedFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->ns4__BaseFaultType::__any, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "ns4:Timestamp", -1, &a->ns4__BaseFaultType::Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTons6__EndpointReferenceType(soap, "ns4:Originator", -1, &a->ns4__BaseFaultType::Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_ns4__BaseFaultType_ErrorCode(soap, "ns4:ErrorCode", -1, &a->ns4__BaseFaultType::ErrorCode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_ns4__BaseFaultType_Description(soap, "ns4:Description", -1, &a->ns4__BaseFaultType::Description, ""))
		return soap->error;
	if (soap_out_PointerTo_ns4__BaseFaultType_FaultCause(soap, "ns4:FaultCause", -1, &a->ns4__BaseFaultType::FaultCause, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__NotifyMessageNotSupportedFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__NotifyMessageNotSupportedFaultType(soap, tag, this, type);
}

SOAP_FMAC3 ns3__NotifyMessageNotSupportedFaultType * SOAP_FMAC4 soap_in_ns3__NotifyMessageNotSupportedFaultType(struct soap *soap, const char *tag, ns3__NotifyMessageNotSupportedFaultType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__NotifyMessageNotSupportedFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__NotifyMessageNotSupportedFaultType, sizeof(ns3__NotifyMessageNotSupportedFaultType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns3__NotifyMessageNotSupportedFaultType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__NotifyMessageNotSupportedFaultType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((ns4__BaseFaultType*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	size_t soap_flag_FaultCause2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "ns4:Timestamp", &a->ns4__BaseFaultType::Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons6__EndpointReferenceType(soap, "ns4:Originator", &a->ns4__BaseFaultType::Originator, "ns6:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns4__BaseFaultType_ErrorCode(soap, "ns4:ErrorCode", &a->ns4__BaseFaultType::ErrorCode, ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_ns4__BaseFaultType_Description(soap, "ns4:Description", &a->ns4__BaseFaultType::Description, ""))
					continue;
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns4__BaseFaultType_FaultCause(soap, "ns4:FaultCause", &a->ns4__BaseFaultType::FaultCause, ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->ns4__BaseFaultType::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns3__NotifyMessageNotSupportedFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__NotifyMessageNotSupportedFaultType, SOAP_TYPE_ns3__NotifyMessageNotSupportedFaultType, sizeof(ns3__NotifyMessageNotSupportedFaultType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__NotifyMessageNotSupportedFaultType * SOAP_FMAC2 soap_instantiate_ns3__NotifyMessageNotSupportedFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__NotifyMessageNotSupportedFaultType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__NotifyMessageNotSupportedFaultType *p;
	size_t k = sizeof(ns3__NotifyMessageNotSupportedFaultType);
	if (n < 0)
	{	p = SOAP_NEW(ns3__NotifyMessageNotSupportedFaultType);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns3__NotifyMessageNotSupportedFaultType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__NotifyMessageNotSupportedFaultType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns3__NotifyMessageNotSupportedFaultType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns3__NotifyMessageNotSupportedFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__NotifyMessageNotSupportedFaultType(soap, tag ? tag : "ns3:NotifyMessageNotSupportedFaultType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__NotifyMessageNotSupportedFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__NotifyMessageNotSupportedFaultType(soap, this, tag, type);
}

SOAP_FMAC3 ns3__NotifyMessageNotSupportedFaultType * SOAP_FMAC4 soap_get_ns3__NotifyMessageNotSupportedFaultType(struct soap *soap, ns3__NotifyMessageNotSupportedFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__NotifyMessageNotSupportedFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__UnsupportedPolicyRequestFaultType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns4__BaseFaultType::soap_default(soap);
	soap_default_std__vectorTemplateOfxsd__QName(soap, &this->ns3__UnsupportedPolicyRequestFaultType::UnsupportedPolicy);
}

void ns3__UnsupportedPolicyRequestFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__QName(soap, &this->ns3__UnsupportedPolicyRequestFaultType::UnsupportedPolicy);
	this->ns4__BaseFaultType::soap_serialize(soap);
#endif
}

int ns3__UnsupportedPolicyRequestFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__UnsupportedPolicyRequestFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__UnsupportedPolicyRequestFaultType(struct soap *soap, const char *tag, int id, const ns3__UnsupportedPolicyRequestFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((ns4__BaseFaultType*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__UnsupportedPolicyRequestFaultType), type ? type : "ns3:UnsupportedPolicyRequestFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->ns4__BaseFaultType::__any, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "ns4:Timestamp", -1, &a->ns4__BaseFaultType::Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTons6__EndpointReferenceType(soap, "ns4:Originator", -1, &a->ns4__BaseFaultType::Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_ns4__BaseFaultType_ErrorCode(soap, "ns4:ErrorCode", -1, &a->ns4__BaseFaultType::ErrorCode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_ns4__BaseFaultType_Description(soap, "ns4:Description", -1, &a->ns4__BaseFaultType::Description, ""))
		return soap->error;
	if (soap_out_PointerTo_ns4__BaseFaultType_FaultCause(soap, "ns4:FaultCause", -1, &a->ns4__BaseFaultType::FaultCause, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__QName(soap, "ns3:UnsupportedPolicy", -1, &a->ns3__UnsupportedPolicyRequestFaultType::UnsupportedPolicy, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__UnsupportedPolicyRequestFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__UnsupportedPolicyRequestFaultType(soap, tag, this, type);
}

SOAP_FMAC3 ns3__UnsupportedPolicyRequestFaultType * SOAP_FMAC4 soap_in_ns3__UnsupportedPolicyRequestFaultType(struct soap *soap, const char *tag, ns3__UnsupportedPolicyRequestFaultType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__UnsupportedPolicyRequestFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__UnsupportedPolicyRequestFaultType, sizeof(ns3__UnsupportedPolicyRequestFaultType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns3__UnsupportedPolicyRequestFaultType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__UnsupportedPolicyRequestFaultType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((ns4__BaseFaultType*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	size_t soap_flag_FaultCause2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "ns4:Timestamp", &a->ns4__BaseFaultType::Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons6__EndpointReferenceType(soap, "ns4:Originator", &a->ns4__BaseFaultType::Originator, "ns6:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns4__BaseFaultType_ErrorCode(soap, "ns4:ErrorCode", &a->ns4__BaseFaultType::ErrorCode, ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_ns4__BaseFaultType_Description(soap, "ns4:Description", &a->ns4__BaseFaultType::Description, ""))
					continue;
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns4__BaseFaultType_FaultCause(soap, "ns4:FaultCause", &a->ns4__BaseFaultType::FaultCause, ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__QName(soap, "ns3:UnsupportedPolicy", &a->ns3__UnsupportedPolicyRequestFaultType::UnsupportedPolicy, "xsd:QName"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->ns4__BaseFaultType::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns3__UnsupportedPolicyRequestFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__UnsupportedPolicyRequestFaultType, SOAP_TYPE_ns3__UnsupportedPolicyRequestFaultType, sizeof(ns3__UnsupportedPolicyRequestFaultType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__UnsupportedPolicyRequestFaultType * SOAP_FMAC2 soap_instantiate_ns3__UnsupportedPolicyRequestFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__UnsupportedPolicyRequestFaultType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__UnsupportedPolicyRequestFaultType *p;
	size_t k = sizeof(ns3__UnsupportedPolicyRequestFaultType);
	if (n < 0)
	{	p = SOAP_NEW(ns3__UnsupportedPolicyRequestFaultType);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns3__UnsupportedPolicyRequestFaultType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__UnsupportedPolicyRequestFaultType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns3__UnsupportedPolicyRequestFaultType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns3__UnsupportedPolicyRequestFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__UnsupportedPolicyRequestFaultType(soap, tag ? tag : "ns3:UnsupportedPolicyRequestFaultType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__UnsupportedPolicyRequestFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__UnsupportedPolicyRequestFaultType(soap, this, tag, type);
}

SOAP_FMAC3 ns3__UnsupportedPolicyRequestFaultType * SOAP_FMAC4 soap_get_ns3__UnsupportedPolicyRequestFaultType(struct soap *soap, ns3__UnsupportedPolicyRequestFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__UnsupportedPolicyRequestFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__UnrecognizedPolicyRequestFaultType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns4__BaseFaultType::soap_default(soap);
	soap_default_std__vectorTemplateOfxsd__QName(soap, &this->ns3__UnrecognizedPolicyRequestFaultType::UnrecognizedPolicy);
}

void ns3__UnrecognizedPolicyRequestFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__QName(soap, &this->ns3__UnrecognizedPolicyRequestFaultType::UnrecognizedPolicy);
	this->ns4__BaseFaultType::soap_serialize(soap);
#endif
}

int ns3__UnrecognizedPolicyRequestFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__UnrecognizedPolicyRequestFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__UnrecognizedPolicyRequestFaultType(struct soap *soap, const char *tag, int id, const ns3__UnrecognizedPolicyRequestFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((ns4__BaseFaultType*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__UnrecognizedPolicyRequestFaultType), type ? type : "ns3:UnrecognizedPolicyRequestFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->ns4__BaseFaultType::__any, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "ns4:Timestamp", -1, &a->ns4__BaseFaultType::Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTons6__EndpointReferenceType(soap, "ns4:Originator", -1, &a->ns4__BaseFaultType::Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_ns4__BaseFaultType_ErrorCode(soap, "ns4:ErrorCode", -1, &a->ns4__BaseFaultType::ErrorCode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_ns4__BaseFaultType_Description(soap, "ns4:Description", -1, &a->ns4__BaseFaultType::Description, ""))
		return soap->error;
	if (soap_out_PointerTo_ns4__BaseFaultType_FaultCause(soap, "ns4:FaultCause", -1, &a->ns4__BaseFaultType::FaultCause, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__QName(soap, "ns3:UnrecognizedPolicy", -1, &a->ns3__UnrecognizedPolicyRequestFaultType::UnrecognizedPolicy, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__UnrecognizedPolicyRequestFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__UnrecognizedPolicyRequestFaultType(soap, tag, this, type);
}

SOAP_FMAC3 ns3__UnrecognizedPolicyRequestFaultType * SOAP_FMAC4 soap_in_ns3__UnrecognizedPolicyRequestFaultType(struct soap *soap, const char *tag, ns3__UnrecognizedPolicyRequestFaultType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__UnrecognizedPolicyRequestFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__UnrecognizedPolicyRequestFaultType, sizeof(ns3__UnrecognizedPolicyRequestFaultType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns3__UnrecognizedPolicyRequestFaultType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__UnrecognizedPolicyRequestFaultType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((ns4__BaseFaultType*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	size_t soap_flag_FaultCause2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "ns4:Timestamp", &a->ns4__BaseFaultType::Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons6__EndpointReferenceType(soap, "ns4:Originator", &a->ns4__BaseFaultType::Originator, "ns6:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns4__BaseFaultType_ErrorCode(soap, "ns4:ErrorCode", &a->ns4__BaseFaultType::ErrorCode, ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_ns4__BaseFaultType_Description(soap, "ns4:Description", &a->ns4__BaseFaultType::Description, ""))
					continue;
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns4__BaseFaultType_FaultCause(soap, "ns4:FaultCause", &a->ns4__BaseFaultType::FaultCause, ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__QName(soap, "ns3:UnrecognizedPolicy", &a->ns3__UnrecognizedPolicyRequestFaultType::UnrecognizedPolicy, "xsd:QName"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->ns4__BaseFaultType::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns3__UnrecognizedPolicyRequestFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__UnrecognizedPolicyRequestFaultType, SOAP_TYPE_ns3__UnrecognizedPolicyRequestFaultType, sizeof(ns3__UnrecognizedPolicyRequestFaultType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__UnrecognizedPolicyRequestFaultType * SOAP_FMAC2 soap_instantiate_ns3__UnrecognizedPolicyRequestFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__UnrecognizedPolicyRequestFaultType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__UnrecognizedPolicyRequestFaultType *p;
	size_t k = sizeof(ns3__UnrecognizedPolicyRequestFaultType);
	if (n < 0)
	{	p = SOAP_NEW(ns3__UnrecognizedPolicyRequestFaultType);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns3__UnrecognizedPolicyRequestFaultType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__UnrecognizedPolicyRequestFaultType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns3__UnrecognizedPolicyRequestFaultType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns3__UnrecognizedPolicyRequestFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__UnrecognizedPolicyRequestFaultType(soap, tag ? tag : "ns3:UnrecognizedPolicyRequestFaultType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__UnrecognizedPolicyRequestFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__UnrecognizedPolicyRequestFaultType(soap, this, tag, type);
}

SOAP_FMAC3 ns3__UnrecognizedPolicyRequestFaultType * SOAP_FMAC4 soap_get_ns3__UnrecognizedPolicyRequestFaultType(struct soap *soap, ns3__UnrecognizedPolicyRequestFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__UnrecognizedPolicyRequestFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__InvalidMessageContentExpressionFaultType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns4__BaseFaultType::soap_default(soap);
}

void ns3__InvalidMessageContentExpressionFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->ns4__BaseFaultType::soap_serialize(soap);
#endif
}

int ns3__InvalidMessageContentExpressionFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__InvalidMessageContentExpressionFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__InvalidMessageContentExpressionFaultType(struct soap *soap, const char *tag, int id, const ns3__InvalidMessageContentExpressionFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((ns4__BaseFaultType*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__InvalidMessageContentExpressionFaultType), type ? type : "ns3:InvalidMessageContentExpressionFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->ns4__BaseFaultType::__any, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "ns4:Timestamp", -1, &a->ns4__BaseFaultType::Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTons6__EndpointReferenceType(soap, "ns4:Originator", -1, &a->ns4__BaseFaultType::Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_ns4__BaseFaultType_ErrorCode(soap, "ns4:ErrorCode", -1, &a->ns4__BaseFaultType::ErrorCode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_ns4__BaseFaultType_Description(soap, "ns4:Description", -1, &a->ns4__BaseFaultType::Description, ""))
		return soap->error;
	if (soap_out_PointerTo_ns4__BaseFaultType_FaultCause(soap, "ns4:FaultCause", -1, &a->ns4__BaseFaultType::FaultCause, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__InvalidMessageContentExpressionFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__InvalidMessageContentExpressionFaultType(soap, tag, this, type);
}

SOAP_FMAC3 ns3__InvalidMessageContentExpressionFaultType * SOAP_FMAC4 soap_in_ns3__InvalidMessageContentExpressionFaultType(struct soap *soap, const char *tag, ns3__InvalidMessageContentExpressionFaultType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__InvalidMessageContentExpressionFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__InvalidMessageContentExpressionFaultType, sizeof(ns3__InvalidMessageContentExpressionFaultType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns3__InvalidMessageContentExpressionFaultType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__InvalidMessageContentExpressionFaultType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((ns4__BaseFaultType*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	size_t soap_flag_FaultCause2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "ns4:Timestamp", &a->ns4__BaseFaultType::Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons6__EndpointReferenceType(soap, "ns4:Originator", &a->ns4__BaseFaultType::Originator, "ns6:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns4__BaseFaultType_ErrorCode(soap, "ns4:ErrorCode", &a->ns4__BaseFaultType::ErrorCode, ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_ns4__BaseFaultType_Description(soap, "ns4:Description", &a->ns4__BaseFaultType::Description, ""))
					continue;
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns4__BaseFaultType_FaultCause(soap, "ns4:FaultCause", &a->ns4__BaseFaultType::FaultCause, ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->ns4__BaseFaultType::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns3__InvalidMessageContentExpressionFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__InvalidMessageContentExpressionFaultType, SOAP_TYPE_ns3__InvalidMessageContentExpressionFaultType, sizeof(ns3__InvalidMessageContentExpressionFaultType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__InvalidMessageContentExpressionFaultType * SOAP_FMAC2 soap_instantiate_ns3__InvalidMessageContentExpressionFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__InvalidMessageContentExpressionFaultType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__InvalidMessageContentExpressionFaultType *p;
	size_t k = sizeof(ns3__InvalidMessageContentExpressionFaultType);
	if (n < 0)
	{	p = SOAP_NEW(ns3__InvalidMessageContentExpressionFaultType);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns3__InvalidMessageContentExpressionFaultType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__InvalidMessageContentExpressionFaultType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns3__InvalidMessageContentExpressionFaultType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns3__InvalidMessageContentExpressionFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__InvalidMessageContentExpressionFaultType(soap, tag ? tag : "ns3:InvalidMessageContentExpressionFaultType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__InvalidMessageContentExpressionFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__InvalidMessageContentExpressionFaultType(soap, this, tag, type);
}

SOAP_FMAC3 ns3__InvalidMessageContentExpressionFaultType * SOAP_FMAC4 soap_get_ns3__InvalidMessageContentExpressionFaultType(struct soap *soap, ns3__InvalidMessageContentExpressionFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__InvalidMessageContentExpressionFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__InvalidProducerPropertiesExpressionFaultType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns4__BaseFaultType::soap_default(soap);
}

void ns3__InvalidProducerPropertiesExpressionFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->ns4__BaseFaultType::soap_serialize(soap);
#endif
}

int ns3__InvalidProducerPropertiesExpressionFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__InvalidProducerPropertiesExpressionFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__InvalidProducerPropertiesExpressionFaultType(struct soap *soap, const char *tag, int id, const ns3__InvalidProducerPropertiesExpressionFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((ns4__BaseFaultType*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__InvalidProducerPropertiesExpressionFaultType), type ? type : "ns3:InvalidProducerPropertiesExpressionFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->ns4__BaseFaultType::__any, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "ns4:Timestamp", -1, &a->ns4__BaseFaultType::Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTons6__EndpointReferenceType(soap, "ns4:Originator", -1, &a->ns4__BaseFaultType::Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_ns4__BaseFaultType_ErrorCode(soap, "ns4:ErrorCode", -1, &a->ns4__BaseFaultType::ErrorCode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_ns4__BaseFaultType_Description(soap, "ns4:Description", -1, &a->ns4__BaseFaultType::Description, ""))
		return soap->error;
	if (soap_out_PointerTo_ns4__BaseFaultType_FaultCause(soap, "ns4:FaultCause", -1, &a->ns4__BaseFaultType::FaultCause, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__InvalidProducerPropertiesExpressionFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__InvalidProducerPropertiesExpressionFaultType(soap, tag, this, type);
}

SOAP_FMAC3 ns3__InvalidProducerPropertiesExpressionFaultType * SOAP_FMAC4 soap_in_ns3__InvalidProducerPropertiesExpressionFaultType(struct soap *soap, const char *tag, ns3__InvalidProducerPropertiesExpressionFaultType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__InvalidProducerPropertiesExpressionFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__InvalidProducerPropertiesExpressionFaultType, sizeof(ns3__InvalidProducerPropertiesExpressionFaultType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns3__InvalidProducerPropertiesExpressionFaultType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__InvalidProducerPropertiesExpressionFaultType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((ns4__BaseFaultType*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	size_t soap_flag_FaultCause2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "ns4:Timestamp", &a->ns4__BaseFaultType::Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons6__EndpointReferenceType(soap, "ns4:Originator", &a->ns4__BaseFaultType::Originator, "ns6:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns4__BaseFaultType_ErrorCode(soap, "ns4:ErrorCode", &a->ns4__BaseFaultType::ErrorCode, ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_ns4__BaseFaultType_Description(soap, "ns4:Description", &a->ns4__BaseFaultType::Description, ""))
					continue;
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns4__BaseFaultType_FaultCause(soap, "ns4:FaultCause", &a->ns4__BaseFaultType::FaultCause, ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->ns4__BaseFaultType::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns3__InvalidProducerPropertiesExpressionFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__InvalidProducerPropertiesExpressionFaultType, SOAP_TYPE_ns3__InvalidProducerPropertiesExpressionFaultType, sizeof(ns3__InvalidProducerPropertiesExpressionFaultType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__InvalidProducerPropertiesExpressionFaultType * SOAP_FMAC2 soap_instantiate_ns3__InvalidProducerPropertiesExpressionFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__InvalidProducerPropertiesExpressionFaultType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__InvalidProducerPropertiesExpressionFaultType *p;
	size_t k = sizeof(ns3__InvalidProducerPropertiesExpressionFaultType);
	if (n < 0)
	{	p = SOAP_NEW(ns3__InvalidProducerPropertiesExpressionFaultType);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns3__InvalidProducerPropertiesExpressionFaultType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__InvalidProducerPropertiesExpressionFaultType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns3__InvalidProducerPropertiesExpressionFaultType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns3__InvalidProducerPropertiesExpressionFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__InvalidProducerPropertiesExpressionFaultType(soap, tag ? tag : "ns3:InvalidProducerPropertiesExpressionFaultType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__InvalidProducerPropertiesExpressionFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__InvalidProducerPropertiesExpressionFaultType(soap, this, tag, type);
}

SOAP_FMAC3 ns3__InvalidProducerPropertiesExpressionFaultType * SOAP_FMAC4 soap_get_ns3__InvalidProducerPropertiesExpressionFaultType(struct soap *soap, ns3__InvalidProducerPropertiesExpressionFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__InvalidProducerPropertiesExpressionFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__MultipleTopicsSpecifiedFaultType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns4__BaseFaultType::soap_default(soap);
}

void ns3__MultipleTopicsSpecifiedFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->ns4__BaseFaultType::soap_serialize(soap);
#endif
}

int ns3__MultipleTopicsSpecifiedFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__MultipleTopicsSpecifiedFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__MultipleTopicsSpecifiedFaultType(struct soap *soap, const char *tag, int id, const ns3__MultipleTopicsSpecifiedFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((ns4__BaseFaultType*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__MultipleTopicsSpecifiedFaultType), type ? type : "ns3:MultipleTopicsSpecifiedFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->ns4__BaseFaultType::__any, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "ns4:Timestamp", -1, &a->ns4__BaseFaultType::Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTons6__EndpointReferenceType(soap, "ns4:Originator", -1, &a->ns4__BaseFaultType::Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_ns4__BaseFaultType_ErrorCode(soap, "ns4:ErrorCode", -1, &a->ns4__BaseFaultType::ErrorCode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_ns4__BaseFaultType_Description(soap, "ns4:Description", -1, &a->ns4__BaseFaultType::Description, ""))
		return soap->error;
	if (soap_out_PointerTo_ns4__BaseFaultType_FaultCause(soap, "ns4:FaultCause", -1, &a->ns4__BaseFaultType::FaultCause, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__MultipleTopicsSpecifiedFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__MultipleTopicsSpecifiedFaultType(soap, tag, this, type);
}

SOAP_FMAC3 ns3__MultipleTopicsSpecifiedFaultType * SOAP_FMAC4 soap_in_ns3__MultipleTopicsSpecifiedFaultType(struct soap *soap, const char *tag, ns3__MultipleTopicsSpecifiedFaultType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__MultipleTopicsSpecifiedFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__MultipleTopicsSpecifiedFaultType, sizeof(ns3__MultipleTopicsSpecifiedFaultType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns3__MultipleTopicsSpecifiedFaultType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__MultipleTopicsSpecifiedFaultType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((ns4__BaseFaultType*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	size_t soap_flag_FaultCause2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "ns4:Timestamp", &a->ns4__BaseFaultType::Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons6__EndpointReferenceType(soap, "ns4:Originator", &a->ns4__BaseFaultType::Originator, "ns6:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns4__BaseFaultType_ErrorCode(soap, "ns4:ErrorCode", &a->ns4__BaseFaultType::ErrorCode, ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_ns4__BaseFaultType_Description(soap, "ns4:Description", &a->ns4__BaseFaultType::Description, ""))
					continue;
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns4__BaseFaultType_FaultCause(soap, "ns4:FaultCause", &a->ns4__BaseFaultType::FaultCause, ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->ns4__BaseFaultType::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns3__MultipleTopicsSpecifiedFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__MultipleTopicsSpecifiedFaultType, SOAP_TYPE_ns3__MultipleTopicsSpecifiedFaultType, sizeof(ns3__MultipleTopicsSpecifiedFaultType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__MultipleTopicsSpecifiedFaultType * SOAP_FMAC2 soap_instantiate_ns3__MultipleTopicsSpecifiedFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__MultipleTopicsSpecifiedFaultType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__MultipleTopicsSpecifiedFaultType *p;
	size_t k = sizeof(ns3__MultipleTopicsSpecifiedFaultType);
	if (n < 0)
	{	p = SOAP_NEW(ns3__MultipleTopicsSpecifiedFaultType);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns3__MultipleTopicsSpecifiedFaultType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__MultipleTopicsSpecifiedFaultType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns3__MultipleTopicsSpecifiedFaultType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns3__MultipleTopicsSpecifiedFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__MultipleTopicsSpecifiedFaultType(soap, tag ? tag : "ns3:MultipleTopicsSpecifiedFaultType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__MultipleTopicsSpecifiedFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__MultipleTopicsSpecifiedFaultType(soap, this, tag, type);
}

SOAP_FMAC3 ns3__MultipleTopicsSpecifiedFaultType * SOAP_FMAC4 soap_get_ns3__MultipleTopicsSpecifiedFaultType(struct soap *soap, ns3__MultipleTopicsSpecifiedFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__MultipleTopicsSpecifiedFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__TopicNotSupportedFaultType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns4__BaseFaultType::soap_default(soap);
}

void ns3__TopicNotSupportedFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->ns4__BaseFaultType::soap_serialize(soap);
#endif
}

int ns3__TopicNotSupportedFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__TopicNotSupportedFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__TopicNotSupportedFaultType(struct soap *soap, const char *tag, int id, const ns3__TopicNotSupportedFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((ns4__BaseFaultType*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__TopicNotSupportedFaultType), type ? type : "ns3:TopicNotSupportedFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->ns4__BaseFaultType::__any, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "ns4:Timestamp", -1, &a->ns4__BaseFaultType::Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTons6__EndpointReferenceType(soap, "ns4:Originator", -1, &a->ns4__BaseFaultType::Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_ns4__BaseFaultType_ErrorCode(soap, "ns4:ErrorCode", -1, &a->ns4__BaseFaultType::ErrorCode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_ns4__BaseFaultType_Description(soap, "ns4:Description", -1, &a->ns4__BaseFaultType::Description, ""))
		return soap->error;
	if (soap_out_PointerTo_ns4__BaseFaultType_FaultCause(soap, "ns4:FaultCause", -1, &a->ns4__BaseFaultType::FaultCause, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__TopicNotSupportedFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__TopicNotSupportedFaultType(soap, tag, this, type);
}

SOAP_FMAC3 ns3__TopicNotSupportedFaultType * SOAP_FMAC4 soap_in_ns3__TopicNotSupportedFaultType(struct soap *soap, const char *tag, ns3__TopicNotSupportedFaultType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__TopicNotSupportedFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__TopicNotSupportedFaultType, sizeof(ns3__TopicNotSupportedFaultType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns3__TopicNotSupportedFaultType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__TopicNotSupportedFaultType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((ns4__BaseFaultType*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	size_t soap_flag_FaultCause2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "ns4:Timestamp", &a->ns4__BaseFaultType::Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons6__EndpointReferenceType(soap, "ns4:Originator", &a->ns4__BaseFaultType::Originator, "ns6:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns4__BaseFaultType_ErrorCode(soap, "ns4:ErrorCode", &a->ns4__BaseFaultType::ErrorCode, ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_ns4__BaseFaultType_Description(soap, "ns4:Description", &a->ns4__BaseFaultType::Description, ""))
					continue;
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns4__BaseFaultType_FaultCause(soap, "ns4:FaultCause", &a->ns4__BaseFaultType::FaultCause, ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->ns4__BaseFaultType::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns3__TopicNotSupportedFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__TopicNotSupportedFaultType, SOAP_TYPE_ns3__TopicNotSupportedFaultType, sizeof(ns3__TopicNotSupportedFaultType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__TopicNotSupportedFaultType * SOAP_FMAC2 soap_instantiate_ns3__TopicNotSupportedFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__TopicNotSupportedFaultType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__TopicNotSupportedFaultType *p;
	size_t k = sizeof(ns3__TopicNotSupportedFaultType);
	if (n < 0)
	{	p = SOAP_NEW(ns3__TopicNotSupportedFaultType);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns3__TopicNotSupportedFaultType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__TopicNotSupportedFaultType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns3__TopicNotSupportedFaultType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns3__TopicNotSupportedFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__TopicNotSupportedFaultType(soap, tag ? tag : "ns3:TopicNotSupportedFaultType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__TopicNotSupportedFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__TopicNotSupportedFaultType(soap, this, tag, type);
}

SOAP_FMAC3 ns3__TopicNotSupportedFaultType * SOAP_FMAC4 soap_get_ns3__TopicNotSupportedFaultType(struct soap *soap, ns3__TopicNotSupportedFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__TopicNotSupportedFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__InvalidTopicExpressionFaultType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns4__BaseFaultType::soap_default(soap);
}

void ns3__InvalidTopicExpressionFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->ns4__BaseFaultType::soap_serialize(soap);
#endif
}

int ns3__InvalidTopicExpressionFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__InvalidTopicExpressionFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__InvalidTopicExpressionFaultType(struct soap *soap, const char *tag, int id, const ns3__InvalidTopicExpressionFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((ns4__BaseFaultType*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__InvalidTopicExpressionFaultType), type ? type : "ns3:InvalidTopicExpressionFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->ns4__BaseFaultType::__any, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "ns4:Timestamp", -1, &a->ns4__BaseFaultType::Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTons6__EndpointReferenceType(soap, "ns4:Originator", -1, &a->ns4__BaseFaultType::Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_ns4__BaseFaultType_ErrorCode(soap, "ns4:ErrorCode", -1, &a->ns4__BaseFaultType::ErrorCode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_ns4__BaseFaultType_Description(soap, "ns4:Description", -1, &a->ns4__BaseFaultType::Description, ""))
		return soap->error;
	if (soap_out_PointerTo_ns4__BaseFaultType_FaultCause(soap, "ns4:FaultCause", -1, &a->ns4__BaseFaultType::FaultCause, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__InvalidTopicExpressionFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__InvalidTopicExpressionFaultType(soap, tag, this, type);
}

SOAP_FMAC3 ns3__InvalidTopicExpressionFaultType * SOAP_FMAC4 soap_in_ns3__InvalidTopicExpressionFaultType(struct soap *soap, const char *tag, ns3__InvalidTopicExpressionFaultType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__InvalidTopicExpressionFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__InvalidTopicExpressionFaultType, sizeof(ns3__InvalidTopicExpressionFaultType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns3__InvalidTopicExpressionFaultType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__InvalidTopicExpressionFaultType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((ns4__BaseFaultType*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	size_t soap_flag_FaultCause2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "ns4:Timestamp", &a->ns4__BaseFaultType::Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons6__EndpointReferenceType(soap, "ns4:Originator", &a->ns4__BaseFaultType::Originator, "ns6:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns4__BaseFaultType_ErrorCode(soap, "ns4:ErrorCode", &a->ns4__BaseFaultType::ErrorCode, ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_ns4__BaseFaultType_Description(soap, "ns4:Description", &a->ns4__BaseFaultType::Description, ""))
					continue;
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns4__BaseFaultType_FaultCause(soap, "ns4:FaultCause", &a->ns4__BaseFaultType::FaultCause, ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->ns4__BaseFaultType::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns3__InvalidTopicExpressionFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__InvalidTopicExpressionFaultType, SOAP_TYPE_ns3__InvalidTopicExpressionFaultType, sizeof(ns3__InvalidTopicExpressionFaultType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__InvalidTopicExpressionFaultType * SOAP_FMAC2 soap_instantiate_ns3__InvalidTopicExpressionFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__InvalidTopicExpressionFaultType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__InvalidTopicExpressionFaultType *p;
	size_t k = sizeof(ns3__InvalidTopicExpressionFaultType);
	if (n < 0)
	{	p = SOAP_NEW(ns3__InvalidTopicExpressionFaultType);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns3__InvalidTopicExpressionFaultType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__InvalidTopicExpressionFaultType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns3__InvalidTopicExpressionFaultType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns3__InvalidTopicExpressionFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__InvalidTopicExpressionFaultType(soap, tag ? tag : "ns3:InvalidTopicExpressionFaultType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__InvalidTopicExpressionFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__InvalidTopicExpressionFaultType(soap, this, tag, type);
}

SOAP_FMAC3 ns3__InvalidTopicExpressionFaultType * SOAP_FMAC4 soap_get_ns3__InvalidTopicExpressionFaultType(struct soap *soap, ns3__InvalidTopicExpressionFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__InvalidTopicExpressionFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__TopicExpressionDialectUnknownFaultType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns4__BaseFaultType::soap_default(soap);
}

void ns3__TopicExpressionDialectUnknownFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->ns4__BaseFaultType::soap_serialize(soap);
#endif
}

int ns3__TopicExpressionDialectUnknownFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__TopicExpressionDialectUnknownFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__TopicExpressionDialectUnknownFaultType(struct soap *soap, const char *tag, int id, const ns3__TopicExpressionDialectUnknownFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((ns4__BaseFaultType*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__TopicExpressionDialectUnknownFaultType), type ? type : "ns3:TopicExpressionDialectUnknownFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->ns4__BaseFaultType::__any, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "ns4:Timestamp", -1, &a->ns4__BaseFaultType::Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTons6__EndpointReferenceType(soap, "ns4:Originator", -1, &a->ns4__BaseFaultType::Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_ns4__BaseFaultType_ErrorCode(soap, "ns4:ErrorCode", -1, &a->ns4__BaseFaultType::ErrorCode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_ns4__BaseFaultType_Description(soap, "ns4:Description", -1, &a->ns4__BaseFaultType::Description, ""))
		return soap->error;
	if (soap_out_PointerTo_ns4__BaseFaultType_FaultCause(soap, "ns4:FaultCause", -1, &a->ns4__BaseFaultType::FaultCause, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__TopicExpressionDialectUnknownFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__TopicExpressionDialectUnknownFaultType(soap, tag, this, type);
}

SOAP_FMAC3 ns3__TopicExpressionDialectUnknownFaultType * SOAP_FMAC4 soap_in_ns3__TopicExpressionDialectUnknownFaultType(struct soap *soap, const char *tag, ns3__TopicExpressionDialectUnknownFaultType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__TopicExpressionDialectUnknownFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__TopicExpressionDialectUnknownFaultType, sizeof(ns3__TopicExpressionDialectUnknownFaultType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns3__TopicExpressionDialectUnknownFaultType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__TopicExpressionDialectUnknownFaultType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((ns4__BaseFaultType*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	size_t soap_flag_FaultCause2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "ns4:Timestamp", &a->ns4__BaseFaultType::Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons6__EndpointReferenceType(soap, "ns4:Originator", &a->ns4__BaseFaultType::Originator, "ns6:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns4__BaseFaultType_ErrorCode(soap, "ns4:ErrorCode", &a->ns4__BaseFaultType::ErrorCode, ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_ns4__BaseFaultType_Description(soap, "ns4:Description", &a->ns4__BaseFaultType::Description, ""))
					continue;
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns4__BaseFaultType_FaultCause(soap, "ns4:FaultCause", &a->ns4__BaseFaultType::FaultCause, ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->ns4__BaseFaultType::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns3__TopicExpressionDialectUnknownFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__TopicExpressionDialectUnknownFaultType, SOAP_TYPE_ns3__TopicExpressionDialectUnknownFaultType, sizeof(ns3__TopicExpressionDialectUnknownFaultType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__TopicExpressionDialectUnknownFaultType * SOAP_FMAC2 soap_instantiate_ns3__TopicExpressionDialectUnknownFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__TopicExpressionDialectUnknownFaultType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__TopicExpressionDialectUnknownFaultType *p;
	size_t k = sizeof(ns3__TopicExpressionDialectUnknownFaultType);
	if (n < 0)
	{	p = SOAP_NEW(ns3__TopicExpressionDialectUnknownFaultType);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns3__TopicExpressionDialectUnknownFaultType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__TopicExpressionDialectUnknownFaultType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns3__TopicExpressionDialectUnknownFaultType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns3__TopicExpressionDialectUnknownFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__TopicExpressionDialectUnknownFaultType(soap, tag ? tag : "ns3:TopicExpressionDialectUnknownFaultType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__TopicExpressionDialectUnknownFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__TopicExpressionDialectUnknownFaultType(soap, this, tag, type);
}

SOAP_FMAC3 ns3__TopicExpressionDialectUnknownFaultType * SOAP_FMAC4 soap_get_ns3__TopicExpressionDialectUnknownFaultType(struct soap *soap, ns3__TopicExpressionDialectUnknownFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__TopicExpressionDialectUnknownFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__InvalidFilterFaultType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns4__BaseFaultType::soap_default(soap);
	soap_default_std__vectorTemplateOfxsd__QName(soap, &this->ns3__InvalidFilterFaultType::UnknownFilter);
}

void ns3__InvalidFilterFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__QName(soap, &this->ns3__InvalidFilterFaultType::UnknownFilter);
	this->ns4__BaseFaultType::soap_serialize(soap);
#endif
}

int ns3__InvalidFilterFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__InvalidFilterFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__InvalidFilterFaultType(struct soap *soap, const char *tag, int id, const ns3__InvalidFilterFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((ns4__BaseFaultType*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__InvalidFilterFaultType), type ? type : "ns3:InvalidFilterFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->ns4__BaseFaultType::__any, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "ns4:Timestamp", -1, &a->ns4__BaseFaultType::Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTons6__EndpointReferenceType(soap, "ns4:Originator", -1, &a->ns4__BaseFaultType::Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_ns4__BaseFaultType_ErrorCode(soap, "ns4:ErrorCode", -1, &a->ns4__BaseFaultType::ErrorCode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_ns4__BaseFaultType_Description(soap, "ns4:Description", -1, &a->ns4__BaseFaultType::Description, ""))
		return soap->error;
	if (soap_out_PointerTo_ns4__BaseFaultType_FaultCause(soap, "ns4:FaultCause", -1, &a->ns4__BaseFaultType::FaultCause, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__QName(soap, "ns3:UnknownFilter", -1, &a->ns3__InvalidFilterFaultType::UnknownFilter, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__InvalidFilterFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__InvalidFilterFaultType(soap, tag, this, type);
}

SOAP_FMAC3 ns3__InvalidFilterFaultType * SOAP_FMAC4 soap_in_ns3__InvalidFilterFaultType(struct soap *soap, const char *tag, ns3__InvalidFilterFaultType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__InvalidFilterFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__InvalidFilterFaultType, sizeof(ns3__InvalidFilterFaultType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns3__InvalidFilterFaultType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__InvalidFilterFaultType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((ns4__BaseFaultType*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	size_t soap_flag_FaultCause2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "ns4:Timestamp", &a->ns4__BaseFaultType::Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons6__EndpointReferenceType(soap, "ns4:Originator", &a->ns4__BaseFaultType::Originator, "ns6:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns4__BaseFaultType_ErrorCode(soap, "ns4:ErrorCode", &a->ns4__BaseFaultType::ErrorCode, ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_ns4__BaseFaultType_Description(soap, "ns4:Description", &a->ns4__BaseFaultType::Description, ""))
					continue;
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns4__BaseFaultType_FaultCause(soap, "ns4:FaultCause", &a->ns4__BaseFaultType::FaultCause, ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__QName(soap, "ns3:UnknownFilter", &a->ns3__InvalidFilterFaultType::UnknownFilter, "xsd:QName"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->ns4__BaseFaultType::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0 || a->ns3__InvalidFilterFaultType::UnknownFilter.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns3__InvalidFilterFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__InvalidFilterFaultType, SOAP_TYPE_ns3__InvalidFilterFaultType, sizeof(ns3__InvalidFilterFaultType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__InvalidFilterFaultType * SOAP_FMAC2 soap_instantiate_ns3__InvalidFilterFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__InvalidFilterFaultType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__InvalidFilterFaultType *p;
	size_t k = sizeof(ns3__InvalidFilterFaultType);
	if (n < 0)
	{	p = SOAP_NEW(ns3__InvalidFilterFaultType);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns3__InvalidFilterFaultType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__InvalidFilterFaultType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns3__InvalidFilterFaultType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns3__InvalidFilterFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__InvalidFilterFaultType(soap, tag ? tag : "ns3:InvalidFilterFaultType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__InvalidFilterFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__InvalidFilterFaultType(soap, this, tag, type);
}

SOAP_FMAC3 ns3__InvalidFilterFaultType * SOAP_FMAC4 soap_get_ns3__InvalidFilterFaultType(struct soap *soap, ns3__InvalidFilterFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__InvalidFilterFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__SubscribeCreationFailedFaultType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns4__BaseFaultType::soap_default(soap);
}

void ns3__SubscribeCreationFailedFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->ns4__BaseFaultType::soap_serialize(soap);
#endif
}

int ns3__SubscribeCreationFailedFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__SubscribeCreationFailedFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__SubscribeCreationFailedFaultType(struct soap *soap, const char *tag, int id, const ns3__SubscribeCreationFailedFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((ns4__BaseFaultType*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__SubscribeCreationFailedFaultType), type ? type : "ns3:SubscribeCreationFailedFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->ns4__BaseFaultType::__any, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "ns4:Timestamp", -1, &a->ns4__BaseFaultType::Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTons6__EndpointReferenceType(soap, "ns4:Originator", -1, &a->ns4__BaseFaultType::Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_ns4__BaseFaultType_ErrorCode(soap, "ns4:ErrorCode", -1, &a->ns4__BaseFaultType::ErrorCode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_ns4__BaseFaultType_Description(soap, "ns4:Description", -1, &a->ns4__BaseFaultType::Description, ""))
		return soap->error;
	if (soap_out_PointerTo_ns4__BaseFaultType_FaultCause(soap, "ns4:FaultCause", -1, &a->ns4__BaseFaultType::FaultCause, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__SubscribeCreationFailedFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__SubscribeCreationFailedFaultType(soap, tag, this, type);
}

SOAP_FMAC3 ns3__SubscribeCreationFailedFaultType * SOAP_FMAC4 soap_in_ns3__SubscribeCreationFailedFaultType(struct soap *soap, const char *tag, ns3__SubscribeCreationFailedFaultType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__SubscribeCreationFailedFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__SubscribeCreationFailedFaultType, sizeof(ns3__SubscribeCreationFailedFaultType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns3__SubscribeCreationFailedFaultType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__SubscribeCreationFailedFaultType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((ns4__BaseFaultType*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	size_t soap_flag_FaultCause2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "ns4:Timestamp", &a->ns4__BaseFaultType::Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons6__EndpointReferenceType(soap, "ns4:Originator", &a->ns4__BaseFaultType::Originator, "ns6:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns4__BaseFaultType_ErrorCode(soap, "ns4:ErrorCode", &a->ns4__BaseFaultType::ErrorCode, ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_ns4__BaseFaultType_Description(soap, "ns4:Description", &a->ns4__BaseFaultType::Description, ""))
					continue;
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns4__BaseFaultType_FaultCause(soap, "ns4:FaultCause", &a->ns4__BaseFaultType::FaultCause, ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->ns4__BaseFaultType::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns3__SubscribeCreationFailedFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__SubscribeCreationFailedFaultType, SOAP_TYPE_ns3__SubscribeCreationFailedFaultType, sizeof(ns3__SubscribeCreationFailedFaultType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__SubscribeCreationFailedFaultType * SOAP_FMAC2 soap_instantiate_ns3__SubscribeCreationFailedFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__SubscribeCreationFailedFaultType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__SubscribeCreationFailedFaultType *p;
	size_t k = sizeof(ns3__SubscribeCreationFailedFaultType);
	if (n < 0)
	{	p = SOAP_NEW(ns3__SubscribeCreationFailedFaultType);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns3__SubscribeCreationFailedFaultType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__SubscribeCreationFailedFaultType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns3__SubscribeCreationFailedFaultType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns3__SubscribeCreationFailedFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__SubscribeCreationFailedFaultType(soap, tag ? tag : "ns3:SubscribeCreationFailedFaultType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__SubscribeCreationFailedFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__SubscribeCreationFailedFaultType(soap, this, tag, type);
}

SOAP_FMAC3 ns3__SubscribeCreationFailedFaultType * SOAP_FMAC4 soap_get_ns3__SubscribeCreationFailedFaultType(struct soap *soap, ns3__SubscribeCreationFailedFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__SubscribeCreationFailedFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__NotificationMessageHolderType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns3__NotificationMessageHolderType::SubscriptionReference = NULL;
	this->ns3__NotificationMessageHolderType::Topic = NULL;
	this->ns3__NotificationMessageHolderType::ProducerReference = NULL;
	this->ns3__NotificationMessageHolderType::Message._ns3__NotificationMessageHolderType_Message::soap_default(soap);
}

void ns3__NotificationMessageHolderType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons6__EndpointReferenceType(soap, &this->ns3__NotificationMessageHolderType::SubscriptionReference);
	soap_serialize_PointerTons3__TopicExpressionType(soap, &this->ns3__NotificationMessageHolderType::Topic);
	soap_serialize_PointerTons6__EndpointReferenceType(soap, &this->ns3__NotificationMessageHolderType::ProducerReference);
	this->ns3__NotificationMessageHolderType::Message.soap_serialize(soap);
#endif
}

int ns3__NotificationMessageHolderType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__NotificationMessageHolderType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__NotificationMessageHolderType(struct soap *soap, const char *tag, int id, const ns3__NotificationMessageHolderType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__NotificationMessageHolderType), type))
		return soap->error;
	if (soap_out_PointerTons6__EndpointReferenceType(soap, "ns3:SubscriptionReference", -1, &a->ns3__NotificationMessageHolderType::SubscriptionReference, ""))
		return soap->error;
	if (soap_out_PointerTons3__TopicExpressionType(soap, "ns3:Topic", -1, &a->ns3__NotificationMessageHolderType::Topic, ""))
		return soap->error;
	if (soap_out_PointerTons6__EndpointReferenceType(soap, "ns3:ProducerReference", -1, &a->ns3__NotificationMessageHolderType::ProducerReference, ""))
		return soap->error;
	if ((a->ns3__NotificationMessageHolderType::Message).soap_out(soap, "ns3:Message", -1, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__NotificationMessageHolderType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__NotificationMessageHolderType(soap, tag, this, type);
}

SOAP_FMAC3 ns3__NotificationMessageHolderType * SOAP_FMAC4 soap_in_ns3__NotificationMessageHolderType(struct soap *soap, const char *tag, ns3__NotificationMessageHolderType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__NotificationMessageHolderType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__NotificationMessageHolderType, sizeof(ns3__NotificationMessageHolderType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns3__NotificationMessageHolderType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__NotificationMessageHolderType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_SubscriptionReference1 = 1;
	size_t soap_flag_Topic1 = 1;
	size_t soap_flag_ProducerReference1 = 1;
	size_t soap_flag_Message1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SubscriptionReference1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons6__EndpointReferenceType(soap, "ns3:SubscriptionReference", &a->ns3__NotificationMessageHolderType::SubscriptionReference, "ns6:EndpointReferenceType"))
				{	soap_flag_SubscriptionReference1--;
					continue;
				}
			}
			if (soap_flag_Topic1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__TopicExpressionType(soap, "ns3:Topic", &a->ns3__NotificationMessageHolderType::Topic, "ns3:TopicExpressionType"))
				{	soap_flag_Topic1--;
					continue;
				}
			}
			if (soap_flag_ProducerReference1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons6__EndpointReferenceType(soap, "ns3:ProducerReference", &a->ns3__NotificationMessageHolderType::ProducerReference, "ns6:EndpointReferenceType"))
				{	soap_flag_ProducerReference1--;
					continue;
				}
			}
			if (soap_flag_Message1 && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->ns3__NotificationMessageHolderType::Message).soap_in(soap, "ns3:Message", ""))
				{	soap_flag_Message1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Message1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns3__NotificationMessageHolderType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__NotificationMessageHolderType, SOAP_TYPE_ns3__NotificationMessageHolderType, sizeof(ns3__NotificationMessageHolderType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__NotificationMessageHolderType * SOAP_FMAC2 soap_instantiate_ns3__NotificationMessageHolderType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__NotificationMessageHolderType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__NotificationMessageHolderType *p;
	size_t k = sizeof(ns3__NotificationMessageHolderType);
	if (n < 0)
	{	p = SOAP_NEW(ns3__NotificationMessageHolderType);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns3__NotificationMessageHolderType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__NotificationMessageHolderType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns3__NotificationMessageHolderType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns3__NotificationMessageHolderType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__NotificationMessageHolderType(soap, tag ? tag : "ns3:NotificationMessageHolderType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__NotificationMessageHolderType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__NotificationMessageHolderType(soap, this, tag, type);
}

SOAP_FMAC3 ns3__NotificationMessageHolderType * SOAP_FMAC4 soap_get_ns3__NotificationMessageHolderType(struct soap *soap, ns3__NotificationMessageHolderType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__NotificationMessageHolderType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__SubscriptionPolicyType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->ns3__SubscriptionPolicyType::__any);
}

void ns3__SubscriptionPolicyType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->ns3__SubscriptionPolicyType::__any);
#endif
}

int ns3__SubscriptionPolicyType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__SubscriptionPolicyType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__SubscriptionPolicyType(struct soap *soap, const char *tag, int id, const ns3__SubscriptionPolicyType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__SubscriptionPolicyType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->ns3__SubscriptionPolicyType::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__SubscriptionPolicyType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__SubscriptionPolicyType(soap, tag, this, type);
}

SOAP_FMAC3 ns3__SubscriptionPolicyType * SOAP_FMAC4 soap_in_ns3__SubscriptionPolicyType(struct soap *soap, const char *tag, ns3__SubscriptionPolicyType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__SubscriptionPolicyType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__SubscriptionPolicyType, sizeof(ns3__SubscriptionPolicyType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns3__SubscriptionPolicyType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__SubscriptionPolicyType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->ns3__SubscriptionPolicyType::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__SubscriptionPolicyType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__SubscriptionPolicyType, SOAP_TYPE_ns3__SubscriptionPolicyType, sizeof(ns3__SubscriptionPolicyType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__SubscriptionPolicyType * SOAP_FMAC2 soap_instantiate_ns3__SubscriptionPolicyType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__SubscriptionPolicyType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__SubscriptionPolicyType *p;
	size_t k = sizeof(ns3__SubscriptionPolicyType);
	if (n < 0)
	{	p = SOAP_NEW(ns3__SubscriptionPolicyType);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns3__SubscriptionPolicyType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__SubscriptionPolicyType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns3__SubscriptionPolicyType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns3__SubscriptionPolicyType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__SubscriptionPolicyType(soap, tag ? tag : "ns3:SubscriptionPolicyType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__SubscriptionPolicyType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__SubscriptionPolicyType(soap, this, tag, type);
}

SOAP_FMAC3 ns3__SubscriptionPolicyType * SOAP_FMAC4 soap_get_ns3__SubscriptionPolicyType(struct soap *soap, ns3__SubscriptionPolicyType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__SubscriptionPolicyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__FilterType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->ns3__FilterType::__any);
}

void ns3__FilterType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->ns3__FilterType::__any);
#endif
}

int ns3__FilterType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__FilterType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__FilterType(struct soap *soap, const char *tag, int id, const ns3__FilterType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__FilterType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->ns3__FilterType::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__FilterType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__FilterType(soap, tag, this, type);
}

SOAP_FMAC3 ns3__FilterType * SOAP_FMAC4 soap_in_ns3__FilterType(struct soap *soap, const char *tag, ns3__FilterType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__FilterType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__FilterType, sizeof(ns3__FilterType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns3__FilterType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__FilterType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->ns3__FilterType::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__FilterType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__FilterType, SOAP_TYPE_ns3__FilterType, sizeof(ns3__FilterType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__FilterType * SOAP_FMAC2 soap_instantiate_ns3__FilterType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__FilterType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__FilterType *p;
	size_t k = sizeof(ns3__FilterType);
	if (n < 0)
	{	p = SOAP_NEW(ns3__FilterType);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns3__FilterType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__FilterType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns3__FilterType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns3__FilterType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__FilterType(soap, tag ? tag : "ns3:FilterType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__FilterType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__FilterType(soap, this, tag, type);
}

SOAP_FMAC3 ns3__FilterType * SOAP_FMAC4 soap_get_ns3__FilterType(struct soap *soap, ns3__FilterType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__FilterType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__TopicExpressionType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &this->ns3__TopicExpressionType::__any);
	soap_default_xsd__anyURI(soap, &this->ns3__TopicExpressionType::Dialect);
	soap_default_xsd__anyAttribute(soap, &this->ns3__TopicExpressionType::__anyAttribute);
	soap_default_xsd__anyType(soap, &this->ns3__TopicExpressionType::__mixed);
}

void ns3__TopicExpressionType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__anyType(soap, &this->ns3__TopicExpressionType::__any);
	soap_serialize_xsd__anyType(soap, &this->ns3__TopicExpressionType::__mixed);
#endif
}

int ns3__TopicExpressionType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__TopicExpressionType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__TopicExpressionType(struct soap *soap, const char *tag, int id, const ns3__TopicExpressionType *a, const char *type)
{
	soap_set_attr(soap, "Dialect", soap_xsd__anyURI2s(soap, ((ns3__TopicExpressionType*)a)->Dialect), 1);
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((ns3__TopicExpressionType*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__TopicExpressionType), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-any", -1, &a->ns3__TopicExpressionType::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-mixed", -1, &a->ns3__TopicExpressionType::__mixed, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__TopicExpressionType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__TopicExpressionType(soap, tag, this, type);
}

SOAP_FMAC3 ns3__TopicExpressionType * SOAP_FMAC4 soap_in_ns3__TopicExpressionType(struct soap *soap, const char *tag, ns3__TopicExpressionType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__TopicExpressionType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__TopicExpressionType, sizeof(ns3__TopicExpressionType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns3__TopicExpressionType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__TopicExpressionType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "Dialect", 4, 1), &((ns3__TopicExpressionType*)a)->Dialect))
		return NULL;
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((ns3__TopicExpressionType*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag___any1 = 1;
	size_t soap_flag___mixed1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__anyType(soap, "-any", &a->ns3__TopicExpressionType::__any, "xsd:anyType"))
				{	soap_flag___any1--;
					continue;
				}
			}
			if (soap_flag___mixed1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__anyType(soap, "-mixed", &a->ns3__TopicExpressionType::__mixed, "xsd:anyType"))
				{	soap_flag___mixed1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__TopicExpressionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__TopicExpressionType, SOAP_TYPE_ns3__TopicExpressionType, sizeof(ns3__TopicExpressionType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__TopicExpressionType * SOAP_FMAC2 soap_instantiate_ns3__TopicExpressionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__TopicExpressionType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__TopicExpressionType *p;
	size_t k = sizeof(ns3__TopicExpressionType);
	if (n < 0)
	{	p = SOAP_NEW(ns3__TopicExpressionType);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns3__TopicExpressionType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__TopicExpressionType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns3__TopicExpressionType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns3__TopicExpressionType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__TopicExpressionType(soap, tag ? tag : "ns3:TopicExpressionType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__TopicExpressionType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__TopicExpressionType(soap, this, tag, type);
}

SOAP_FMAC3 ns3__TopicExpressionType * SOAP_FMAC4 soap_get_ns3__TopicExpressionType(struct soap *soap, ns3__TopicExpressionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__TopicExpressionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__QueryExpressionType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &this->ns3__QueryExpressionType::__any);
	soap_default_xsd__anyURI(soap, &this->ns3__QueryExpressionType::Dialect);
	soap_default_xsd__anyType(soap, &this->ns3__QueryExpressionType::__mixed);
}

void ns3__QueryExpressionType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__anyType(soap, &this->ns3__QueryExpressionType::__any);
	soap_serialize_xsd__anyType(soap, &this->ns3__QueryExpressionType::__mixed);
#endif
}

int ns3__QueryExpressionType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__QueryExpressionType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__QueryExpressionType(struct soap *soap, const char *tag, int id, const ns3__QueryExpressionType *a, const char *type)
{
	soap_set_attr(soap, "Dialect", soap_xsd__anyURI2s(soap, ((ns3__QueryExpressionType*)a)->Dialect), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__QueryExpressionType), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-any", -1, &a->ns3__QueryExpressionType::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-mixed", -1, &a->ns3__QueryExpressionType::__mixed, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__QueryExpressionType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__QueryExpressionType(soap, tag, this, type);
}

SOAP_FMAC3 ns3__QueryExpressionType * SOAP_FMAC4 soap_in_ns3__QueryExpressionType(struct soap *soap, const char *tag, ns3__QueryExpressionType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__QueryExpressionType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__QueryExpressionType, sizeof(ns3__QueryExpressionType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns3__QueryExpressionType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__QueryExpressionType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "Dialect", 4, 1), &((ns3__QueryExpressionType*)a)->Dialect))
		return NULL;
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag___any1 = 1;
	size_t soap_flag___mixed1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__anyType(soap, "-any", &a->ns3__QueryExpressionType::__any, "xsd:anyType"))
				{	soap_flag___any1--;
					continue;
				}
			}
			if (soap_flag___mixed1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__anyType(soap, "-mixed", &a->ns3__QueryExpressionType::__mixed, "xsd:anyType"))
				{	soap_flag___mixed1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__QueryExpressionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__QueryExpressionType, SOAP_TYPE_ns3__QueryExpressionType, sizeof(ns3__QueryExpressionType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__QueryExpressionType * SOAP_FMAC2 soap_instantiate_ns3__QueryExpressionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__QueryExpressionType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__QueryExpressionType *p;
	size_t k = sizeof(ns3__QueryExpressionType);
	if (n < 0)
	{	p = SOAP_NEW(ns3__QueryExpressionType);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns3__QueryExpressionType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__QueryExpressionType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns3__QueryExpressionType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns3__QueryExpressionType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__QueryExpressionType(soap, tag ? tag : "ns3:QueryExpressionType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__QueryExpressionType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__QueryExpressionType(soap, this, tag, type);
}

SOAP_FMAC3 ns3__QueryExpressionType * SOAP_FMAC4 soap_get_ns3__QueryExpressionType(struct soap *soap, ns3__QueryExpressionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__QueryExpressionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__TopicSetType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns2__ExtensibleDocumented::soap_default(soap);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->ns2__TopicSetType::__any);
}

void ns2__TopicSetType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->ns2__TopicSetType::__any);
	this->ns2__ExtensibleDocumented::soap_serialize(soap);
#endif
}

int ns2__TopicSetType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__TopicSetType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__TopicSetType(struct soap *soap, const char *tag, int id, const ns2__TopicSetType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((ns2__ExtensibleDocumented*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__TopicSetType), type ? type : "ns2:TopicSetType"))
		return soap->error;
	if (soap_out_PointerTons2__Documentation(soap, "ns2:documentation", -1, &a->ns2__ExtensibleDocumented::documentation, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->ns2__TopicSetType::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__TopicSetType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__TopicSetType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__TopicSetType * SOAP_FMAC4 soap_in_ns2__TopicSetType(struct soap *soap, const char *tag, ns2__TopicSetType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__TopicSetType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__TopicSetType, sizeof(ns2__TopicSetType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__TopicSetType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__TopicSetType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((ns2__ExtensibleDocumented*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_documentation2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_documentation2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__Documentation(soap, "ns2:documentation", &a->ns2__ExtensibleDocumented::documentation, "ns2:Documentation"))
				{	soap_flag_documentation2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->ns2__TopicSetType::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__TopicSetType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__TopicSetType, SOAP_TYPE_ns2__TopicSetType, sizeof(ns2__TopicSetType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__TopicSetType * SOAP_FMAC2 soap_instantiate_ns2__TopicSetType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__TopicSetType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__TopicSetType *p;
	size_t k = sizeof(ns2__TopicSetType);
	if (n < 0)
	{	p = SOAP_NEW(ns2__TopicSetType);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__TopicSetType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__TopicSetType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__TopicSetType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__TopicSetType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__TopicSetType(soap, tag ? tag : "ns2:TopicSetType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__TopicSetType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__TopicSetType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__TopicSetType * SOAP_FMAC4 soap_get_ns2__TopicSetType(struct soap *soap, ns2__TopicSetType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__TopicSetType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__TopicType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns2__ExtensibleDocumented::soap_default(soap);
	this->ns2__TopicType::MessagePattern = NULL;
	soap_default_std__vectorTemplateOfPointerTons2__TopicType(soap, &this->ns2__TopicType::Topic);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->ns2__TopicType::__any);
	soap_default_xsd__NCName(soap, &this->ns2__TopicType::name);
	this->ns2__TopicType::messageTypes = NULL;
	this->ns2__TopicType::final_ = (bool)0;
}

void ns2__TopicType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__QueryExpressionType(soap, &this->ns2__TopicType::MessagePattern);
	soap_serialize_std__vectorTemplateOfPointerTons2__TopicType(soap, &this->ns2__TopicType::Topic);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->ns2__TopicType::__any);
	this->ns2__ExtensibleDocumented::soap_serialize(soap);
#endif
}

int ns2__TopicType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__TopicType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__TopicType(struct soap *soap, const char *tag, int id, const ns2__TopicType *a, const char *type)
{
	soap_set_attr(soap, "name", soap_xsd__NCName2s(soap, ((ns2__TopicType*)a)->name), 1);
	if (((ns2__TopicType*)a)->messageTypes)
	{	soap_set_attr(soap, "messageTypes", soap_xsd__QName2s(soap, *((ns2__TopicType*)a)->messageTypes), 1);
	}
	soap_set_attr(soap, "final", soap_bool2s(soap, ((ns2__TopicType*)a)->final_), 1);
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((ns2__ExtensibleDocumented*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__TopicType), type ? type : "ns2:TopicType"))
		return soap->error;
	if (soap_out_PointerTons2__Documentation(soap, "ns2:documentation", -1, &a->ns2__ExtensibleDocumented::documentation, ""))
		return soap->error;
	if (soap_out_PointerTons2__QueryExpressionType(soap, "ns2:MessagePattern", -1, &a->ns2__TopicType::MessagePattern, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__TopicType(soap, "ns2:Topic", -1, &a->ns2__TopicType::Topic, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->ns2__TopicType::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__TopicType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__TopicType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__TopicType * SOAP_FMAC4 soap_in_ns2__TopicType(struct soap *soap, const char *tag, ns2__TopicType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__TopicType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__TopicType, sizeof(ns2__TopicType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__TopicType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__TopicType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__NCName(soap, soap_attr_value(soap, "name", 5, 1), &((ns2__TopicType*)a)->name))
		return NULL;
	{
		const char *t = soap_attr_value(soap, "messageTypes", 2, 0);
		if (t)
		{
			if (!(((ns2__TopicType*)a)->messageTypes = soap_new_xsd__QName(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__QName(soap, t, ((ns2__TopicType*)a)->messageTypes))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2bool(soap, soap_attr_value(soap, "final", 5, 0), &((ns2__TopicType*)a)->final_))
		return NULL;
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((ns2__ExtensibleDocumented*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_documentation2 = 1;
	size_t soap_flag_MessagePattern1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_documentation2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__Documentation(soap, "ns2:documentation", &a->ns2__ExtensibleDocumented::documentation, "ns2:Documentation"))
				{	soap_flag_documentation2--;
					continue;
				}
			}
			if (soap_flag_MessagePattern1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__QueryExpressionType(soap, "ns2:MessagePattern", &a->ns2__TopicType::MessagePattern, "ns2:QueryExpressionType"))
				{	soap_flag_MessagePattern1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons2__TopicType(soap, "ns2:Topic", &a->ns2__TopicType::Topic, "ns2:TopicType"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->ns2__TopicType::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__TopicType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__TopicType, SOAP_TYPE_ns2__TopicType, sizeof(ns2__TopicType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__TopicType * SOAP_FMAC2 soap_instantiate_ns2__TopicType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__TopicType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__TopicType *p;
	size_t k = sizeof(ns2__TopicType);
	if (n < 0)
	{	p = SOAP_NEW(ns2__TopicType);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__TopicType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__TopicType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__TopicType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__TopicType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__TopicType(soap, tag ? tag : "ns2:TopicType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__TopicType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__TopicType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__TopicType * SOAP_FMAC4 soap_get_ns2__TopicType(struct soap *soap, ns2__TopicType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__TopicType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__TopicNamespaceType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns2__ExtensibleDocumented::soap_default(soap);
	soap_default_std__vectorTemplateOf_ns2__TopicNamespaceType_Topic(soap, &this->ns2__TopicNamespaceType::Topic);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->ns2__TopicNamespaceType::__any);
	this->ns2__TopicNamespaceType::name = NULL;
	soap_default_xsd__anyURI(soap, &this->ns2__TopicNamespaceType::targetNamespace);
	this->ns2__TopicNamespaceType::final_ = (bool)0;
}

void ns2__TopicNamespaceType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOf_ns2__TopicNamespaceType_Topic(soap, &this->ns2__TopicNamespaceType::Topic);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->ns2__TopicNamespaceType::__any);
	this->ns2__ExtensibleDocumented::soap_serialize(soap);
#endif
}

int ns2__TopicNamespaceType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__TopicNamespaceType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__TopicNamespaceType(struct soap *soap, const char *tag, int id, const ns2__TopicNamespaceType *a, const char *type)
{
	if (((ns2__TopicNamespaceType*)a)->name)
	{	soap_set_attr(soap, "name", soap_xsd__NCName2s(soap, *((ns2__TopicNamespaceType*)a)->name), 1);
	}
	soap_set_attr(soap, "targetNamespace", soap_xsd__anyURI2s(soap, ((ns2__TopicNamespaceType*)a)->targetNamespace), 1);
	soap_set_attr(soap, "final", soap_bool2s(soap, ((ns2__TopicNamespaceType*)a)->final_), 1);
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((ns2__ExtensibleDocumented*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__TopicNamespaceType), type ? type : "ns2:TopicNamespaceType"))
		return soap->error;
	if (soap_out_PointerTons2__Documentation(soap, "ns2:documentation", -1, &a->ns2__ExtensibleDocumented::documentation, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_ns2__TopicNamespaceType_Topic(soap, "ns2:Topic", -1, &a->ns2__TopicNamespaceType::Topic, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->ns2__TopicNamespaceType::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__TopicNamespaceType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__TopicNamespaceType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__TopicNamespaceType * SOAP_FMAC4 soap_in_ns2__TopicNamespaceType(struct soap *soap, const char *tag, ns2__TopicNamespaceType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__TopicNamespaceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__TopicNamespaceType, sizeof(ns2__TopicNamespaceType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__TopicNamespaceType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__TopicNamespaceType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "name", 5, 0);
		if (t)
		{
			if (!(((ns2__TopicNamespaceType*)a)->name = soap_new_xsd__NCName(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__NCName(soap, t, ((ns2__TopicNamespaceType*)a)->name))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "targetNamespace", 4, 1), &((ns2__TopicNamespaceType*)a)->targetNamespace))
		return NULL;
	if (soap_s2bool(soap, soap_attr_value(soap, "final", 5, 0), &((ns2__TopicNamespaceType*)a)->final_))
		return NULL;
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((ns2__ExtensibleDocumented*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_documentation2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_documentation2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__Documentation(soap, "ns2:documentation", &a->ns2__ExtensibleDocumented::documentation, "ns2:Documentation"))
				{	soap_flag_documentation2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_ns2__TopicNamespaceType_Topic(soap, "ns2:Topic", &a->ns2__TopicNamespaceType::Topic, ""))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->ns2__TopicNamespaceType::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__TopicNamespaceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__TopicNamespaceType, SOAP_TYPE_ns2__TopicNamespaceType, sizeof(ns2__TopicNamespaceType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__TopicNamespaceType * SOAP_FMAC2 soap_instantiate_ns2__TopicNamespaceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__TopicNamespaceType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__TopicNamespaceType *p;
	size_t k = sizeof(ns2__TopicNamespaceType);
	if (n < 0)
	{	p = SOAP_NEW(ns2__TopicNamespaceType);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__TopicNamespaceType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__TopicNamespaceType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__TopicNamespaceType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__TopicNamespaceType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__TopicNamespaceType(soap, tag ? tag : "ns2:TopicNamespaceType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__TopicNamespaceType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__TopicNamespaceType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__TopicNamespaceType * SOAP_FMAC4 soap_get_ns2__TopicNamespaceType(struct soap *soap, ns2__TopicNamespaceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__TopicNamespaceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__QueryExpressionType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &this->ns2__QueryExpressionType::__any);
	soap_default_xsd__anyURI(soap, &this->ns2__QueryExpressionType::Dialect);
	soap_default_xsd__anyType(soap, &this->ns2__QueryExpressionType::__mixed);
}

void ns2__QueryExpressionType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__anyType(soap, &this->ns2__QueryExpressionType::__any);
	soap_serialize_xsd__anyType(soap, &this->ns2__QueryExpressionType::__mixed);
#endif
}

int ns2__QueryExpressionType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__QueryExpressionType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__QueryExpressionType(struct soap *soap, const char *tag, int id, const ns2__QueryExpressionType *a, const char *type)
{
	soap_set_attr(soap, "Dialect", soap_xsd__anyURI2s(soap, ((ns2__QueryExpressionType*)a)->Dialect), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__QueryExpressionType), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-any", -1, &a->ns2__QueryExpressionType::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-mixed", -1, &a->ns2__QueryExpressionType::__mixed, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__QueryExpressionType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__QueryExpressionType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__QueryExpressionType * SOAP_FMAC4 soap_in_ns2__QueryExpressionType(struct soap *soap, const char *tag, ns2__QueryExpressionType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__QueryExpressionType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__QueryExpressionType, sizeof(ns2__QueryExpressionType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__QueryExpressionType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__QueryExpressionType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "Dialect", 4, 1), &((ns2__QueryExpressionType*)a)->Dialect))
		return NULL;
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag___any1 = 1;
	size_t soap_flag___mixed1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__anyType(soap, "-any", &a->ns2__QueryExpressionType::__any, "xsd:anyType"))
				{	soap_flag___any1--;
					continue;
				}
			}
			if (soap_flag___mixed1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__anyType(soap, "-mixed", &a->ns2__QueryExpressionType::__mixed, "xsd:anyType"))
				{	soap_flag___mixed1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__QueryExpressionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__QueryExpressionType, SOAP_TYPE_ns2__QueryExpressionType, sizeof(ns2__QueryExpressionType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__QueryExpressionType * SOAP_FMAC2 soap_instantiate_ns2__QueryExpressionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__QueryExpressionType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__QueryExpressionType *p;
	size_t k = sizeof(ns2__QueryExpressionType);
	if (n < 0)
	{	p = SOAP_NEW(ns2__QueryExpressionType);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__QueryExpressionType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__QueryExpressionType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__QueryExpressionType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__QueryExpressionType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__QueryExpressionType(soap, tag ? tag : "ns2:QueryExpressionType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__QueryExpressionType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__QueryExpressionType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__QueryExpressionType * SOAP_FMAC4 soap_get_ns2__QueryExpressionType(struct soap *soap, ns2__QueryExpressionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__QueryExpressionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__ExtensibleDocumented::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns2__ExtensibleDocumented::documentation = NULL;
	soap_default_xsd__anyAttribute(soap, &this->ns2__ExtensibleDocumented::__anyAttribute);
}

void ns2__ExtensibleDocumented::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__Documentation(soap, &this->ns2__ExtensibleDocumented::documentation);
#endif
}

int ns2__ExtensibleDocumented::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ExtensibleDocumented(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ExtensibleDocumented(struct soap *soap, const char *tag, int id, const ns2__ExtensibleDocumented *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((ns2__ExtensibleDocumented*)a)->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ExtensibleDocumented), type))
		return soap->error;
	if (soap_out_PointerTons2__Documentation(soap, "ns2:documentation", -1, &a->ns2__ExtensibleDocumented::documentation, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__ExtensibleDocumented::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ExtensibleDocumented(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ExtensibleDocumented * SOAP_FMAC4 soap_in_ns2__ExtensibleDocumented(struct soap *soap, const char *tag, ns2__ExtensibleDocumented *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ExtensibleDocumented *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ExtensibleDocumented, sizeof(ns2__ExtensibleDocumented), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__ExtensibleDocumented)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__ExtensibleDocumented *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((ns2__ExtensibleDocumented*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_documentation1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_documentation1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__Documentation(soap, "ns2:documentation", &a->ns2__ExtensibleDocumented::documentation, "ns2:Documentation"))
				{	soap_flag_documentation1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ExtensibleDocumented *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ExtensibleDocumented, SOAP_TYPE_ns2__ExtensibleDocumented, sizeof(ns2__ExtensibleDocumented), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__ExtensibleDocumented * SOAP_FMAC2 soap_instantiate_ns2__ExtensibleDocumented(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ExtensibleDocumented(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (soap && type && !soap_match_tag(soap, type, "ns2:TopicNamespaceType"))
		return soap_instantiate_ns2__TopicNamespaceType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns2:TopicType"))
		return soap_instantiate_ns2__TopicType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns2:TopicSetType"))
		return soap_instantiate_ns2__TopicSetType(soap, n, NULL, NULL, size);
	ns2__ExtensibleDocumented *p;
	size_t k = sizeof(ns2__ExtensibleDocumented);
	if (n < 0)
	{	p = SOAP_NEW(ns2__ExtensibleDocumented);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__ExtensibleDocumented, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__ExtensibleDocumented location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__ExtensibleDocumented, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__ExtensibleDocumented::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__ExtensibleDocumented(soap, tag ? tag : "ns2:ExtensibleDocumented", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ExtensibleDocumented::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ExtensibleDocumented(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ExtensibleDocumented * SOAP_FMAC4 soap_get_ns2__ExtensibleDocumented(struct soap *soap, ns2__ExtensibleDocumented *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ExtensibleDocumented(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__Documentation::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->ns2__Documentation::__any);
	soap_default_xsd__anyType(soap, &this->ns2__Documentation::__mixed);
}

void ns2__Documentation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->ns2__Documentation::__any);
	soap_serialize_xsd__anyType(soap, &this->ns2__Documentation::__mixed);
#endif
}

int ns2__Documentation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__Documentation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Documentation(struct soap *soap, const char *tag, int id, const ns2__Documentation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__Documentation), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &a->ns2__Documentation::__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-mixed", -1, &a->ns2__Documentation::__mixed, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__Documentation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__Documentation(soap, tag, this, type);
}

SOAP_FMAC3 ns2__Documentation * SOAP_FMAC4 soap_in_ns2__Documentation(struct soap *soap, const char *tag, ns2__Documentation *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__Documentation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__Documentation, sizeof(ns2__Documentation), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__Documentation)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__Documentation *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag___mixed1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &a->ns2__Documentation::__any, "xsd:anyType"))
					continue;
			}
			if (soap_flag___mixed1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__anyType(soap, "-mixed", &a->ns2__Documentation::__mixed, "xsd:anyType"))
				{	soap_flag___mixed1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__Documentation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__Documentation, SOAP_TYPE_ns2__Documentation, sizeof(ns2__Documentation), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__Documentation * SOAP_FMAC2 soap_instantiate_ns2__Documentation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__Documentation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__Documentation *p;
	size_t k = sizeof(ns2__Documentation);
	if (n < 0)
	{	p = SOAP_NEW(ns2__Documentation);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__Documentation, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__Documentation location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__Documentation, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__Documentation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__Documentation(soap, tag ? tag : "ns2:Documentation", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__Documentation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__Documentation(soap, this, tag, type);
}

SOAP_FMAC3 ns2__Documentation * SOAP_FMAC4 soap_get_ns2__Documentation(struct soap *soap, ns2__Documentation *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Documentation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__ChangeVirtualInputStateResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_ns1__ChangeVirtualInputStateResponse::stateChanged);
	/* transient soap skipped */
}

void _ns1__ChangeVirtualInputStateResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_ns1__ChangeVirtualInputStateResponse::stateChanged, SOAP_TYPE_bool);
#endif
}

int _ns1__ChangeVirtualInputStateResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__ChangeVirtualInputStateResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ChangeVirtualInputStateResponse(struct soap *soap, const char *tag, int id, const _ns1__ChangeVirtualInputStateResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__ChangeVirtualInputStateResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:stateChanged");
	if (soap_out_bool(soap, "ns1:stateChanged", -1, &a->_ns1__ChangeVirtualInputStateResponse::stateChanged, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__ChangeVirtualInputStateResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__ChangeVirtualInputStateResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__ChangeVirtualInputStateResponse * SOAP_FMAC4 soap_in__ns1__ChangeVirtualInputStateResponse(struct soap *soap, const char *tag, _ns1__ChangeVirtualInputStateResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__ChangeVirtualInputStateResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__ChangeVirtualInputStateResponse, sizeof(_ns1__ChangeVirtualInputStateResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__ChangeVirtualInputStateResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__ChangeVirtualInputStateResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_stateChanged1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_stateChanged1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "ns1:stateChanged", &a->_ns1__ChangeVirtualInputStateResponse::stateChanged, "xsd:boolean"))
				{	soap_flag_stateChanged1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:stateChanged");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_stateChanged1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__ChangeVirtualInputStateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__ChangeVirtualInputStateResponse, SOAP_TYPE__ns1__ChangeVirtualInputStateResponse, sizeof(_ns1__ChangeVirtualInputStateResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__ChangeVirtualInputStateResponse * SOAP_FMAC2 soap_instantiate__ns1__ChangeVirtualInputStateResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__ChangeVirtualInputStateResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__ChangeVirtualInputStateResponse *p;
	size_t k = sizeof(_ns1__ChangeVirtualInputStateResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__ChangeVirtualInputStateResponse);
		if (p)
			((_ns1__ChangeVirtualInputStateResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__ChangeVirtualInputStateResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__ChangeVirtualInputStateResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__ChangeVirtualInputStateResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__ChangeVirtualInputStateResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__ChangeVirtualInputStateResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__ChangeVirtualInputStateResponse(soap, tag ? tag : "ns1:ChangeVirtualInputStateResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__ChangeVirtualInputStateResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__ChangeVirtualInputStateResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__ChangeVirtualInputStateResponse * SOAP_FMAC4 soap_get__ns1__ChangeVirtualInputStateResponse(struct soap *soap, _ns1__ChangeVirtualInputStateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ChangeVirtualInputStateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__ChangeVirtualInputState::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__ChangeVirtualInputState::port);
	soap_default_bool(soap, &this->_ns1__ChangeVirtualInputState::active);
	/* transient soap skipped */
}

void _ns1__ChangeVirtualInputState::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_ns1__ChangeVirtualInputState::active, SOAP_TYPE_bool);
#endif
}

int _ns1__ChangeVirtualInputState::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__ChangeVirtualInputState(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ChangeVirtualInputState(struct soap *soap, const char *tag, int id, const _ns1__ChangeVirtualInputState *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__ChangeVirtualInputState), type))
		return soap->error;
	if (soap_out_int(soap, "ns1:port", -1, &a->_ns1__ChangeVirtualInputState::port, ""))
		return soap->error;
	if (soap_out_bool(soap, "ns1:active", -1, &a->_ns1__ChangeVirtualInputState::active, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__ChangeVirtualInputState::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__ChangeVirtualInputState(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__ChangeVirtualInputState * SOAP_FMAC4 soap_in__ns1__ChangeVirtualInputState(struct soap *soap, const char *tag, _ns1__ChangeVirtualInputState *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__ChangeVirtualInputState *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__ChangeVirtualInputState, sizeof(_ns1__ChangeVirtualInputState), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__ChangeVirtualInputState)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__ChangeVirtualInputState *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_port1 = 1;
	size_t soap_flag_active1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_port1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns1:port", &a->_ns1__ChangeVirtualInputState::port, "xsd:int"))
				{	soap_flag_port1--;
					continue;
				}
			}
			if (soap_flag_active1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "ns1:active", &a->_ns1__ChangeVirtualInputState::active, "xsd:boolean"))
				{	soap_flag_active1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_port1 > 0 || soap_flag_active1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__ChangeVirtualInputState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__ChangeVirtualInputState, SOAP_TYPE__ns1__ChangeVirtualInputState, sizeof(_ns1__ChangeVirtualInputState), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__ChangeVirtualInputState * SOAP_FMAC2 soap_instantiate__ns1__ChangeVirtualInputState(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__ChangeVirtualInputState(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__ChangeVirtualInputState *p;
	size_t k = sizeof(_ns1__ChangeVirtualInputState);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__ChangeVirtualInputState);
		if (p)
			((_ns1__ChangeVirtualInputState*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__ChangeVirtualInputState, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__ChangeVirtualInputState*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__ChangeVirtualInputState location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__ChangeVirtualInputState, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__ChangeVirtualInputState::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__ChangeVirtualInputState(soap, tag ? tag : "ns1:ChangeVirtualInputState", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__ChangeVirtualInputState::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__ChangeVirtualInputState(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__ChangeVirtualInputState * SOAP_FMAC4 soap_get__ns1__ChangeVirtualInputState(struct soap *soap, _ns1__ChangeVirtualInputState *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ChangeVirtualInputState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__ScheduledEventAlreadyExistsFault::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns1__ScheduledEventAlreadyExistsFault::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__ScheduledEventAlreadyExistsFault::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__ScheduledEventAlreadyExistsFault(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ScheduledEventAlreadyExistsFault(struct soap *soap, const char *tag, int id, const _ns1__ScheduledEventAlreadyExistsFault *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__ScheduledEventAlreadyExistsFault), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__ScheduledEventAlreadyExistsFault::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__ScheduledEventAlreadyExistsFault(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__ScheduledEventAlreadyExistsFault * SOAP_FMAC4 soap_in__ns1__ScheduledEventAlreadyExistsFault(struct soap *soap, const char *tag, _ns1__ScheduledEventAlreadyExistsFault *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__ScheduledEventAlreadyExistsFault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__ScheduledEventAlreadyExistsFault, sizeof(_ns1__ScheduledEventAlreadyExistsFault), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__ScheduledEventAlreadyExistsFault)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__ScheduledEventAlreadyExistsFault *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__ScheduledEventAlreadyExistsFault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__ScheduledEventAlreadyExistsFault, SOAP_TYPE__ns1__ScheduledEventAlreadyExistsFault, sizeof(_ns1__ScheduledEventAlreadyExistsFault), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__ScheduledEventAlreadyExistsFault * SOAP_FMAC2 soap_instantiate__ns1__ScheduledEventAlreadyExistsFault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__ScheduledEventAlreadyExistsFault(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__ScheduledEventAlreadyExistsFault *p;
	size_t k = sizeof(_ns1__ScheduledEventAlreadyExistsFault);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__ScheduledEventAlreadyExistsFault);
		if (p)
			((_ns1__ScheduledEventAlreadyExistsFault*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__ScheduledEventAlreadyExistsFault, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__ScheduledEventAlreadyExistsFault*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__ScheduledEventAlreadyExistsFault location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__ScheduledEventAlreadyExistsFault, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__ScheduledEventAlreadyExistsFault::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__ScheduledEventAlreadyExistsFault(soap, tag ? tag : "ns1:ScheduledEventAlreadyExistsFault", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__ScheduledEventAlreadyExistsFault::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__ScheduledEventAlreadyExistsFault(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__ScheduledEventAlreadyExistsFault * SOAP_FMAC4 soap_get__ns1__ScheduledEventAlreadyExistsFault(struct soap *soap, _ns1__ScheduledEventAlreadyExistsFault *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ScheduledEventAlreadyExistsFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__InvalidScheduledEventIDFault::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns1__InvalidScheduledEventIDFault::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__InvalidScheduledEventIDFault::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__InvalidScheduledEventIDFault(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__InvalidScheduledEventIDFault(struct soap *soap, const char *tag, int id, const _ns1__InvalidScheduledEventIDFault *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__InvalidScheduledEventIDFault), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__InvalidScheduledEventIDFault::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__InvalidScheduledEventIDFault(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__InvalidScheduledEventIDFault * SOAP_FMAC4 soap_in__ns1__InvalidScheduledEventIDFault(struct soap *soap, const char *tag, _ns1__InvalidScheduledEventIDFault *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__InvalidScheduledEventIDFault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__InvalidScheduledEventIDFault, sizeof(_ns1__InvalidScheduledEventIDFault), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__InvalidScheduledEventIDFault)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__InvalidScheduledEventIDFault *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__InvalidScheduledEventIDFault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__InvalidScheduledEventIDFault, SOAP_TYPE__ns1__InvalidScheduledEventIDFault, sizeof(_ns1__InvalidScheduledEventIDFault), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__InvalidScheduledEventIDFault * SOAP_FMAC2 soap_instantiate__ns1__InvalidScheduledEventIDFault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__InvalidScheduledEventIDFault(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__InvalidScheduledEventIDFault *p;
	size_t k = sizeof(_ns1__InvalidScheduledEventIDFault);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__InvalidScheduledEventIDFault);
		if (p)
			((_ns1__InvalidScheduledEventIDFault*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__InvalidScheduledEventIDFault, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__InvalidScheduledEventIDFault*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__InvalidScheduledEventIDFault location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__InvalidScheduledEventIDFault, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__InvalidScheduledEventIDFault::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__InvalidScheduledEventIDFault(soap, tag ? tag : "ns1:InvalidScheduledEventIDFault", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__InvalidScheduledEventIDFault::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__InvalidScheduledEventIDFault(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__InvalidScheduledEventIDFault * SOAP_FMAC4 soap_get__ns1__InvalidScheduledEventIDFault(struct soap *soap, _ns1__InvalidScheduledEventIDFault *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__InvalidScheduledEventIDFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__InvalidScheduleFault::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns1__InvalidScheduleFault::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__InvalidScheduleFault::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__InvalidScheduleFault(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__InvalidScheduleFault(struct soap *soap, const char *tag, int id, const _ns1__InvalidScheduleFault *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__InvalidScheduleFault), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__InvalidScheduleFault::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__InvalidScheduleFault(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__InvalidScheduleFault * SOAP_FMAC4 soap_in__ns1__InvalidScheduleFault(struct soap *soap, const char *tag, _ns1__InvalidScheduleFault *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__InvalidScheduleFault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__InvalidScheduleFault, sizeof(_ns1__InvalidScheduleFault), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__InvalidScheduleFault)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__InvalidScheduleFault *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__InvalidScheduleFault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__InvalidScheduleFault, SOAP_TYPE__ns1__InvalidScheduleFault, sizeof(_ns1__InvalidScheduleFault), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__InvalidScheduleFault * SOAP_FMAC2 soap_instantiate__ns1__InvalidScheduleFault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__InvalidScheduleFault(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__InvalidScheduleFault *p;
	size_t k = sizeof(_ns1__InvalidScheduleFault);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__InvalidScheduleFault);
		if (p)
			((_ns1__InvalidScheduleFault*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__InvalidScheduleFault, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__InvalidScheduleFault*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__InvalidScheduleFault location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__InvalidScheduleFault, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__InvalidScheduleFault::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__InvalidScheduleFault(soap, tag ? tag : "ns1:InvalidScheduleFault", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__InvalidScheduleFault::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__InvalidScheduleFault(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__InvalidScheduleFault * SOAP_FMAC4 soap_get__ns1__InvalidScheduleFault(struct soap *soap, _ns1__InvalidScheduleFault *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__InvalidScheduleFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__ScheduledEventNotFoundFault::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns1__ScheduledEventNotFoundFault::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__ScheduledEventNotFoundFault::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__ScheduledEventNotFoundFault(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ScheduledEventNotFoundFault(struct soap *soap, const char *tag, int id, const _ns1__ScheduledEventNotFoundFault *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__ScheduledEventNotFoundFault), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__ScheduledEventNotFoundFault::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__ScheduledEventNotFoundFault(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__ScheduledEventNotFoundFault * SOAP_FMAC4 soap_in__ns1__ScheduledEventNotFoundFault(struct soap *soap, const char *tag, _ns1__ScheduledEventNotFoundFault *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__ScheduledEventNotFoundFault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__ScheduledEventNotFoundFault, sizeof(_ns1__ScheduledEventNotFoundFault), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__ScheduledEventNotFoundFault)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__ScheduledEventNotFoundFault *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__ScheduledEventNotFoundFault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__ScheduledEventNotFoundFault, SOAP_TYPE__ns1__ScheduledEventNotFoundFault, sizeof(_ns1__ScheduledEventNotFoundFault), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__ScheduledEventNotFoundFault * SOAP_FMAC2 soap_instantiate__ns1__ScheduledEventNotFoundFault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__ScheduledEventNotFoundFault(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__ScheduledEventNotFoundFault *p;
	size_t k = sizeof(_ns1__ScheduledEventNotFoundFault);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__ScheduledEventNotFoundFault);
		if (p)
			((_ns1__ScheduledEventNotFoundFault*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__ScheduledEventNotFoundFault, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__ScheduledEventNotFoundFault*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__ScheduledEventNotFoundFault location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__ScheduledEventNotFoundFault, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__ScheduledEventNotFoundFault::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__ScheduledEventNotFoundFault(soap, tag ? tag : "ns1:ScheduledEventNotFoundFault", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__ScheduledEventNotFoundFault::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__ScheduledEventNotFoundFault(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__ScheduledEventNotFoundFault * SOAP_FMAC4 soap_get__ns1__ScheduledEventNotFoundFault(struct soap *soap, _ns1__ScheduledEventNotFoundFault *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ScheduledEventNotFoundFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetScheduledEventsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetScheduledEventsResponse::ScheduledEvents = NULL;
	/* transient soap skipped */
}

void _ns1__GetScheduledEventsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ScheduledEvents(soap, &this->_ns1__GetScheduledEventsResponse::ScheduledEvents);
#endif
}

int _ns1__GetScheduledEventsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetScheduledEventsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetScheduledEventsResponse(struct soap *soap, const char *tag, int id, const _ns1__GetScheduledEventsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetScheduledEventsResponse), type))
		return soap->error;
	if (a->ScheduledEvents)
		soap_element_result(soap, "ns1:ScheduledEvents");
	if (!a->_ns1__GetScheduledEventsResponse::ScheduledEvents)
	{	if (soap_element_empty(soap, "ns1:ScheduledEvents"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons1__ScheduledEvents(soap, "ns1:ScheduledEvents", -1, &a->_ns1__GetScheduledEventsResponse::ScheduledEvents, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetScheduledEventsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetScheduledEventsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetScheduledEventsResponse * SOAP_FMAC4 soap_in__ns1__GetScheduledEventsResponse(struct soap *soap, const char *tag, _ns1__GetScheduledEventsResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetScheduledEventsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetScheduledEventsResponse, sizeof(_ns1__GetScheduledEventsResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetScheduledEventsResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetScheduledEventsResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ScheduledEvents1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ScheduledEvents1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ScheduledEvents(soap, "ns1:ScheduledEvents", &a->_ns1__GetScheduledEventsResponse::ScheduledEvents, "ns1:ScheduledEvents"))
				{	soap_flag_ScheduledEvents1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:ScheduledEvents");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_ns1__GetScheduledEventsResponse::ScheduledEvents))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__GetScheduledEventsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetScheduledEventsResponse, SOAP_TYPE__ns1__GetScheduledEventsResponse, sizeof(_ns1__GetScheduledEventsResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetScheduledEventsResponse * SOAP_FMAC2 soap_instantiate__ns1__GetScheduledEventsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetScheduledEventsResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetScheduledEventsResponse *p;
	size_t k = sizeof(_ns1__GetScheduledEventsResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetScheduledEventsResponse);
		if (p)
			((_ns1__GetScheduledEventsResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetScheduledEventsResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetScheduledEventsResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetScheduledEventsResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetScheduledEventsResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetScheduledEventsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetScheduledEventsResponse(soap, tag ? tag : "ns1:GetScheduledEventsResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetScheduledEventsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetScheduledEventsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetScheduledEventsResponse * SOAP_FMAC4 soap_get__ns1__GetScheduledEventsResponse(struct soap *soap, _ns1__GetScheduledEventsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetScheduledEventsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetScheduledEvents::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetScheduledEvents::ScheduleFilter = NULL;
	/* transient soap skipped */
}

void _ns1__GetScheduledEvents::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ScheduleFilter(soap, &this->_ns1__GetScheduledEvents::ScheduleFilter);
#endif
}

int _ns1__GetScheduledEvents::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetScheduledEvents(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetScheduledEvents(struct soap *soap, const char *tag, int id, const _ns1__GetScheduledEvents *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetScheduledEvents), type))
		return soap->error;
	if (soap_out_PointerTons1__ScheduleFilter(soap, "ns1:ScheduleFilter", -1, &a->_ns1__GetScheduledEvents::ScheduleFilter, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetScheduledEvents::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetScheduledEvents(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetScheduledEvents * SOAP_FMAC4 soap_in__ns1__GetScheduledEvents(struct soap *soap, const char *tag, _ns1__GetScheduledEvents *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetScheduledEvents *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetScheduledEvents, sizeof(_ns1__GetScheduledEvents), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetScheduledEvents)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetScheduledEvents *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ScheduleFilter1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ScheduleFilter1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ScheduleFilter(soap, "ns1:ScheduleFilter", &a->_ns1__GetScheduledEvents::ScheduleFilter, "ns1:ScheduleFilter"))
				{	soap_flag_ScheduleFilter1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetScheduledEvents *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetScheduledEvents, SOAP_TYPE__ns1__GetScheduledEvents, sizeof(_ns1__GetScheduledEvents), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetScheduledEvents * SOAP_FMAC2 soap_instantiate__ns1__GetScheduledEvents(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetScheduledEvents(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetScheduledEvents *p;
	size_t k = sizeof(_ns1__GetScheduledEvents);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetScheduledEvents);
		if (p)
			((_ns1__GetScheduledEvents*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetScheduledEvents, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetScheduledEvents*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetScheduledEvents location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetScheduledEvents, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetScheduledEvents::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetScheduledEvents(soap, tag ? tag : "ns1:GetScheduledEvents", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetScheduledEvents::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetScheduledEvents(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetScheduledEvents * SOAP_FMAC4 soap_get__ns1__GetScheduledEvents(struct soap *soap, _ns1__GetScheduledEvents *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetScheduledEvents(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__RemoveScheduledEventResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns1__RemoveScheduledEventResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__RemoveScheduledEventResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__RemoveScheduledEventResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__RemoveScheduledEventResponse(struct soap *soap, const char *tag, int id, const _ns1__RemoveScheduledEventResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__RemoveScheduledEventResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__RemoveScheduledEventResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__RemoveScheduledEventResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__RemoveScheduledEventResponse * SOAP_FMAC4 soap_in__ns1__RemoveScheduledEventResponse(struct soap *soap, const char *tag, _ns1__RemoveScheduledEventResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__RemoveScheduledEventResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__RemoveScheduledEventResponse, sizeof(_ns1__RemoveScheduledEventResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__RemoveScheduledEventResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__RemoveScheduledEventResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__RemoveScheduledEventResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__RemoveScheduledEventResponse, SOAP_TYPE__ns1__RemoveScheduledEventResponse, sizeof(_ns1__RemoveScheduledEventResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__RemoveScheduledEventResponse * SOAP_FMAC2 soap_instantiate__ns1__RemoveScheduledEventResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__RemoveScheduledEventResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__RemoveScheduledEventResponse *p;
	size_t k = sizeof(_ns1__RemoveScheduledEventResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__RemoveScheduledEventResponse);
		if (p)
			((_ns1__RemoveScheduledEventResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__RemoveScheduledEventResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__RemoveScheduledEventResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__RemoveScheduledEventResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__RemoveScheduledEventResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__RemoveScheduledEventResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__RemoveScheduledEventResponse(soap, tag ? tag : "ns1:RemoveScheduledEventResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__RemoveScheduledEventResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__RemoveScheduledEventResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__RemoveScheduledEventResponse * SOAP_FMAC4 soap_get__ns1__RemoveScheduledEventResponse(struct soap *soap, _ns1__RemoveScheduledEventResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__RemoveScheduledEventResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__RemoveScheduledEvent::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_ns1__RemoveScheduledEvent::EventID);
	/* transient soap skipped */
}

void _ns1__RemoveScheduledEvent::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_ns1__RemoveScheduledEvent::EventID, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns1__RemoveScheduledEvent::EventID);
#endif
}

int _ns1__RemoveScheduledEvent::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__RemoveScheduledEvent(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__RemoveScheduledEvent(struct soap *soap, const char *tag, int id, const _ns1__RemoveScheduledEvent *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__RemoveScheduledEvent), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:EventID", -1, &a->_ns1__RemoveScheduledEvent::EventID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__RemoveScheduledEvent::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__RemoveScheduledEvent(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__RemoveScheduledEvent * SOAP_FMAC4 soap_in__ns1__RemoveScheduledEvent(struct soap *soap, const char *tag, _ns1__RemoveScheduledEvent *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__RemoveScheduledEvent *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__RemoveScheduledEvent, sizeof(_ns1__RemoveScheduledEvent), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__RemoveScheduledEvent)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__RemoveScheduledEvent *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_EventID1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_EventID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:EventID", &a->_ns1__RemoveScheduledEvent::EventID, "xsd:string"))
				{	soap_flag_EventID1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_EventID1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__RemoveScheduledEvent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__RemoveScheduledEvent, SOAP_TYPE__ns1__RemoveScheduledEvent, sizeof(_ns1__RemoveScheduledEvent), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__RemoveScheduledEvent * SOAP_FMAC2 soap_instantiate__ns1__RemoveScheduledEvent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__RemoveScheduledEvent(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__RemoveScheduledEvent *p;
	size_t k = sizeof(_ns1__RemoveScheduledEvent);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__RemoveScheduledEvent);
		if (p)
			((_ns1__RemoveScheduledEvent*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__RemoveScheduledEvent, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__RemoveScheduledEvent*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__RemoveScheduledEvent location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__RemoveScheduledEvent, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__RemoveScheduledEvent::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__RemoveScheduledEvent(soap, tag ? tag : "ns1:RemoveScheduledEvent", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__RemoveScheduledEvent::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__RemoveScheduledEvent(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__RemoveScheduledEvent * SOAP_FMAC4 soap_get__ns1__RemoveScheduledEvent(struct soap *soap, _ns1__RemoveScheduledEvent *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__RemoveScheduledEvent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__AddScheduledEventResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__AddScheduledEventResponse::EventID = NULL;
	/* transient soap skipped */
}

void _ns1__AddScheduledEventResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__AddScheduledEventResponse::EventID);
#endif
}

int _ns1__AddScheduledEventResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__AddScheduledEventResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__AddScheduledEventResponse(struct soap *soap, const char *tag, int id, const _ns1__AddScheduledEventResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__AddScheduledEventResponse), type))
		return soap->error;
	if (a->EventID)
		soap_element_result(soap, "ns1:EventID");
	if (soap_out_PointerTostd__string(soap, "ns1:EventID", -1, &a->_ns1__AddScheduledEventResponse::EventID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__AddScheduledEventResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__AddScheduledEventResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__AddScheduledEventResponse * SOAP_FMAC4 soap_in__ns1__AddScheduledEventResponse(struct soap *soap, const char *tag, _ns1__AddScheduledEventResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__AddScheduledEventResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__AddScheduledEventResponse, sizeof(_ns1__AddScheduledEventResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__AddScheduledEventResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__AddScheduledEventResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_EventID1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_EventID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:EventID", &a->_ns1__AddScheduledEventResponse::EventID, "xsd:string"))
				{	soap_flag_EventID1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:EventID");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__AddScheduledEventResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__AddScheduledEventResponse, SOAP_TYPE__ns1__AddScheduledEventResponse, sizeof(_ns1__AddScheduledEventResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__AddScheduledEventResponse * SOAP_FMAC2 soap_instantiate__ns1__AddScheduledEventResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__AddScheduledEventResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__AddScheduledEventResponse *p;
	size_t k = sizeof(_ns1__AddScheduledEventResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__AddScheduledEventResponse);
		if (p)
			((_ns1__AddScheduledEventResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__AddScheduledEventResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__AddScheduledEventResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__AddScheduledEventResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__AddScheduledEventResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__AddScheduledEventResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__AddScheduledEventResponse(soap, tag ? tag : "ns1:AddScheduledEventResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__AddScheduledEventResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__AddScheduledEventResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__AddScheduledEventResponse * SOAP_FMAC4 soap_get__ns1__AddScheduledEventResponse(struct soap *soap, _ns1__AddScheduledEventResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__AddScheduledEventResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__AddScheduledEvent::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__AddScheduledEvent::NewScheduledEvent = NULL;
	/* transient soap skipped */
}

void _ns1__AddScheduledEvent::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__NewScheduledEvent(soap, &this->_ns1__AddScheduledEvent::NewScheduledEvent);
#endif
}

int _ns1__AddScheduledEvent::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__AddScheduledEvent(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__AddScheduledEvent(struct soap *soap, const char *tag, int id, const _ns1__AddScheduledEvent *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__AddScheduledEvent), type))
		return soap->error;
	if (!a->_ns1__AddScheduledEvent::NewScheduledEvent)
	{	if (soap_element_empty(soap, "ns1:NewScheduledEvent"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons1__NewScheduledEvent(soap, "ns1:NewScheduledEvent", -1, &a->_ns1__AddScheduledEvent::NewScheduledEvent, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__AddScheduledEvent::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__AddScheduledEvent(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__AddScheduledEvent * SOAP_FMAC4 soap_in__ns1__AddScheduledEvent(struct soap *soap, const char *tag, _ns1__AddScheduledEvent *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__AddScheduledEvent *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__AddScheduledEvent, sizeof(_ns1__AddScheduledEvent), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__AddScheduledEvent)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__AddScheduledEvent *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_NewScheduledEvent1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_NewScheduledEvent1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__NewScheduledEvent(soap, "ns1:NewScheduledEvent", &a->_ns1__AddScheduledEvent::NewScheduledEvent, "ns1:NewScheduledEvent"))
				{	soap_flag_NewScheduledEvent1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_ns1__AddScheduledEvent::NewScheduledEvent))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__AddScheduledEvent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__AddScheduledEvent, SOAP_TYPE__ns1__AddScheduledEvent, sizeof(_ns1__AddScheduledEvent), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__AddScheduledEvent * SOAP_FMAC2 soap_instantiate__ns1__AddScheduledEvent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__AddScheduledEvent(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__AddScheduledEvent *p;
	size_t k = sizeof(_ns1__AddScheduledEvent);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__AddScheduledEvent);
		if (p)
			((_ns1__AddScheduledEvent*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__AddScheduledEvent, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__AddScheduledEvent*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__AddScheduledEvent location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__AddScheduledEvent, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__AddScheduledEvent::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__AddScheduledEvent(soap, tag ? tag : "ns1:AddScheduledEvent", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__AddScheduledEvent::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__AddScheduledEvent(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__AddScheduledEvent * SOAP_FMAC4 soap_get__ns1__AddScheduledEvent(struct soap *soap, _ns1__AddScheduledEvent *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__AddScheduledEvent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetEventInstancesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetEventInstancesResponse::ns2__TopicSet = NULL;
	/* transient soap skipped */
}

void _ns1__GetEventInstancesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__TopicSetType(soap, &this->_ns1__GetEventInstancesResponse::ns2__TopicSet);
#endif
}

int _ns1__GetEventInstancesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetEventInstancesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetEventInstancesResponse(struct soap *soap, const char *tag, int id, const _ns1__GetEventInstancesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetEventInstancesResponse), type))
		return soap->error;
	if (a->ns2__TopicSet)
		soap_element_result(soap, "ns2:TopicSet");
	if (!a->_ns1__GetEventInstancesResponse::ns2__TopicSet)
	{	if (soap_element_empty(soap, "ns2:TopicSet"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons2__TopicSetType(soap, "ns2:TopicSet", -1, &a->_ns1__GetEventInstancesResponse::ns2__TopicSet, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetEventInstancesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetEventInstancesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetEventInstancesResponse * SOAP_FMAC4 soap_in__ns1__GetEventInstancesResponse(struct soap *soap, const char *tag, _ns1__GetEventInstancesResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetEventInstancesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetEventInstancesResponse, sizeof(_ns1__GetEventInstancesResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetEventInstancesResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetEventInstancesResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ns2__TopicSet1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__TopicSet1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__TopicSetType(soap, "ns2:TopicSet", &a->_ns1__GetEventInstancesResponse::ns2__TopicSet, "ns2:TopicSetType"))
				{	soap_flag_ns2__TopicSet1--;
					continue;
				}
			}
			soap_check_result(soap, "ns2:TopicSet");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_ns1__GetEventInstancesResponse::ns2__TopicSet))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__GetEventInstancesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetEventInstancesResponse, SOAP_TYPE__ns1__GetEventInstancesResponse, sizeof(_ns1__GetEventInstancesResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetEventInstancesResponse * SOAP_FMAC2 soap_instantiate__ns1__GetEventInstancesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetEventInstancesResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetEventInstancesResponse *p;
	size_t k = sizeof(_ns1__GetEventInstancesResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetEventInstancesResponse);
		if (p)
			((_ns1__GetEventInstancesResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetEventInstancesResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetEventInstancesResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetEventInstancesResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetEventInstancesResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetEventInstancesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetEventInstancesResponse(soap, tag ? tag : "ns1:GetEventInstancesResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetEventInstancesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetEventInstancesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetEventInstancesResponse * SOAP_FMAC4 soap_get__ns1__GetEventInstancesResponse(struct soap *soap, _ns1__GetEventInstancesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetEventInstancesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetEventInstances::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns1__GetEventInstances::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__GetEventInstances::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetEventInstances(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetEventInstances(struct soap *soap, const char *tag, int id, const _ns1__GetEventInstances *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetEventInstances), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetEventInstances::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetEventInstances(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetEventInstances * SOAP_FMAC4 soap_in__ns1__GetEventInstances(struct soap *soap, const char *tag, _ns1__GetEventInstances *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetEventInstances *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetEventInstances, sizeof(_ns1__GetEventInstances), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetEventInstances)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetEventInstances *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetEventInstances *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetEventInstances, SOAP_TYPE__ns1__GetEventInstances, sizeof(_ns1__GetEventInstances), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetEventInstances * SOAP_FMAC2 soap_instantiate__ns1__GetEventInstances(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetEventInstances(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetEventInstances *p;
	size_t k = sizeof(_ns1__GetEventInstances);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetEventInstances);
		if (p)
			((_ns1__GetEventInstances*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetEventInstances, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetEventInstances*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetEventInstances location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetEventInstances, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetEventInstances::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetEventInstances(soap, tag ? tag : "ns1:GetEventInstances", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetEventInstances::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetEventInstances(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetEventInstances * SOAP_FMAC4 soap_get__ns1__GetEventInstances(struct soap *soap, _ns1__GetEventInstances *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetEventInstances(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__ScheduleFilter::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns1__ScheduleFilter::ScheduleType = NULL;
}

void ns1__ScheduleFilter::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ScheduledType(soap, &this->ns1__ScheduleFilter::ScheduleType);
#endif
}

int ns1__ScheduleFilter::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ScheduleFilter(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ScheduleFilter(struct soap *soap, const char *tag, int id, const ns1__ScheduleFilter *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ScheduleFilter), type))
		return soap->error;
	if (soap_out_PointerTons1__ScheduledType(soap, "ns1:ScheduleType", -1, &a->ns1__ScheduleFilter::ScheduleType, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__ScheduleFilter::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ScheduleFilter(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ScheduleFilter * SOAP_FMAC4 soap_in_ns1__ScheduleFilter(struct soap *soap, const char *tag, ns1__ScheduleFilter *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ScheduleFilter *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ScheduleFilter, sizeof(ns1__ScheduleFilter), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__ScheduleFilter)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__ScheduleFilter *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_ScheduleType1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ScheduleType1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ScheduledType(soap, "ns1:ScheduleType", &a->ns1__ScheduleFilter::ScheduleType, "ns1:ScheduledType"))
				{	soap_flag_ScheduleType1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ScheduleFilter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ScheduleFilter, SOAP_TYPE_ns1__ScheduleFilter, sizeof(ns1__ScheduleFilter), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__ScheduleFilter * SOAP_FMAC2 soap_instantiate_ns1__ScheduleFilter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ScheduleFilter(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__ScheduleFilter *p;
	size_t k = sizeof(ns1__ScheduleFilter);
	if (n < 0)
	{	p = SOAP_NEW(ns1__ScheduleFilter);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns1__ScheduleFilter, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__ScheduleFilter location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__ScheduleFilter, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns1__ScheduleFilter::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__ScheduleFilter(soap, tag ? tag : "ns1:ScheduleFilter", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ScheduleFilter::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ScheduleFilter(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ScheduleFilter * SOAP_FMAC4 soap_get_ns1__ScheduleFilter(struct soap *soap, ns1__ScheduleFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ScheduleFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__ICalendar::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__string(soap, &this->ns1__ICalendar::__item);
	this->ns1__ICalendar::Dialect = "http://www.axis.com/vapix/ws/ical1";
}

void ns1__ICalendar::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__ICalendar::__item, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__ICalendar::__item);
#endif
}

int ns1__ICalendar::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ICalendar(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ICalendar(struct soap *soap, const char *tag, int id, const ns1__ICalendar *a, const char *type)
{
	soap_set_attr(soap, "Dialect", soap_xsd__anyURI2s(soap, ((ns1__ICalendar*)a)->Dialect), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_std__string(soap, tag, id, &a->ns1__ICalendar::__item, "");
}

void *ns1__ICalendar::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ICalendar(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ICalendar * SOAP_FMAC4 soap_in_ns1__ICalendar(struct soap *soap, const char *tag, ns1__ICalendar *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns1__ICalendar *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ICalendar, sizeof(ns1__ICalendar), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__ICalendar)
		return (ns1__ICalendar *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "Dialect", 4, 0), &((ns1__ICalendar*)a)->Dialect))
		return NULL;
	if (!soap_in_std__string(soap, tag, &a->ns1__ICalendar::__item, "ns1:ICalendar"))
		return NULL;
	return a;
}

SOAP_FMAC1 ns1__ICalendar * SOAP_FMAC2 soap_instantiate_ns1__ICalendar(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ICalendar(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__ICalendar *p;
	size_t k = sizeof(ns1__ICalendar);
	if (n < 0)
	{	p = SOAP_NEW(ns1__ICalendar);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns1__ICalendar, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__ICalendar location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__ICalendar, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns1__ICalendar::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__ICalendar(soap, tag ? tag : "ns1:ICalendar", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ICalendar::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ICalendar(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ICalendar * SOAP_FMAC4 soap_get_ns1__ICalendar(struct soap *soap, ns1__ICalendar *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ICalendar(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__Schedule::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns1__Schedule::ICalendar = NULL;
}

void ns1__Schedule::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ICalendar(soap, &this->ns1__Schedule::ICalendar);
#endif
}

int ns1__Schedule::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Schedule(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Schedule(struct soap *soap, const char *tag, int id, const ns1__Schedule *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Schedule), type))
		return soap->error;
	if (!a->ns1__Schedule::ICalendar)
	{	if (soap_element_empty(soap, "ns1:ICalendar"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons1__ICalendar(soap, "ns1:ICalendar", -1, &a->ns1__Schedule::ICalendar, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__Schedule::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__Schedule(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Schedule * SOAP_FMAC4 soap_in_ns1__Schedule(struct soap *soap, const char *tag, ns1__Schedule *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__Schedule *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Schedule, sizeof(ns1__Schedule), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__Schedule)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__Schedule *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_ICalendar1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ICalendar1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ICalendar(soap, "ns1:ICalendar", &a->ns1__Schedule::ICalendar, "ns1:ICalendar"))
				{	soap_flag_ICalendar1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns1__Schedule::ICalendar))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__Schedule *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Schedule, SOAP_TYPE_ns1__Schedule, sizeof(ns1__Schedule), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__Schedule * SOAP_FMAC2 soap_instantiate_ns1__Schedule(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Schedule(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__Schedule *p;
	size_t k = sizeof(ns1__Schedule);
	if (n < 0)
	{	p = SOAP_NEW(ns1__Schedule);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns1__Schedule, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__Schedule location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__Schedule, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns1__Schedule::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__Schedule(soap, tag ? tag : "ns1:Schedule", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__Schedule::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Schedule(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Schedule * SOAP_FMAC4 soap_get_ns1__Schedule(struct soap *soap, ns1__Schedule *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Schedule(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__ScheduledEvent::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__string(soap, &this->ns1__ScheduledEvent::EventID);
	this->ns1__ScheduledEvent::Name = NULL;
	this->ns1__ScheduledEvent::Schedule = NULL;
}

void ns1__ScheduledEvent::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__ScheduledEvent::EventID, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__ScheduledEvent::EventID);
	soap_serialize_PointerTostd__string(soap, &this->ns1__ScheduledEvent::Name);
	soap_serialize_PointerTons1__Schedule(soap, &this->ns1__ScheduledEvent::Schedule);
#endif
}

int ns1__ScheduledEvent::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ScheduledEvent(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ScheduledEvent(struct soap *soap, const char *tag, int id, const ns1__ScheduledEvent *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ScheduledEvent), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:EventID", -1, &a->ns1__ScheduledEvent::EventID, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Name", -1, &a->ns1__ScheduledEvent::Name, ""))
		return soap->error;
	if (!a->ns1__ScheduledEvent::Schedule)
	{	if (soap_element_empty(soap, "ns1:Schedule"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons1__Schedule(soap, "ns1:Schedule", -1, &a->ns1__ScheduledEvent::Schedule, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__ScheduledEvent::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ScheduledEvent(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ScheduledEvent * SOAP_FMAC4 soap_in_ns1__ScheduledEvent(struct soap *soap, const char *tag, ns1__ScheduledEvent *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ScheduledEvent *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ScheduledEvent, sizeof(ns1__ScheduledEvent), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__ScheduledEvent)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__ScheduledEvent *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_EventID1 = 1;
	size_t soap_flag_Name1 = 1;
	size_t soap_flag_Schedule1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_EventID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:EventID", &a->ns1__ScheduledEvent::EventID, "xsd:string"))
				{	soap_flag_EventID1--;
					continue;
				}
			}
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Name", &a->ns1__ScheduledEvent::Name, "xsd:string"))
				{	soap_flag_Name1--;
					continue;
				}
			}
			if (soap_flag_Schedule1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__Schedule(soap, "ns1:Schedule", &a->ns1__ScheduledEvent::Schedule, "ns1:Schedule"))
				{	soap_flag_Schedule1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_EventID1 > 0 || !a->ns1__ScheduledEvent::Schedule))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__ScheduledEvent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ScheduledEvent, SOAP_TYPE_ns1__ScheduledEvent, sizeof(ns1__ScheduledEvent), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__ScheduledEvent * SOAP_FMAC2 soap_instantiate_ns1__ScheduledEvent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ScheduledEvent(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__ScheduledEvent *p;
	size_t k = sizeof(ns1__ScheduledEvent);
	if (n < 0)
	{	p = SOAP_NEW(ns1__ScheduledEvent);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns1__ScheduledEvent, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__ScheduledEvent location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__ScheduledEvent, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns1__ScheduledEvent::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__ScheduledEvent(soap, tag ? tag : "ns1:ScheduledEvent", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ScheduledEvent::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ScheduledEvent(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ScheduledEvent * SOAP_FMAC4 soap_get_ns1__ScheduledEvent(struct soap *soap, ns1__ScheduledEvent *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ScheduledEvent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__ScheduledEvents::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfPointerTons1__ScheduledEvent(soap, &this->ns1__ScheduledEvents::ScheduledEvent);
}

void ns1__ScheduledEvents::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons1__ScheduledEvent(soap, &this->ns1__ScheduledEvents::ScheduledEvent);
#endif
}

int ns1__ScheduledEvents::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ScheduledEvents(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ScheduledEvents(struct soap *soap, const char *tag, int id, const ns1__ScheduledEvents *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ScheduledEvents), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__ScheduledEvent(soap, "ns1:ScheduledEvent", -1, &a->ns1__ScheduledEvents::ScheduledEvent, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__ScheduledEvents::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ScheduledEvents(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ScheduledEvents * SOAP_FMAC4 soap_in_ns1__ScheduledEvents(struct soap *soap, const char *tag, ns1__ScheduledEvents *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ScheduledEvents *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ScheduledEvents, sizeof(ns1__ScheduledEvents), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__ScheduledEvents)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__ScheduledEvents *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons1__ScheduledEvent(soap, "ns1:ScheduledEvent", &a->ns1__ScheduledEvents::ScheduledEvent, "ns1:ScheduledEvent"))
					continue;
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ScheduledEvents *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ScheduledEvents, SOAP_TYPE_ns1__ScheduledEvents, sizeof(ns1__ScheduledEvents), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__ScheduledEvents * SOAP_FMAC2 soap_instantiate_ns1__ScheduledEvents(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ScheduledEvents(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__ScheduledEvents *p;
	size_t k = sizeof(ns1__ScheduledEvents);
	if (n < 0)
	{	p = SOAP_NEW(ns1__ScheduledEvents);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns1__ScheduledEvents, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__ScheduledEvents location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__ScheduledEvents, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns1__ScheduledEvents::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__ScheduledEvents(soap, tag ? tag : "ns1:ScheduledEvents", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ScheduledEvents::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ScheduledEvents(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ScheduledEvents * SOAP_FMAC4 soap_get_ns1__ScheduledEvents(struct soap *soap, ns1__ScheduledEvents *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ScheduledEvents(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__NewScheduledEvent::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns1__NewScheduledEvent::EventID = NULL;
	this->ns1__NewScheduledEvent::Name = NULL;
	this->ns1__NewScheduledEvent::Schedule = NULL;
}

void ns1__NewScheduledEvent::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns1__NewScheduledEvent::EventID);
	soap_serialize_PointerTostd__string(soap, &this->ns1__NewScheduledEvent::Name);
	soap_serialize_PointerTons1__Schedule(soap, &this->ns1__NewScheduledEvent::Schedule);
#endif
}

int ns1__NewScheduledEvent::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__NewScheduledEvent(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__NewScheduledEvent(struct soap *soap, const char *tag, int id, const ns1__NewScheduledEvent *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__NewScheduledEvent), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:EventID", -1, &a->ns1__NewScheduledEvent::EventID, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Name", -1, &a->ns1__NewScheduledEvent::Name, ""))
		return soap->error;
	if (!a->ns1__NewScheduledEvent::Schedule)
	{	if (soap_element_empty(soap, "ns1:Schedule"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons1__Schedule(soap, "ns1:Schedule", -1, &a->ns1__NewScheduledEvent::Schedule, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, NULL, -1, static_cast<const soap_dom_element*>(a), NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__NewScheduledEvent::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__NewScheduledEvent(soap, tag, this, type);
}

SOAP_FMAC3 ns1__NewScheduledEvent * SOAP_FMAC4 soap_in_ns1__NewScheduledEvent(struct soap *soap, const char *tag, ns1__NewScheduledEvent *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__NewScheduledEvent *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__NewScheduledEvent, sizeof(ns1__NewScheduledEvent), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__NewScheduledEvent)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__NewScheduledEvent *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap_dom_element = 1;
	size_t soap_flag_EventID1 = 1;
	size_t soap_flag_Name1 = 1;
	size_t soap_flag_Schedule1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_EventID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:EventID", &a->ns1__NewScheduledEvent::EventID, "xsd:string"))
				{	soap_flag_EventID1--;
					continue;
				}
			}
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Name", &a->ns1__NewScheduledEvent::Name, "xsd:string"))
				{	soap_flag_Name1--;
					continue;
				}
			}
			if (soap_flag_Schedule1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__Schedule(soap, "ns1:Schedule", &a->ns1__NewScheduledEvent::Schedule, "ns1:Schedule"))
				{	soap_flag_Schedule1--;
					continue;
				}
			}
			if (soap_flag_soap_dom_element && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, NULL, static_cast<soap_dom_element*>(a), NULL))
				{	soap_flag_soap_dom_element = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns1__NewScheduledEvent::Schedule))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__NewScheduledEvent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__NewScheduledEvent, SOAP_TYPE_ns1__NewScheduledEvent, sizeof(ns1__NewScheduledEvent), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__NewScheduledEvent * SOAP_FMAC2 soap_instantiate_ns1__NewScheduledEvent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__NewScheduledEvent(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__NewScheduledEvent *p;
	size_t k = sizeof(ns1__NewScheduledEvent);
	if (n < 0)
	{	p = SOAP_NEW(ns1__NewScheduledEvent);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns1__NewScheduledEvent, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__NewScheduledEvent location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__NewScheduledEvent, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns1__NewScheduledEvent::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__NewScheduledEvent(soap, tag ? tag : "ns1:NewScheduledEvent", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__NewScheduledEvent::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__NewScheduledEvent(soap, this, tag, type);
}

SOAP_FMAC3 ns1__NewScheduledEvent * SOAP_FMAC4 soap_get_ns1__NewScheduledEvent(struct soap *soap, ns1__NewScheduledEvent *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__NewScheduledEvent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xsd__unsignedLong::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_ULONG64(soap, &this->xsd__unsignedLong::__item);
}

void xsd__unsignedLong::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int xsd__unsignedLong::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__unsignedLong(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__unsignedLong(struct soap *soap, const char *tag, int id, const xsd__unsignedLong *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_ULONG64(soap, tag, id, &a->xsd__unsignedLong::__item, "");
}

void *xsd__unsignedLong::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__unsignedLong(soap, tag, this, type);
}

SOAP_FMAC3 xsd__unsignedLong * SOAP_FMAC4 soap_in_xsd__unsignedLong(struct soap *soap, const char *tag, xsd__unsignedLong *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__unsignedLong *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__unsignedLong, sizeof(xsd__unsignedLong), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_xsd__unsignedLong)
		return (xsd__unsignedLong *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_ULONG64(soap, tag, &a->xsd__unsignedLong::__item, "xsd:unsignedLong"))
		return NULL;
	return a;
}

SOAP_FMAC1 xsd__unsignedLong * SOAP_FMAC2 soap_instantiate_xsd__unsignedLong(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__unsignedLong(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xsd__unsignedLong *p;
	size_t k = sizeof(xsd__unsignedLong);
	if (n < 0)
	{	p = SOAP_NEW(xsd__unsignedLong);
	}
	else
	{	p = SOAP_NEW_ARRAY(xsd__unsignedLong, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xsd__unsignedLong location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_xsd__unsignedLong, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int xsd__unsignedLong::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xsd__unsignedLong(soap, tag ? tag : "xsd:unsignedLong", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__unsignedLong::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__unsignedLong(soap, this, tag, type);
}

SOAP_FMAC3 xsd__unsignedLong * SOAP_FMAC4 soap_get_xsd__unsignedLong(struct soap *soap, xsd__unsignedLong *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__unsignedLong(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xsd__token_::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__token(soap, &this->xsd__token_::__item);
}

void xsd__token_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__token(soap, &this->xsd__token_::__item);
#endif
}

int xsd__token_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__token_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__token_(struct soap *soap, const char *tag, int id, const xsd__token_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_xsd__token(soap, tag, id, &a->xsd__token_::__item, "");
}

void *xsd__token_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__token_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__token_ * SOAP_FMAC4 soap_in_xsd__token_(struct soap *soap, const char *tag, xsd__token_ *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__token_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__token_, sizeof(xsd__token_), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_xsd__token_)
		return (xsd__token_ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_xsd__token(soap, tag, &a->xsd__token_::__item, "xsd:token"))
		return NULL;
	return a;
}

SOAP_FMAC1 xsd__token_ * SOAP_FMAC2 soap_instantiate_xsd__token_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__token_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xsd__token_ *p;
	size_t k = sizeof(xsd__token_);
	if (n < 0)
	{	p = SOAP_NEW(xsd__token_);
	}
	else
	{	p = SOAP_NEW_ARRAY(xsd__token_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xsd__token_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_xsd__token_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int xsd__token_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xsd__token_(soap, tag ? tag : "xsd:token", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__token_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__token_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__token_ * SOAP_FMAC4 soap_get_xsd__token_(struct soap *soap, xsd__token_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__token_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__token(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__token(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__token), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__token(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__token, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 5, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__token, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_xsd__token, SOAP_TYPE_xsd__token, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__token(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_xsd__token(soap, tag ? tag : "xsd:token", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__token(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__token(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xsd__string::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__string(soap, &this->xsd__string::__item);
}

void xsd__string::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->xsd__string::__item, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->xsd__string::__item);
#endif
}

int xsd__string::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__string(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__string(struct soap *soap, const char *tag, int id, const xsd__string *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_std__string(soap, tag, id, &a->xsd__string::__item, "");
}

void *xsd__string::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__string(soap, tag, this, type);
}

SOAP_FMAC3 xsd__string * SOAP_FMAC4 soap_in_xsd__string(struct soap *soap, const char *tag, xsd__string *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__string *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__string, sizeof(xsd__string), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_xsd__string)
		return (xsd__string *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_std__string(soap, tag, &a->xsd__string::__item, "xsd:string"))
		return NULL;
	return a;
}

SOAP_FMAC1 xsd__string * SOAP_FMAC2 soap_instantiate_xsd__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__string(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xsd__string *p;
	size_t k = sizeof(xsd__string);
	if (n < 0)
	{	p = SOAP_NEW(xsd__string);
	}
	else
	{	p = SOAP_NEW_ARRAY(xsd__string, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xsd__string location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_xsd__string, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int xsd__string::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xsd__string(soap, tag ? tag : "xsd:string", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__string::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__string(soap, this, tag, type);
}

SOAP_FMAC3 xsd__string * SOAP_FMAC4 soap_get_xsd__string(struct soap *soap, xsd__string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xsd__nonNegativeInteger_::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__nonNegativeInteger(soap, &this->xsd__nonNegativeInteger_::__item);
}

void xsd__nonNegativeInteger_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->xsd__nonNegativeInteger_::__item, SOAP_TYPE_xsd__nonNegativeInteger);
	soap_serialize_xsd__nonNegativeInteger(soap, &this->xsd__nonNegativeInteger_::__item);
#endif
}

int xsd__nonNegativeInteger_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__nonNegativeInteger_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__nonNegativeInteger_(struct soap *soap, const char *tag, int id, const xsd__nonNegativeInteger_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_xsd__nonNegativeInteger(soap, tag, id, &a->xsd__nonNegativeInteger_::__item, "");
}

void *xsd__nonNegativeInteger_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__nonNegativeInteger_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__nonNegativeInteger_ * SOAP_FMAC4 soap_in_xsd__nonNegativeInteger_(struct soap *soap, const char *tag, xsd__nonNegativeInteger_ *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__nonNegativeInteger_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__nonNegativeInteger_, sizeof(xsd__nonNegativeInteger_), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_xsd__nonNegativeInteger_)
		return (xsd__nonNegativeInteger_ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_xsd__nonNegativeInteger(soap, tag, &a->xsd__nonNegativeInteger_::__item, "xsd:nonNegativeInteger"))
		return NULL;
	return a;
}

SOAP_FMAC1 xsd__nonNegativeInteger_ * SOAP_FMAC2 soap_instantiate_xsd__nonNegativeInteger_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__nonNegativeInteger_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xsd__nonNegativeInteger_ *p;
	size_t k = sizeof(xsd__nonNegativeInteger_);
	if (n < 0)
	{	p = SOAP_NEW(xsd__nonNegativeInteger_);
	}
	else
	{	p = SOAP_NEW_ARRAY(xsd__nonNegativeInteger_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xsd__nonNegativeInteger_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_xsd__nonNegativeInteger_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int xsd__nonNegativeInteger_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xsd__nonNegativeInteger_(soap, tag ? tag : "xsd:nonNegativeInteger", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__nonNegativeInteger_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__nonNegativeInteger_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__nonNegativeInteger_ * SOAP_FMAC4 soap_get_xsd__nonNegativeInteger_(struct soap *soap, xsd__nonNegativeInteger_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__nonNegativeInteger_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__nonNegativeInteger(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__nonNegativeInteger(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__nonNegativeInteger), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__nonNegativeInteger(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__nonNegativeInteger, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 5, 0, -1, "\\+?\\d+")))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__nonNegativeInteger, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_xsd__nonNegativeInteger, SOAP_TYPE_xsd__nonNegativeInteger, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__nonNegativeInteger(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_xsd__nonNegativeInteger(soap, tag ? tag : "xsd:nonNegativeInteger", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__nonNegativeInteger(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__nonNegativeInteger(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xsd__integer_::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__integer(soap, &this->xsd__integer_::__item);
}

void xsd__integer_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->xsd__integer_::__item, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &this->xsd__integer_::__item);
#endif
}

int xsd__integer_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__integer_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__integer_(struct soap *soap, const char *tag, int id, const xsd__integer_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_xsd__integer(soap, tag, id, &a->xsd__integer_::__item, "");
}

void *xsd__integer_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__integer_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__integer_ * SOAP_FMAC4 soap_in_xsd__integer_(struct soap *soap, const char *tag, xsd__integer_ *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__integer_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__integer_, sizeof(xsd__integer_), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_xsd__integer_)
		return (xsd__integer_ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_xsd__integer(soap, tag, &a->xsd__integer_::__item, "xsd:integer"))
		return NULL;
	return a;
}

SOAP_FMAC1 xsd__integer_ * SOAP_FMAC2 soap_instantiate_xsd__integer_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__integer_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xsd__integer_ *p;
	size_t k = sizeof(xsd__integer_);
	if (n < 0)
	{	p = SOAP_NEW(xsd__integer_);
	}
	else
	{	p = SOAP_NEW_ARRAY(xsd__integer_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xsd__integer_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_xsd__integer_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int xsd__integer_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xsd__integer_(soap, tag ? tag : "xsd:integer", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__integer_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__integer_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__integer_ * SOAP_FMAC4 soap_get_xsd__integer_(struct soap *soap, xsd__integer_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__integer_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__integer(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__integer(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__integer), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__integer(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__integer, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 5, 0, -1, "[-+]?\\d+")))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__integer, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_xsd__integer, SOAP_TYPE_xsd__integer, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__integer(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_xsd__integer(soap, tag ? tag : "xsd:integer", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__integer(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__integer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xsd__int::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_int(soap, &this->xsd__int::__item);
}

void xsd__int::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int xsd__int::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__int(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__int(struct soap *soap, const char *tag, int id, const xsd__int *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_int(soap, tag, id, &a->xsd__int::__item, "");
}

void *xsd__int::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__int(soap, tag, this, type);
}

SOAP_FMAC3 xsd__int * SOAP_FMAC4 soap_in_xsd__int(struct soap *soap, const char *tag, xsd__int *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__int *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__int, sizeof(xsd__int), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_xsd__int)
		return (xsd__int *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_int(soap, tag, &a->xsd__int::__item, "xsd:int"))
		return NULL;
	return a;
}

SOAP_FMAC1 xsd__int * SOAP_FMAC2 soap_instantiate_xsd__int(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__int(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xsd__int *p;
	size_t k = sizeof(xsd__int);
	if (n < 0)
	{	p = SOAP_NEW(xsd__int);
	}
	else
	{	p = SOAP_NEW_ARRAY(xsd__int, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xsd__int location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_xsd__int, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int xsd__int::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xsd__int(soap, tag ? tag : "xsd:int", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__int::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__int(soap, this, tag, type);
}

SOAP_FMAC3 xsd__int * SOAP_FMAC4 soap_get_xsd__int(struct soap *soap, xsd__int *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xsd__duration_::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__duration(soap, &this->xsd__duration_::__item);
}

void xsd__duration_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->xsd__duration_::__item, SOAP_TYPE_xsd__duration);
	soap_serialize_xsd__duration(soap, &this->xsd__duration_::__item);
#endif
}

int xsd__duration_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__duration_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__duration_(struct soap *soap, const char *tag, int id, const xsd__duration_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_xsd__duration(soap, tag, id, &a->xsd__duration_::__item, "");
}

void *xsd__duration_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__duration_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__duration_ * SOAP_FMAC4 soap_in_xsd__duration_(struct soap *soap, const char *tag, xsd__duration_ *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__duration_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__duration_, sizeof(xsd__duration_), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_xsd__duration_)
		return (xsd__duration_ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_xsd__duration(soap, tag, &a->xsd__duration_::__item, "xsd:duration"))
		return NULL;
	return a;
}

SOAP_FMAC1 xsd__duration_ * SOAP_FMAC2 soap_instantiate_xsd__duration_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__duration_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xsd__duration_ *p;
	size_t k = sizeof(xsd__duration_);
	if (n < 0)
	{	p = SOAP_NEW(xsd__duration_);
	}
	else
	{	p = SOAP_NEW_ARRAY(xsd__duration_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xsd__duration_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_xsd__duration_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int xsd__duration_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xsd__duration_(soap, tag ? tag : "xsd:duration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__duration_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__duration_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__duration_ * SOAP_FMAC4 soap_get_xsd__duration_(struct soap *soap, xsd__duration_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__duration_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__duration(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__duration(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__duration), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__duration(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__duration, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 5, 0, -1, "[-+]?P(\\d+Y)?(\\d+M)?(\\d+D)?(T(\\d+H)?(\\d+M)?(\\d+(\\.\\d*)?S)?)?")))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__duration, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_xsd__duration, SOAP_TYPE_xsd__duration, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__duration(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_xsd__duration(soap, tag ? tag : "xsd:duration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__duration(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__duration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xsd__dateTime::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_dateTime(soap, &this->xsd__dateTime::__item);
}

void xsd__dateTime::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->xsd__dateTime::__item, SOAP_TYPE_dateTime);
#endif
}

int xsd__dateTime::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__dateTime(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__dateTime(struct soap *soap, const char *tag, int id, const xsd__dateTime *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_dateTime(soap, tag, id, &a->xsd__dateTime::__item, "");
}

void *xsd__dateTime::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__dateTime(soap, tag, this, type);
}

SOAP_FMAC3 xsd__dateTime * SOAP_FMAC4 soap_in_xsd__dateTime(struct soap *soap, const char *tag, xsd__dateTime *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__dateTime *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__dateTime, sizeof(xsd__dateTime), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_xsd__dateTime)
		return (xsd__dateTime *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_dateTime(soap, tag, &a->xsd__dateTime::__item, "xsd:dateTime"))
		return NULL;
	return a;
}

SOAP_FMAC1 xsd__dateTime * SOAP_FMAC2 soap_instantiate_xsd__dateTime(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__dateTime(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xsd__dateTime *p;
	size_t k = sizeof(xsd__dateTime);
	if (n < 0)
	{	p = SOAP_NEW(xsd__dateTime);
	}
	else
	{	p = SOAP_NEW_ARRAY(xsd__dateTime, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xsd__dateTime location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_xsd__dateTime, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int xsd__dateTime::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xsd__dateTime(soap, tag ? tag : "xsd:dateTime", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__dateTime::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__dateTime(soap, this, tag, type);
}

SOAP_FMAC3 xsd__dateTime * SOAP_FMAC4 soap_get_xsd__dateTime(struct soap *soap, xsd__dateTime *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__dateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xsd__boolean::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_bool(soap, &this->xsd__boolean::__item);
}

void xsd__boolean::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->xsd__boolean::__item, SOAP_TYPE_bool);
#endif
}

int xsd__boolean::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__boolean(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__boolean(struct soap *soap, const char *tag, int id, const xsd__boolean *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_bool(soap, tag, id, &a->xsd__boolean::__item, "");
}

void *xsd__boolean::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__boolean(soap, tag, this, type);
}

SOAP_FMAC3 xsd__boolean * SOAP_FMAC4 soap_in_xsd__boolean(struct soap *soap, const char *tag, xsd__boolean *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__boolean *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__boolean, sizeof(xsd__boolean), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_xsd__boolean)
		return (xsd__boolean *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_bool(soap, tag, &a->xsd__boolean::__item, "xsd:boolean"))
		return NULL;
	return a;
}

SOAP_FMAC1 xsd__boolean * SOAP_FMAC2 soap_instantiate_xsd__boolean(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__boolean(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xsd__boolean *p;
	size_t k = sizeof(xsd__boolean);
	if (n < 0)
	{	p = SOAP_NEW(xsd__boolean);
	}
	else
	{	p = SOAP_NEW_ARRAY(xsd__boolean, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xsd__boolean location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_xsd__boolean, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int xsd__boolean::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xsd__boolean(soap, tag ? tag : "xsd:boolean", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__boolean::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__boolean(soap, this, tag, type);
}

SOAP_FMAC3 xsd__boolean * SOAP_FMAC4 soap_get_xsd__boolean(struct soap *soap, xsd__boolean *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__boolean(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xsd__anyURI_::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &this->xsd__anyURI_::__item);
}

void xsd__anyURI_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->xsd__anyURI_::__item, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->xsd__anyURI_::__item);
#endif
}

int xsd__anyURI_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__anyURI_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anyURI_(struct soap *soap, const char *tag, int id, const xsd__anyURI_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_xsd__anyURI(soap, tag, id, &a->xsd__anyURI_::__item, "");
}

void *xsd__anyURI_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__anyURI_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__anyURI_ * SOAP_FMAC4 soap_in_xsd__anyURI_(struct soap *soap, const char *tag, xsd__anyURI_ *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__anyURI_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__anyURI_, sizeof(xsd__anyURI_), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_xsd__anyURI_)
		return (xsd__anyURI_ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_xsd__anyURI(soap, tag, &a->xsd__anyURI_::__item, "xsd:anyURI"))
		return NULL;
	return a;
}

SOAP_FMAC1 xsd__anyURI_ * SOAP_FMAC2 soap_instantiate_xsd__anyURI_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__anyURI_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xsd__anyURI_ *p;
	size_t k = sizeof(xsd__anyURI_);
	if (n < 0)
	{	p = SOAP_NEW(xsd__anyURI_);
	}
	else
	{	p = SOAP_NEW_ARRAY(xsd__anyURI_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xsd__anyURI_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_xsd__anyURI_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int xsd__anyURI_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xsd__anyURI_(soap, tag ? tag : "xsd:anyURI", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__anyURI_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__anyURI_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__anyURI_ * SOAP_FMAC4 soap_get_xsd__anyURI_(struct soap *soap, xsd__anyURI_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anyURI_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__anyURI(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anyURI(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__anyURI), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__anyURI(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__anyURI, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 4, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__anyURI, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_xsd__anyURI, SOAP_TYPE_xsd__anyURI, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__anyURI(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_xsd__anyURI(soap, tag ? tag : "xsd:anyURI", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__anyURI(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anyURI(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xsd__QName_::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__QName(soap, &this->xsd__QName_::__item);
}

void xsd__QName_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->xsd__QName_::__item, SOAP_TYPE_xsd__QName);
	soap_serialize_xsd__QName(soap, &this->xsd__QName_::__item);
#endif
}

int xsd__QName_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__QName_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__QName_(struct soap *soap, const char *tag, int id, const xsd__QName_ *a, const char *type)
{
	std::string soap_tmp___item(soap_QName2s(soap, a->__item.c_str()));
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_xsd__QName(soap, tag, id, &soap_tmp___item, "");
}

void *xsd__QName_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__QName_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__QName_ * SOAP_FMAC4 soap_in_xsd__QName_(struct soap *soap, const char *tag, xsd__QName_ *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__QName_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__QName_, sizeof(xsd__QName_), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_xsd__QName_)
		return (xsd__QName_ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_xsd__QName(soap, tag, &a->xsd__QName_::__item, "xsd:QName"))
		return NULL;
	return a;
}

SOAP_FMAC1 xsd__QName_ * SOAP_FMAC2 soap_instantiate_xsd__QName_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__QName_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xsd__QName_ *p;
	size_t k = sizeof(xsd__QName_);
	if (n < 0)
	{	p = SOAP_NEW(xsd__QName_);
	}
	else
	{	p = SOAP_NEW_ARRAY(xsd__QName_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xsd__QName_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_xsd__QName_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int xsd__QName_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xsd__QName_(soap, tag ? tag : "xsd:QName", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__QName_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__QName_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__QName_ * SOAP_FMAC4 soap_get_xsd__QName_(struct soap *soap, xsd__QName_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__QName_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xsd__NCName_::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__NCName(soap, &this->xsd__NCName_::__item);
}

void xsd__NCName_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->xsd__NCName_::__item, SOAP_TYPE_xsd__NCName);
	soap_serialize_xsd__NCName(soap, &this->xsd__NCName_::__item);
#endif
}

int xsd__NCName_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__NCName_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__NCName_(struct soap *soap, const char *tag, int id, const xsd__NCName_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_xsd__NCName(soap, tag, id, &a->xsd__NCName_::__item, "");
}

void *xsd__NCName_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__NCName_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__NCName_ * SOAP_FMAC4 soap_in_xsd__NCName_(struct soap *soap, const char *tag, xsd__NCName_ *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__NCName_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__NCName_, sizeof(xsd__NCName_), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_xsd__NCName_)
		return (xsd__NCName_ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_xsd__NCName(soap, tag, &a->xsd__NCName_::__item, "xsd:NCName"))
		return NULL;
	return a;
}

SOAP_FMAC1 xsd__NCName_ * SOAP_FMAC2 soap_instantiate_xsd__NCName_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__NCName_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xsd__NCName_ *p;
	size_t k = sizeof(xsd__NCName_);
	if (n < 0)
	{	p = SOAP_NEW(xsd__NCName_);
	}
	else
	{	p = SOAP_NEW_ARRAY(xsd__NCName_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xsd__NCName_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_xsd__NCName_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int xsd__NCName_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xsd__NCName_(soap, tag ? tag : "xsd:NCName", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__NCName_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__NCName_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__NCName_ * SOAP_FMAC4 soap_get_xsd__NCName_(struct soap *soap, xsd__NCName_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__NCName_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__NCName(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__NCName(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__NCName), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__NCName(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__NCName, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 5, 0, -1, "[\\i-[:]][\\c-[:]]*")))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__NCName, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_xsd__NCName, SOAP_TYPE_xsd__NCName, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__NCName(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_xsd__NCName(soap, tag ? tag : "xsd:NCName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__NCName(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__NCName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__QName(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__QName(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__QName), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__QName(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__QName, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 2, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__QName, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_xsd__QName, SOAP_TYPE_xsd__QName, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_instantiate_xsd__QName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__QName(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::string *p;
	size_t k = sizeof(std::string);
	if (n < 0)
	{	p = SOAP_NEW(std::string);
	}
	else
	{	p = SOAP_NEW_ARRAY(std::string, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::string location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_xsd__QName, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__QName(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_xsd__QName(soap, tag ? tag : "xsd:QName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__QName(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_std__string, SOAP_TYPE_std__string, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::string *p;
	size_t k = sizeof(std::string);
	if (n < 0)
	{	p = SOAP_NEW(std::string);
	}
	else
	{	p = SOAP_NEW_ARRAY(std::string, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::string location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__string, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_std__string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->faultcode);
	soap_serialize_string(soap, (char*const*)&a->faultstring);
	soap_serialize_string(soap, (char*const*)&a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Node);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)(void*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, (char*const*)&a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, (char*const*)&a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, (char*const*)&a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, (char*const*)&a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__QName(soap, "faultcode", (char**)&a->faultcode, "xsd:QName"))
				{	soap_flag_faultcode--;
					continue;
				}
			}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "faultstring", (char**)&a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "faultactor", (char**)&a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Node", (char**)&a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Role", (char**)&a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Fault *p;
	size_t k = sizeof(struct SOAP_ENV__Fault);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Fault);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Fault, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Fault location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Fault(soap, tag ? tag : "SOAP-ENV:Fault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, (char*const*)&a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Text", (char**)&a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Reason *p;
	size_t k = sizeof(struct SOAP_ENV__Reason);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Reason);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Reason, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Reason location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)(void*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__QName(soap, "SOAP-ENV:Value", (char**)&a->SOAP_ENV__Value, "xsd:QName"))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Code *p;
	size_t k = sizeof(struct SOAP_ENV__Code);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Code);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Code, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Code location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Header *p;
	size_t k = sizeof(struct SOAP_ENV__Header);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Header);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Header, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Header location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Header(soap, tag ? tag : "SOAP-ENV:Header", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns5__RemoveActionRule(struct soap *soap, struct __ns5__RemoveActionRule *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns5__RemoveActionRule = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns5__RemoveActionRule(struct soap *soap, const struct __ns5__RemoveActionRule *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns5__RemoveActionRule(soap, &a->ns5__RemoveActionRule);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns5__RemoveActionRule(struct soap *soap, const char *tag, int id, const struct __ns5__RemoveActionRule *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns5__RemoveActionRule(soap, "ns5:RemoveActionRule", -1, &a->ns5__RemoveActionRule, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns5__RemoveActionRule * SOAP_FMAC4 soap_in___ns5__RemoveActionRule(struct soap *soap, const char *tag, struct __ns5__RemoveActionRule *a, const char *type)
{
	size_t soap_flag_ns5__RemoveActionRule = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns5__RemoveActionRule *)soap_id_enter(soap, "", a, SOAP_TYPE___ns5__RemoveActionRule, sizeof(struct __ns5__RemoveActionRule), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns5__RemoveActionRule(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns5__RemoveActionRule && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns5__RemoveActionRule(soap, "ns5:RemoveActionRule", &a->ns5__RemoveActionRule, ""))
				{	soap_flag_ns5__RemoveActionRule--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns5__RemoveActionRule * SOAP_FMAC2 soap_instantiate___ns5__RemoveActionRule(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns5__RemoveActionRule(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns5__RemoveActionRule *p;
	size_t k = sizeof(struct __ns5__RemoveActionRule);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns5__RemoveActionRule);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns5__RemoveActionRule, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns5__RemoveActionRule location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns5__RemoveActionRule, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns5__RemoveActionRule(struct soap *soap, const struct __ns5__RemoveActionRule *a, const char *tag, const char *type)
{
	if (soap_out___ns5__RemoveActionRule(soap, tag ? tag : "-ns5:RemoveActionRule", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns5__RemoveActionRule * SOAP_FMAC4 soap_get___ns5__RemoveActionRule(struct soap *soap, struct __ns5__RemoveActionRule *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns5__RemoveActionRule(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns5__GetActionRules(struct soap *soap, struct __ns5__GetActionRules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns5__GetActionRules = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns5__GetActionRules(struct soap *soap, const struct __ns5__GetActionRules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns5__GetActionRules(soap, &a->ns5__GetActionRules);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns5__GetActionRules(struct soap *soap, const char *tag, int id, const struct __ns5__GetActionRules *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns5__GetActionRules(soap, "ns5:GetActionRules", -1, &a->ns5__GetActionRules, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns5__GetActionRules * SOAP_FMAC4 soap_in___ns5__GetActionRules(struct soap *soap, const char *tag, struct __ns5__GetActionRules *a, const char *type)
{
	size_t soap_flag_ns5__GetActionRules = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns5__GetActionRules *)soap_id_enter(soap, "", a, SOAP_TYPE___ns5__GetActionRules, sizeof(struct __ns5__GetActionRules), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns5__GetActionRules(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns5__GetActionRules && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns5__GetActionRules(soap, "ns5:GetActionRules", &a->ns5__GetActionRules, ""))
				{	soap_flag_ns5__GetActionRules--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns5__GetActionRules * SOAP_FMAC2 soap_instantiate___ns5__GetActionRules(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns5__GetActionRules(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns5__GetActionRules *p;
	size_t k = sizeof(struct __ns5__GetActionRules);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns5__GetActionRules);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns5__GetActionRules, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns5__GetActionRules location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns5__GetActionRules, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns5__GetActionRules(struct soap *soap, const struct __ns5__GetActionRules *a, const char *tag, const char *type)
{
	if (soap_out___ns5__GetActionRules(soap, tag ? tag : "-ns5:GetActionRules", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns5__GetActionRules * SOAP_FMAC4 soap_get___ns5__GetActionRules(struct soap *soap, struct __ns5__GetActionRules *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns5__GetActionRules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns5__AddActionRule(struct soap *soap, struct __ns5__AddActionRule *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns5__AddActionRule = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns5__AddActionRule(struct soap *soap, const struct __ns5__AddActionRule *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns5__AddActionRule(soap, &a->ns5__AddActionRule);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns5__AddActionRule(struct soap *soap, const char *tag, int id, const struct __ns5__AddActionRule *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns5__AddActionRule(soap, "ns5:AddActionRule", -1, &a->ns5__AddActionRule, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns5__AddActionRule * SOAP_FMAC4 soap_in___ns5__AddActionRule(struct soap *soap, const char *tag, struct __ns5__AddActionRule *a, const char *type)
{
	size_t soap_flag_ns5__AddActionRule = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns5__AddActionRule *)soap_id_enter(soap, "", a, SOAP_TYPE___ns5__AddActionRule, sizeof(struct __ns5__AddActionRule), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns5__AddActionRule(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns5__AddActionRule && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns5__AddActionRule(soap, "ns5:AddActionRule", &a->ns5__AddActionRule, ""))
				{	soap_flag_ns5__AddActionRule--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns5__AddActionRule * SOAP_FMAC2 soap_instantiate___ns5__AddActionRule(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns5__AddActionRule(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns5__AddActionRule *p;
	size_t k = sizeof(struct __ns5__AddActionRule);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns5__AddActionRule);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns5__AddActionRule, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns5__AddActionRule location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns5__AddActionRule, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns5__AddActionRule(struct soap *soap, const struct __ns5__AddActionRule *a, const char *tag, const char *type)
{
	if (soap_out___ns5__AddActionRule(soap, tag ? tag : "-ns5:AddActionRule", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns5__AddActionRule * SOAP_FMAC4 soap_get___ns5__AddActionRule(struct soap *soap, struct __ns5__AddActionRule *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns5__AddActionRule(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns5__GetRecipientConfigurations(struct soap *soap, struct __ns5__GetRecipientConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns5__GetRecipientConfigurations = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns5__GetRecipientConfigurations(struct soap *soap, const struct __ns5__GetRecipientConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns5__GetRecipientConfigurations(soap, &a->ns5__GetRecipientConfigurations);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns5__GetRecipientConfigurations(struct soap *soap, const char *tag, int id, const struct __ns5__GetRecipientConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns5__GetRecipientConfigurations(soap, "ns5:GetRecipientConfigurations", -1, &a->ns5__GetRecipientConfigurations, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns5__GetRecipientConfigurations * SOAP_FMAC4 soap_in___ns5__GetRecipientConfigurations(struct soap *soap, const char *tag, struct __ns5__GetRecipientConfigurations *a, const char *type)
{
	size_t soap_flag_ns5__GetRecipientConfigurations = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns5__GetRecipientConfigurations *)soap_id_enter(soap, "", a, SOAP_TYPE___ns5__GetRecipientConfigurations, sizeof(struct __ns5__GetRecipientConfigurations), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns5__GetRecipientConfigurations(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns5__GetRecipientConfigurations && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns5__GetRecipientConfigurations(soap, "ns5:GetRecipientConfigurations", &a->ns5__GetRecipientConfigurations, ""))
				{	soap_flag_ns5__GetRecipientConfigurations--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns5__GetRecipientConfigurations * SOAP_FMAC2 soap_instantiate___ns5__GetRecipientConfigurations(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns5__GetRecipientConfigurations(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns5__GetRecipientConfigurations *p;
	size_t k = sizeof(struct __ns5__GetRecipientConfigurations);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns5__GetRecipientConfigurations);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns5__GetRecipientConfigurations, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns5__GetRecipientConfigurations location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns5__GetRecipientConfigurations, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns5__GetRecipientConfigurations(struct soap *soap, const struct __ns5__GetRecipientConfigurations *a, const char *tag, const char *type)
{
	if (soap_out___ns5__GetRecipientConfigurations(soap, tag ? tag : "-ns5:GetRecipientConfigurations", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns5__GetRecipientConfigurations * SOAP_FMAC4 soap_get___ns5__GetRecipientConfigurations(struct soap *soap, struct __ns5__GetRecipientConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns5__GetRecipientConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns5__RemoveRecipientConfiguration(struct soap *soap, struct __ns5__RemoveRecipientConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns5__RemoveRecipientConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns5__RemoveRecipientConfiguration(struct soap *soap, const struct __ns5__RemoveRecipientConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns5__RemoveRecipientConfiguration(soap, &a->ns5__RemoveRecipientConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns5__RemoveRecipientConfiguration(struct soap *soap, const char *tag, int id, const struct __ns5__RemoveRecipientConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns5__RemoveRecipientConfiguration(soap, "ns5:RemoveRecipientConfiguration", -1, &a->ns5__RemoveRecipientConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns5__RemoveRecipientConfiguration * SOAP_FMAC4 soap_in___ns5__RemoveRecipientConfiguration(struct soap *soap, const char *tag, struct __ns5__RemoveRecipientConfiguration *a, const char *type)
{
	size_t soap_flag_ns5__RemoveRecipientConfiguration = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns5__RemoveRecipientConfiguration *)soap_id_enter(soap, "", a, SOAP_TYPE___ns5__RemoveRecipientConfiguration, sizeof(struct __ns5__RemoveRecipientConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns5__RemoveRecipientConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns5__RemoveRecipientConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns5__RemoveRecipientConfiguration(soap, "ns5:RemoveRecipientConfiguration", &a->ns5__RemoveRecipientConfiguration, ""))
				{	soap_flag_ns5__RemoveRecipientConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns5__RemoveRecipientConfiguration * SOAP_FMAC2 soap_instantiate___ns5__RemoveRecipientConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns5__RemoveRecipientConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns5__RemoveRecipientConfiguration *p;
	size_t k = sizeof(struct __ns5__RemoveRecipientConfiguration);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns5__RemoveRecipientConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns5__RemoveRecipientConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns5__RemoveRecipientConfiguration location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns5__RemoveRecipientConfiguration, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns5__RemoveRecipientConfiguration(struct soap *soap, const struct __ns5__RemoveRecipientConfiguration *a, const char *tag, const char *type)
{
	if (soap_out___ns5__RemoveRecipientConfiguration(soap, tag ? tag : "-ns5:RemoveRecipientConfiguration", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns5__RemoveRecipientConfiguration * SOAP_FMAC4 soap_get___ns5__RemoveRecipientConfiguration(struct soap *soap, struct __ns5__RemoveRecipientConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns5__RemoveRecipientConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns5__AddRecipientConfiguration(struct soap *soap, struct __ns5__AddRecipientConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns5__AddRecipientConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns5__AddRecipientConfiguration(struct soap *soap, const struct __ns5__AddRecipientConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns5__AddRecipientConfiguration(soap, &a->ns5__AddRecipientConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns5__AddRecipientConfiguration(struct soap *soap, const char *tag, int id, const struct __ns5__AddRecipientConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns5__AddRecipientConfiguration(soap, "ns5:AddRecipientConfiguration", -1, &a->ns5__AddRecipientConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns5__AddRecipientConfiguration * SOAP_FMAC4 soap_in___ns5__AddRecipientConfiguration(struct soap *soap, const char *tag, struct __ns5__AddRecipientConfiguration *a, const char *type)
{
	size_t soap_flag_ns5__AddRecipientConfiguration = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns5__AddRecipientConfiguration *)soap_id_enter(soap, "", a, SOAP_TYPE___ns5__AddRecipientConfiguration, sizeof(struct __ns5__AddRecipientConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns5__AddRecipientConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns5__AddRecipientConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns5__AddRecipientConfiguration(soap, "ns5:AddRecipientConfiguration", &a->ns5__AddRecipientConfiguration, ""))
				{	soap_flag_ns5__AddRecipientConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns5__AddRecipientConfiguration * SOAP_FMAC2 soap_instantiate___ns5__AddRecipientConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns5__AddRecipientConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns5__AddRecipientConfiguration *p;
	size_t k = sizeof(struct __ns5__AddRecipientConfiguration);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns5__AddRecipientConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns5__AddRecipientConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns5__AddRecipientConfiguration location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns5__AddRecipientConfiguration, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns5__AddRecipientConfiguration(struct soap *soap, const struct __ns5__AddRecipientConfiguration *a, const char *tag, const char *type)
{
	if (soap_out___ns5__AddRecipientConfiguration(soap, tag ? tag : "-ns5:AddRecipientConfiguration", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns5__AddRecipientConfiguration * SOAP_FMAC4 soap_get___ns5__AddRecipientConfiguration(struct soap *soap, struct __ns5__AddRecipientConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns5__AddRecipientConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns5__GetRecipientTemplates(struct soap *soap, struct __ns5__GetRecipientTemplates *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns5__GetRecipientTemplates = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns5__GetRecipientTemplates(struct soap *soap, const struct __ns5__GetRecipientTemplates *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns5__GetRecipientTemplates(soap, &a->ns5__GetRecipientTemplates);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns5__GetRecipientTemplates(struct soap *soap, const char *tag, int id, const struct __ns5__GetRecipientTemplates *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns5__GetRecipientTemplates(soap, "ns5:GetRecipientTemplates", -1, &a->ns5__GetRecipientTemplates, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns5__GetRecipientTemplates * SOAP_FMAC4 soap_in___ns5__GetRecipientTemplates(struct soap *soap, const char *tag, struct __ns5__GetRecipientTemplates *a, const char *type)
{
	size_t soap_flag_ns5__GetRecipientTemplates = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns5__GetRecipientTemplates *)soap_id_enter(soap, "", a, SOAP_TYPE___ns5__GetRecipientTemplates, sizeof(struct __ns5__GetRecipientTemplates), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns5__GetRecipientTemplates(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns5__GetRecipientTemplates && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns5__GetRecipientTemplates(soap, "ns5:GetRecipientTemplates", &a->ns5__GetRecipientTemplates, ""))
				{	soap_flag_ns5__GetRecipientTemplates--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns5__GetRecipientTemplates * SOAP_FMAC2 soap_instantiate___ns5__GetRecipientTemplates(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns5__GetRecipientTemplates(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns5__GetRecipientTemplates *p;
	size_t k = sizeof(struct __ns5__GetRecipientTemplates);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns5__GetRecipientTemplates);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns5__GetRecipientTemplates, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns5__GetRecipientTemplates location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns5__GetRecipientTemplates, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns5__GetRecipientTemplates(struct soap *soap, const struct __ns5__GetRecipientTemplates *a, const char *tag, const char *type)
{
	if (soap_out___ns5__GetRecipientTemplates(soap, tag ? tag : "-ns5:GetRecipientTemplates", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns5__GetRecipientTemplates * SOAP_FMAC4 soap_get___ns5__GetRecipientTemplates(struct soap *soap, struct __ns5__GetRecipientTemplates *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns5__GetRecipientTemplates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns5__GetActionConfigurations(struct soap *soap, struct __ns5__GetActionConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns5__GetActionConfigurations = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns5__GetActionConfigurations(struct soap *soap, const struct __ns5__GetActionConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns5__GetActionConfigurations(soap, &a->ns5__GetActionConfigurations);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns5__GetActionConfigurations(struct soap *soap, const char *tag, int id, const struct __ns5__GetActionConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns5__GetActionConfigurations(soap, "ns5:GetActionConfigurations", -1, &a->ns5__GetActionConfigurations, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns5__GetActionConfigurations * SOAP_FMAC4 soap_in___ns5__GetActionConfigurations(struct soap *soap, const char *tag, struct __ns5__GetActionConfigurations *a, const char *type)
{
	size_t soap_flag_ns5__GetActionConfigurations = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns5__GetActionConfigurations *)soap_id_enter(soap, "", a, SOAP_TYPE___ns5__GetActionConfigurations, sizeof(struct __ns5__GetActionConfigurations), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns5__GetActionConfigurations(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns5__GetActionConfigurations && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns5__GetActionConfigurations(soap, "ns5:GetActionConfigurations", &a->ns5__GetActionConfigurations, ""))
				{	soap_flag_ns5__GetActionConfigurations--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns5__GetActionConfigurations * SOAP_FMAC2 soap_instantiate___ns5__GetActionConfigurations(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns5__GetActionConfigurations(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns5__GetActionConfigurations *p;
	size_t k = sizeof(struct __ns5__GetActionConfigurations);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns5__GetActionConfigurations);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns5__GetActionConfigurations, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns5__GetActionConfigurations location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns5__GetActionConfigurations, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns5__GetActionConfigurations(struct soap *soap, const struct __ns5__GetActionConfigurations *a, const char *tag, const char *type)
{
	if (soap_out___ns5__GetActionConfigurations(soap, tag ? tag : "-ns5:GetActionConfigurations", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns5__GetActionConfigurations * SOAP_FMAC4 soap_get___ns5__GetActionConfigurations(struct soap *soap, struct __ns5__GetActionConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns5__GetActionConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns5__RemoveActionConfiguration(struct soap *soap, struct __ns5__RemoveActionConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns5__RemoveActionConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns5__RemoveActionConfiguration(struct soap *soap, const struct __ns5__RemoveActionConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns5__RemoveActionConfiguration(soap, &a->ns5__RemoveActionConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns5__RemoveActionConfiguration(struct soap *soap, const char *tag, int id, const struct __ns5__RemoveActionConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns5__RemoveActionConfiguration(soap, "ns5:RemoveActionConfiguration", -1, &a->ns5__RemoveActionConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns5__RemoveActionConfiguration * SOAP_FMAC4 soap_in___ns5__RemoveActionConfiguration(struct soap *soap, const char *tag, struct __ns5__RemoveActionConfiguration *a, const char *type)
{
	size_t soap_flag_ns5__RemoveActionConfiguration = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns5__RemoveActionConfiguration *)soap_id_enter(soap, "", a, SOAP_TYPE___ns5__RemoveActionConfiguration, sizeof(struct __ns5__RemoveActionConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns5__RemoveActionConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns5__RemoveActionConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns5__RemoveActionConfiguration(soap, "ns5:RemoveActionConfiguration", &a->ns5__RemoveActionConfiguration, ""))
				{	soap_flag_ns5__RemoveActionConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns5__RemoveActionConfiguration * SOAP_FMAC2 soap_instantiate___ns5__RemoveActionConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns5__RemoveActionConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns5__RemoveActionConfiguration *p;
	size_t k = sizeof(struct __ns5__RemoveActionConfiguration);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns5__RemoveActionConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns5__RemoveActionConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns5__RemoveActionConfiguration location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns5__RemoveActionConfiguration, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns5__RemoveActionConfiguration(struct soap *soap, const struct __ns5__RemoveActionConfiguration *a, const char *tag, const char *type)
{
	if (soap_out___ns5__RemoveActionConfiguration(soap, tag ? tag : "-ns5:RemoveActionConfiguration", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns5__RemoveActionConfiguration * SOAP_FMAC4 soap_get___ns5__RemoveActionConfiguration(struct soap *soap, struct __ns5__RemoveActionConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns5__RemoveActionConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns5__AddActionConfiguration(struct soap *soap, struct __ns5__AddActionConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns5__AddActionConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns5__AddActionConfiguration(struct soap *soap, const struct __ns5__AddActionConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns5__AddActionConfiguration(soap, &a->ns5__AddActionConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns5__AddActionConfiguration(struct soap *soap, const char *tag, int id, const struct __ns5__AddActionConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns5__AddActionConfiguration(soap, "ns5:AddActionConfiguration", -1, &a->ns5__AddActionConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns5__AddActionConfiguration * SOAP_FMAC4 soap_in___ns5__AddActionConfiguration(struct soap *soap, const char *tag, struct __ns5__AddActionConfiguration *a, const char *type)
{
	size_t soap_flag_ns5__AddActionConfiguration = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns5__AddActionConfiguration *)soap_id_enter(soap, "", a, SOAP_TYPE___ns5__AddActionConfiguration, sizeof(struct __ns5__AddActionConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns5__AddActionConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns5__AddActionConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns5__AddActionConfiguration(soap, "ns5:AddActionConfiguration", &a->ns5__AddActionConfiguration, ""))
				{	soap_flag_ns5__AddActionConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns5__AddActionConfiguration * SOAP_FMAC2 soap_instantiate___ns5__AddActionConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns5__AddActionConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns5__AddActionConfiguration *p;
	size_t k = sizeof(struct __ns5__AddActionConfiguration);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns5__AddActionConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns5__AddActionConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns5__AddActionConfiguration location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns5__AddActionConfiguration, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns5__AddActionConfiguration(struct soap *soap, const struct __ns5__AddActionConfiguration *a, const char *tag, const char *type)
{
	if (soap_out___ns5__AddActionConfiguration(soap, tag ? tag : "-ns5:AddActionConfiguration", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns5__AddActionConfiguration * SOAP_FMAC4 soap_get___ns5__AddActionConfiguration(struct soap *soap, struct __ns5__AddActionConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns5__AddActionConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns5__GetActionTemplates(struct soap *soap, struct __ns5__GetActionTemplates *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns5__GetActionTemplates = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns5__GetActionTemplates(struct soap *soap, const struct __ns5__GetActionTemplates *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns5__GetActionTemplates(soap, &a->ns5__GetActionTemplates);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns5__GetActionTemplates(struct soap *soap, const char *tag, int id, const struct __ns5__GetActionTemplates *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns5__GetActionTemplates(soap, "ns5:GetActionTemplates", -1, &a->ns5__GetActionTemplates, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns5__GetActionTemplates * SOAP_FMAC4 soap_in___ns5__GetActionTemplates(struct soap *soap, const char *tag, struct __ns5__GetActionTemplates *a, const char *type)
{
	size_t soap_flag_ns5__GetActionTemplates = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns5__GetActionTemplates *)soap_id_enter(soap, "", a, SOAP_TYPE___ns5__GetActionTemplates, sizeof(struct __ns5__GetActionTemplates), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns5__GetActionTemplates(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns5__GetActionTemplates && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns5__GetActionTemplates(soap, "ns5:GetActionTemplates", &a->ns5__GetActionTemplates, ""))
				{	soap_flag_ns5__GetActionTemplates--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns5__GetActionTemplates * SOAP_FMAC2 soap_instantiate___ns5__GetActionTemplates(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns5__GetActionTemplates(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns5__GetActionTemplates *p;
	size_t k = sizeof(struct __ns5__GetActionTemplates);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns5__GetActionTemplates);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns5__GetActionTemplates, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns5__GetActionTemplates location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns5__GetActionTemplates, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns5__GetActionTemplates(struct soap *soap, const struct __ns5__GetActionTemplates *a, const char *tag, const char *type)
{
	if (soap_out___ns5__GetActionTemplates(soap, tag ? tag : "-ns5:GetActionTemplates", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns5__GetActionTemplates * SOAP_FMAC4 soap_get___ns5__GetActionTemplates(struct soap *soap, struct __ns5__GetActionTemplates *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns5__GetActionTemplates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__ChangeVirtualInputState(struct soap *soap, struct __ns1__ChangeVirtualInputState *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__ChangeVirtualInputState = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__ChangeVirtualInputState(struct soap *soap, const struct __ns1__ChangeVirtualInputState *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__ChangeVirtualInputState(soap, &a->ns1__ChangeVirtualInputState);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__ChangeVirtualInputState(struct soap *soap, const char *tag, int id, const struct __ns1__ChangeVirtualInputState *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__ChangeVirtualInputState(soap, "ns1:ChangeVirtualInputState", -1, &a->ns1__ChangeVirtualInputState, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ChangeVirtualInputState * SOAP_FMAC4 soap_in___ns1__ChangeVirtualInputState(struct soap *soap, const char *tag, struct __ns1__ChangeVirtualInputState *a, const char *type)
{
	size_t soap_flag_ns1__ChangeVirtualInputState = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__ChangeVirtualInputState *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__ChangeVirtualInputState, sizeof(struct __ns1__ChangeVirtualInputState), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__ChangeVirtualInputState(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__ChangeVirtualInputState && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__ChangeVirtualInputState(soap, "ns1:ChangeVirtualInputState", &a->ns1__ChangeVirtualInputState, ""))
				{	soap_flag_ns1__ChangeVirtualInputState--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__ChangeVirtualInputState * SOAP_FMAC2 soap_instantiate___ns1__ChangeVirtualInputState(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__ChangeVirtualInputState(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__ChangeVirtualInputState *p;
	size_t k = sizeof(struct __ns1__ChangeVirtualInputState);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__ChangeVirtualInputState);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__ChangeVirtualInputState, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__ChangeVirtualInputState location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__ChangeVirtualInputState, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__ChangeVirtualInputState(struct soap *soap, const struct __ns1__ChangeVirtualInputState *a, const char *tag, const char *type)
{
	if (soap_out___ns1__ChangeVirtualInputState(soap, tag ? tag : "-ns1:ChangeVirtualInputState", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ChangeVirtualInputState * SOAP_FMAC4 soap_get___ns1__ChangeVirtualInputState(struct soap *soap, struct __ns1__ChangeVirtualInputState *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__ChangeVirtualInputState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetScheduledEvents(struct soap *soap, struct __ns1__GetScheduledEvents *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetScheduledEvents = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetScheduledEvents(struct soap *soap, const struct __ns1__GetScheduledEvents *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetScheduledEvents(soap, &a->ns1__GetScheduledEvents);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetScheduledEvents(struct soap *soap, const char *tag, int id, const struct __ns1__GetScheduledEvents *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetScheduledEvents(soap, "ns1:GetScheduledEvents", -1, &a->ns1__GetScheduledEvents, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetScheduledEvents * SOAP_FMAC4 soap_in___ns1__GetScheduledEvents(struct soap *soap, const char *tag, struct __ns1__GetScheduledEvents *a, const char *type)
{
	size_t soap_flag_ns1__GetScheduledEvents = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetScheduledEvents *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetScheduledEvents, sizeof(struct __ns1__GetScheduledEvents), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetScheduledEvents(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetScheduledEvents && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetScheduledEvents(soap, "ns1:GetScheduledEvents", &a->ns1__GetScheduledEvents, ""))
				{	soap_flag_ns1__GetScheduledEvents--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetScheduledEvents * SOAP_FMAC2 soap_instantiate___ns1__GetScheduledEvents(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetScheduledEvents(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetScheduledEvents *p;
	size_t k = sizeof(struct __ns1__GetScheduledEvents);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__GetScheduledEvents);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__GetScheduledEvents, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetScheduledEvents location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__GetScheduledEvents, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetScheduledEvents(struct soap *soap, const struct __ns1__GetScheduledEvents *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetScheduledEvents(soap, tag ? tag : "-ns1:GetScheduledEvents", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetScheduledEvents * SOAP_FMAC4 soap_get___ns1__GetScheduledEvents(struct soap *soap, struct __ns1__GetScheduledEvents *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetScheduledEvents(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__RemoveScheduledEvent(struct soap *soap, struct __ns1__RemoveScheduledEvent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__RemoveScheduledEvent = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__RemoveScheduledEvent(struct soap *soap, const struct __ns1__RemoveScheduledEvent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__RemoveScheduledEvent(soap, &a->ns1__RemoveScheduledEvent);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__RemoveScheduledEvent(struct soap *soap, const char *tag, int id, const struct __ns1__RemoveScheduledEvent *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__RemoveScheduledEvent(soap, "ns1:RemoveScheduledEvent", -1, &a->ns1__RemoveScheduledEvent, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__RemoveScheduledEvent * SOAP_FMAC4 soap_in___ns1__RemoveScheduledEvent(struct soap *soap, const char *tag, struct __ns1__RemoveScheduledEvent *a, const char *type)
{
	size_t soap_flag_ns1__RemoveScheduledEvent = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__RemoveScheduledEvent *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__RemoveScheduledEvent, sizeof(struct __ns1__RemoveScheduledEvent), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__RemoveScheduledEvent(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__RemoveScheduledEvent && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__RemoveScheduledEvent(soap, "ns1:RemoveScheduledEvent", &a->ns1__RemoveScheduledEvent, ""))
				{	soap_flag_ns1__RemoveScheduledEvent--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__RemoveScheduledEvent * SOAP_FMAC2 soap_instantiate___ns1__RemoveScheduledEvent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__RemoveScheduledEvent(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__RemoveScheduledEvent *p;
	size_t k = sizeof(struct __ns1__RemoveScheduledEvent);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__RemoveScheduledEvent);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__RemoveScheduledEvent, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__RemoveScheduledEvent location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__RemoveScheduledEvent, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__RemoveScheduledEvent(struct soap *soap, const struct __ns1__RemoveScheduledEvent *a, const char *tag, const char *type)
{
	if (soap_out___ns1__RemoveScheduledEvent(soap, tag ? tag : "-ns1:RemoveScheduledEvent", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__RemoveScheduledEvent * SOAP_FMAC4 soap_get___ns1__RemoveScheduledEvent(struct soap *soap, struct __ns1__RemoveScheduledEvent *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__RemoveScheduledEvent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__AddScheduledEvent(struct soap *soap, struct __ns1__AddScheduledEvent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__AddScheduledEvent = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__AddScheduledEvent(struct soap *soap, const struct __ns1__AddScheduledEvent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__AddScheduledEvent(soap, &a->ns1__AddScheduledEvent);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__AddScheduledEvent(struct soap *soap, const char *tag, int id, const struct __ns1__AddScheduledEvent *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__AddScheduledEvent(soap, "ns1:AddScheduledEvent", -1, &a->ns1__AddScheduledEvent, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__AddScheduledEvent * SOAP_FMAC4 soap_in___ns1__AddScheduledEvent(struct soap *soap, const char *tag, struct __ns1__AddScheduledEvent *a, const char *type)
{
	size_t soap_flag_ns1__AddScheduledEvent = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__AddScheduledEvent *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__AddScheduledEvent, sizeof(struct __ns1__AddScheduledEvent), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__AddScheduledEvent(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__AddScheduledEvent && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__AddScheduledEvent(soap, "ns1:AddScheduledEvent", &a->ns1__AddScheduledEvent, ""))
				{	soap_flag_ns1__AddScheduledEvent--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__AddScheduledEvent * SOAP_FMAC2 soap_instantiate___ns1__AddScheduledEvent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__AddScheduledEvent(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__AddScheduledEvent *p;
	size_t k = sizeof(struct __ns1__AddScheduledEvent);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__AddScheduledEvent);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__AddScheduledEvent, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__AddScheduledEvent location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__AddScheduledEvent, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__AddScheduledEvent(struct soap *soap, const struct __ns1__AddScheduledEvent *a, const char *tag, const char *type)
{
	if (soap_out___ns1__AddScheduledEvent(soap, tag ? tag : "-ns1:AddScheduledEvent", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__AddScheduledEvent * SOAP_FMAC4 soap_get___ns1__AddScheduledEvent(struct soap *soap, struct __ns1__AddScheduledEvent *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__AddScheduledEvent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetEventInstances(struct soap *soap, struct __ns1__GetEventInstances *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetEventInstances = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetEventInstances(struct soap *soap, const struct __ns1__GetEventInstances *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetEventInstances(soap, &a->ns1__GetEventInstances);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetEventInstances(struct soap *soap, const char *tag, int id, const struct __ns1__GetEventInstances *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetEventInstances(soap, "ns1:GetEventInstances", -1, &a->ns1__GetEventInstances, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetEventInstances * SOAP_FMAC4 soap_in___ns1__GetEventInstances(struct soap *soap, const char *tag, struct __ns1__GetEventInstances *a, const char *type)
{
	size_t soap_flag_ns1__GetEventInstances = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetEventInstances *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetEventInstances, sizeof(struct __ns1__GetEventInstances), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetEventInstances(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetEventInstances && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetEventInstances(soap, "ns1:GetEventInstances", &a->ns1__GetEventInstances, ""))
				{	soap_flag_ns1__GetEventInstances--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetEventInstances * SOAP_FMAC2 soap_instantiate___ns1__GetEventInstances(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetEventInstances(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetEventInstances *p;
	size_t k = sizeof(struct __ns1__GetEventInstances);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__GetEventInstances);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__GetEventInstances, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetEventInstances location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__GetEventInstances, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetEventInstances(struct soap *soap, const struct __ns1__GetEventInstances *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetEventInstances(soap, tag ? tag : "-ns1:GetEventInstances", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetEventInstances * SOAP_FMAC4 soap_get___ns1__GetEventInstances(struct soap *soap, struct __ns1__GetEventInstances *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetEventInstances(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
	a->ns1__InvalidScheduleFault = NULL;
	a->ns1__InvalidScheduledEventIDFault = NULL;
	a->ns1__ScheduledEventAlreadyExistsFault = NULL;
	a->ns1__ScheduledEventNotFoundFault = NULL;
	a->ns5__ActionConfigurationIsInUseFault = NULL;
	a->ns5__ActionConfigurationNotFoundFault = NULL;
	a->ns5__ActionRuleNotFoundFault = NULL;
	a->ns5__ActionTemplateNotFoundFault = NULL;
	a->ns5__InsufficientActivationRuleFault = NULL;
	a->ns5__InvalidActionConfigurationFault = NULL;
	a->ns5__InvalidActivationTimeoutFault = NULL;
	a->ns5__InvalidConditionFilterFault = NULL;
	a->ns3__InvalidFilterFault = NULL;
	a->ns3__InvalidMessageContentExpressionFault = NULL;
	a->ns3__InvalidTopicExpressionFault = NULL;
	a->ns5__ParametersMissmatchFault = NULL;
	a->ns5__RecipientConfigurationNotFoundFault = NULL;
	a->ns5__RecipientTemplateNotFoundFault = NULL;
	a->ns3__TopicExpressionDialectUnknownFault = NULL;
	a->__type = 0;
	a->fault = NULL;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__InvalidScheduleFault(soap, &a->ns1__InvalidScheduleFault);
	soap_serialize_PointerTo_ns1__InvalidScheduledEventIDFault(soap, &a->ns1__InvalidScheduledEventIDFault);
	soap_serialize_PointerTo_ns1__ScheduledEventAlreadyExistsFault(soap, &a->ns1__ScheduledEventAlreadyExistsFault);
	soap_serialize_PointerTo_ns1__ScheduledEventNotFoundFault(soap, &a->ns1__ScheduledEventNotFoundFault);
	soap_serialize_PointerTo_ns5__ActionConfigurationIsInUseFault(soap, &a->ns5__ActionConfigurationIsInUseFault);
	soap_serialize_PointerTo_ns5__ActionConfigurationNotFoundFault(soap, &a->ns5__ActionConfigurationNotFoundFault);
	soap_serialize_PointerTo_ns5__ActionRuleNotFoundFault(soap, &a->ns5__ActionRuleNotFoundFault);
	soap_serialize_PointerTo_ns5__ActionTemplateNotFoundFault(soap, &a->ns5__ActionTemplateNotFoundFault);
	soap_serialize_PointerTo_ns5__InsufficientActivationRuleFault(soap, &a->ns5__InsufficientActivationRuleFault);
	soap_serialize_PointerTo_ns5__InvalidActionConfigurationFault(soap, &a->ns5__InvalidActionConfigurationFault);
	soap_serialize_PointerTo_ns5__InvalidActivationTimeoutFault(soap, &a->ns5__InvalidActivationTimeoutFault);
	soap_serialize_PointerTo_ns5__InvalidConditionFilterFault(soap, &a->ns5__InvalidConditionFilterFault);
	soap_serialize_PointerTons3__InvalidFilterFaultType(soap, &a->ns3__InvalidFilterFault);
	soap_serialize_PointerTons3__InvalidMessageContentExpressionFaultType(soap, &a->ns3__InvalidMessageContentExpressionFault);
	soap_serialize_PointerTons3__InvalidTopicExpressionFaultType(soap, &a->ns3__InvalidTopicExpressionFault);
	soap_serialize_PointerTo_ns5__ParametersMissmatchFault(soap, &a->ns5__ParametersMissmatchFault);
	soap_serialize_PointerTo_ns5__RecipientConfigurationNotFoundFault(soap, &a->ns5__RecipientConfigurationNotFoundFault);
	soap_serialize_PointerTo_ns5__RecipientTemplateNotFoundFault(soap, &a->ns5__RecipientTemplateNotFoundFault);
	soap_serialize_PointerTons3__TopicExpressionDialectUnknownFaultType(soap, &a->ns3__TopicExpressionDialectUnknownFault);
	soap_markelement(soap, a->fault, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	if (soap_out_PointerTo_ns1__InvalidScheduleFault(soap, "ns1:InvalidScheduleFault", -1, &a->ns1__InvalidScheduleFault, ""))
		return soap->error;
	if (soap_out_PointerTo_ns1__InvalidScheduledEventIDFault(soap, "ns1:InvalidScheduledEventIDFault", -1, &a->ns1__InvalidScheduledEventIDFault, ""))
		return soap->error;
	if (soap_out_PointerTo_ns1__ScheduledEventAlreadyExistsFault(soap, "ns1:ScheduledEventAlreadyExistsFault", -1, &a->ns1__ScheduledEventAlreadyExistsFault, ""))
		return soap->error;
	if (soap_out_PointerTo_ns1__ScheduledEventNotFoundFault(soap, "ns1:ScheduledEventNotFoundFault", -1, &a->ns1__ScheduledEventNotFoundFault, ""))
		return soap->error;
	if (soap_out_PointerTo_ns5__ActionConfigurationIsInUseFault(soap, "ns5:ActionConfigurationIsInUseFault", -1, &a->ns5__ActionConfigurationIsInUseFault, ""))
		return soap->error;
	if (soap_out_PointerTo_ns5__ActionConfigurationNotFoundFault(soap, "ns5:ActionConfigurationNotFoundFault", -1, &a->ns5__ActionConfigurationNotFoundFault, ""))
		return soap->error;
	if (soap_out_PointerTo_ns5__ActionRuleNotFoundFault(soap, "ns5:ActionRuleNotFoundFault", -1, &a->ns5__ActionRuleNotFoundFault, ""))
		return soap->error;
	if (soap_out_PointerTo_ns5__ActionTemplateNotFoundFault(soap, "ns5:ActionTemplateNotFoundFault", -1, &a->ns5__ActionTemplateNotFoundFault, ""))
		return soap->error;
	if (soap_out_PointerTo_ns5__InsufficientActivationRuleFault(soap, "ns5:InsufficientActivationRuleFault", -1, &a->ns5__InsufficientActivationRuleFault, ""))
		return soap->error;
	if (soap_out_PointerTo_ns5__InvalidActionConfigurationFault(soap, "ns5:InvalidActionConfigurationFault", -1, &a->ns5__InvalidActionConfigurationFault, ""))
		return soap->error;
	if (soap_out_PointerTo_ns5__InvalidActivationTimeoutFault(soap, "ns5:InvalidActivationTimeoutFault", -1, &a->ns5__InvalidActivationTimeoutFault, ""))
		return soap->error;
	if (soap_out_PointerTo_ns5__InvalidConditionFilterFault(soap, "ns5:InvalidConditionFilterFault", -1, &a->ns5__InvalidConditionFilterFault, ""))
		return soap->error;
	if (soap_out_PointerTons3__InvalidFilterFaultType(soap, "ns3:InvalidFilterFault", -1, &a->ns3__InvalidFilterFault, ""))
		return soap->error;
	if (soap_out_PointerTons3__InvalidMessageContentExpressionFaultType(soap, "ns3:InvalidMessageContentExpressionFault", -1, &a->ns3__InvalidMessageContentExpressionFault, ""))
		return soap->error;
	if (soap_out_PointerTons3__InvalidTopicExpressionFaultType(soap, "ns3:InvalidTopicExpressionFault", -1, &a->ns3__InvalidTopicExpressionFault, ""))
		return soap->error;
	if (soap_out_PointerTo_ns5__ParametersMissmatchFault(soap, "ns5:ParametersMissmatchFault", -1, &a->ns5__ParametersMissmatchFault, ""))
		return soap->error;
	if (soap_out_PointerTo_ns5__RecipientConfigurationNotFoundFault(soap, "ns5:RecipientConfigurationNotFoundFault", -1, &a->ns5__RecipientConfigurationNotFoundFault, ""))
		return soap->error;
	if (soap_out_PointerTo_ns5__RecipientTemplateNotFoundFault(soap, "ns5:RecipientTemplateNotFoundFault", -1, &a->ns5__RecipientTemplateNotFoundFault, ""))
		return soap->error;
	if (soap_out_PointerTons3__TopicExpressionDialectUnknownFaultType(soap, "ns3:TopicExpressionDialectUnknownFault", -1, &a->ns3__TopicExpressionDialectUnknownFault, ""))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag_ns1__InvalidScheduleFault = 1;
	size_t soap_flag_ns1__InvalidScheduledEventIDFault = 1;
	size_t soap_flag_ns1__ScheduledEventAlreadyExistsFault = 1;
	size_t soap_flag_ns1__ScheduledEventNotFoundFault = 1;
	size_t soap_flag_ns5__ActionConfigurationIsInUseFault = 1;
	size_t soap_flag_ns5__ActionConfigurationNotFoundFault = 1;
	size_t soap_flag_ns5__ActionRuleNotFoundFault = 1;
	size_t soap_flag_ns5__ActionTemplateNotFoundFault = 1;
	size_t soap_flag_ns5__InsufficientActivationRuleFault = 1;
	size_t soap_flag_ns5__InvalidActionConfigurationFault = 1;
	size_t soap_flag_ns5__InvalidActivationTimeoutFault = 1;
	size_t soap_flag_ns5__InvalidConditionFilterFault = 1;
	size_t soap_flag_ns3__InvalidFilterFault = 1;
	size_t soap_flag_ns3__InvalidMessageContentExpressionFault = 1;
	size_t soap_flag_ns3__InvalidTopicExpressionFault = 1;
	size_t soap_flag_ns5__ParametersMissmatchFault = 1;
	size_t soap_flag_ns5__RecipientConfigurationNotFoundFault = 1;
	size_t soap_flag_ns5__RecipientTemplateNotFoundFault = 1;
	size_t soap_flag_ns3__TopicExpressionDialectUnknownFault = 1;
	size_t soap_flag_fault = 1;
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__InvalidScheduleFault && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__InvalidScheduleFault(soap, "ns1:InvalidScheduleFault", &a->ns1__InvalidScheduleFault, ""))
				{	soap_flag_ns1__InvalidScheduleFault--;
					continue;
				}
			}
			if (soap_flag_ns1__InvalidScheduledEventIDFault && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__InvalidScheduledEventIDFault(soap, "ns1:InvalidScheduledEventIDFault", &a->ns1__InvalidScheduledEventIDFault, ""))
				{	soap_flag_ns1__InvalidScheduledEventIDFault--;
					continue;
				}
			}
			if (soap_flag_ns1__ScheduledEventAlreadyExistsFault && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__ScheduledEventAlreadyExistsFault(soap, "ns1:ScheduledEventAlreadyExistsFault", &a->ns1__ScheduledEventAlreadyExistsFault, ""))
				{	soap_flag_ns1__ScheduledEventAlreadyExistsFault--;
					continue;
				}
			}
			if (soap_flag_ns1__ScheduledEventNotFoundFault && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__ScheduledEventNotFoundFault(soap, "ns1:ScheduledEventNotFoundFault", &a->ns1__ScheduledEventNotFoundFault, ""))
				{	soap_flag_ns1__ScheduledEventNotFoundFault--;
					continue;
				}
			}
			if (soap_flag_ns5__ActionConfigurationIsInUseFault && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns5__ActionConfigurationIsInUseFault(soap, "ns5:ActionConfigurationIsInUseFault", &a->ns5__ActionConfigurationIsInUseFault, ""))
				{	soap_flag_ns5__ActionConfigurationIsInUseFault--;
					continue;
				}
			}
			if (soap_flag_ns5__ActionConfigurationNotFoundFault && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns5__ActionConfigurationNotFoundFault(soap, "ns5:ActionConfigurationNotFoundFault", &a->ns5__ActionConfigurationNotFoundFault, ""))
				{	soap_flag_ns5__ActionConfigurationNotFoundFault--;
					continue;
				}
			}
			if (soap_flag_ns5__ActionRuleNotFoundFault && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns5__ActionRuleNotFoundFault(soap, "ns5:ActionRuleNotFoundFault", &a->ns5__ActionRuleNotFoundFault, ""))
				{	soap_flag_ns5__ActionRuleNotFoundFault--;
					continue;
				}
			}
			if (soap_flag_ns5__ActionTemplateNotFoundFault && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns5__ActionTemplateNotFoundFault(soap, "ns5:ActionTemplateNotFoundFault", &a->ns5__ActionTemplateNotFoundFault, ""))
				{	soap_flag_ns5__ActionTemplateNotFoundFault--;
					continue;
				}
			}
			if (soap_flag_ns5__InsufficientActivationRuleFault && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns5__InsufficientActivationRuleFault(soap, "ns5:InsufficientActivationRuleFault", &a->ns5__InsufficientActivationRuleFault, ""))
				{	soap_flag_ns5__InsufficientActivationRuleFault--;
					continue;
				}
			}
			if (soap_flag_ns5__InvalidActionConfigurationFault && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns5__InvalidActionConfigurationFault(soap, "ns5:InvalidActionConfigurationFault", &a->ns5__InvalidActionConfigurationFault, ""))
				{	soap_flag_ns5__InvalidActionConfigurationFault--;
					continue;
				}
			}
			if (soap_flag_ns5__InvalidActivationTimeoutFault && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns5__InvalidActivationTimeoutFault(soap, "ns5:InvalidActivationTimeoutFault", &a->ns5__InvalidActivationTimeoutFault, ""))
				{	soap_flag_ns5__InvalidActivationTimeoutFault--;
					continue;
				}
			}
			if (soap_flag_ns5__InvalidConditionFilterFault && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns5__InvalidConditionFilterFault(soap, "ns5:InvalidConditionFilterFault", &a->ns5__InvalidConditionFilterFault, ""))
				{	soap_flag_ns5__InvalidConditionFilterFault--;
					continue;
				}
			}
			if (soap_flag_ns3__InvalidFilterFault && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__InvalidFilterFaultType(soap, "ns3:InvalidFilterFault", &a->ns3__InvalidFilterFault, "ns3:InvalidFilterFaultType"))
				{	soap_flag_ns3__InvalidFilterFault--;
					continue;
				}
			}
			if (soap_flag_ns3__InvalidMessageContentExpressionFault && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__InvalidMessageContentExpressionFaultType(soap, "ns3:InvalidMessageContentExpressionFault", &a->ns3__InvalidMessageContentExpressionFault, "ns3:InvalidMessageContentExpressionFaultType"))
				{	soap_flag_ns3__InvalidMessageContentExpressionFault--;
					continue;
				}
			}
			if (soap_flag_ns3__InvalidTopicExpressionFault && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__InvalidTopicExpressionFaultType(soap, "ns3:InvalidTopicExpressionFault", &a->ns3__InvalidTopicExpressionFault, "ns3:InvalidTopicExpressionFaultType"))
				{	soap_flag_ns3__InvalidTopicExpressionFault--;
					continue;
				}
			}
			if (soap_flag_ns5__ParametersMissmatchFault && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns5__ParametersMissmatchFault(soap, "ns5:ParametersMissmatchFault", &a->ns5__ParametersMissmatchFault, ""))
				{	soap_flag_ns5__ParametersMissmatchFault--;
					continue;
				}
			}
			if (soap_flag_ns5__RecipientConfigurationNotFoundFault && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns5__RecipientConfigurationNotFoundFault(soap, "ns5:RecipientConfigurationNotFoundFault", &a->ns5__RecipientConfigurationNotFoundFault, ""))
				{	soap_flag_ns5__RecipientConfigurationNotFoundFault--;
					continue;
				}
			}
			if (soap_flag_ns5__RecipientTemplateNotFoundFault && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns5__RecipientTemplateNotFoundFault(soap, "ns5:RecipientTemplateNotFoundFault", &a->ns5__RecipientTemplateNotFoundFault, ""))
				{	soap_flag_ns5__RecipientTemplateNotFoundFault--;
					continue;
				}
			}
			if (soap_flag_ns3__TopicExpressionDialectUnknownFault && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__TopicExpressionDialectUnknownFaultType(soap, "ns3:TopicExpressionDialectUnknownFault", &a->ns3__TopicExpressionDialectUnknownFault, "ns3:TopicExpressionDialectUnknownFaultType"))
				{	soap_flag_ns3__TopicExpressionDialectUnknownFault--;
					continue;
				}
			}
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Detail *p;
	size_t k = sizeof(struct SOAP_ENV__Detail);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Detail);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Detail, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Detail location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC1 struct soap_dom_attribute * SOAP_FMAC2 soap_instantiate_xsd__anyAttribute(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__anyAttribute(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct soap_dom_attribute *p;
	size_t k = sizeof(struct soap_dom_attribute);
	if (n < 0)
	{	p = SOAP_NEW(struct soap_dom_attribute);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct soap_dom_attribute, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct soap_dom_attribute location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_xsd__anyAttribute, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__anyAttribute(struct soap *soap, const struct soap_dom_attribute *a, const char *tag, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, tag ? tag : "xsd:anyAttribute", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct soap_dom_attribute * SOAP_FMAC4 soap_get_xsd__anyAttribute(struct soap *soap, struct soap_dom_attribute *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anyAttribute(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct soap_dom_element * SOAP_FMAC2 soap_instantiate_xsd__anyType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__anyType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct soap_dom_element *p;
	size_t k = sizeof(struct soap_dom_element);
	if (n < 0)
	{	p = SOAP_NEW(struct soap_dom_element);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct soap_dom_element, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct soap_dom_element location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_xsd__anyType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__anyType(struct soap *soap, const struct soap_dom_element *a, const char *tag, const char *type)
{
	if (soap_out_xsd__anyType(soap, tag ? tag : "xsd:anyType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct soap_dom_element * SOAP_FMAC4 soap_get_xsd__anyType(struct soap *soap, struct soap_dom_element *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code, &mark);
	if (id < 0)
		return soap->error;
	soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns5__RemoveActionRule(struct soap *soap, _ns5__RemoveActionRule *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns5__RemoveActionRule))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns5__RemoveActionRule(struct soap *soap, const char *tag, int id, _ns5__RemoveActionRule *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns5__RemoveActionRule, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns5__RemoveActionRule ? type : NULL);
}

SOAP_FMAC3 _ns5__RemoveActionRule ** SOAP_FMAC4 soap_in_PointerTo_ns5__RemoveActionRule(struct soap *soap, const char *tag, _ns5__RemoveActionRule **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns5__RemoveActionRule **)soap_malloc(soap, sizeof(_ns5__RemoveActionRule *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns5__RemoveActionRule *)soap_instantiate__ns5__RemoveActionRule(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns5__RemoveActionRule **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__RemoveActionRule, sizeof(_ns5__RemoveActionRule), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns5__RemoveActionRule(struct soap *soap, _ns5__RemoveActionRule *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns5__RemoveActionRule(soap, tag ? tag : "ns5:RemoveActionRule", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns5__RemoveActionRule ** SOAP_FMAC4 soap_get_PointerTo_ns5__RemoveActionRule(struct soap *soap, _ns5__RemoveActionRule **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns5__RemoveActionRule(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns5__GetActionRules(struct soap *soap, _ns5__GetActionRules *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns5__GetActionRules))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns5__GetActionRules(struct soap *soap, const char *tag, int id, _ns5__GetActionRules *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns5__GetActionRules, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns5__GetActionRules ? type : NULL);
}

SOAP_FMAC3 _ns5__GetActionRules ** SOAP_FMAC4 soap_in_PointerTo_ns5__GetActionRules(struct soap *soap, const char *tag, _ns5__GetActionRules **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns5__GetActionRules **)soap_malloc(soap, sizeof(_ns5__GetActionRules *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns5__GetActionRules *)soap_instantiate__ns5__GetActionRules(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns5__GetActionRules **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__GetActionRules, sizeof(_ns5__GetActionRules), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns5__GetActionRules(struct soap *soap, _ns5__GetActionRules *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns5__GetActionRules(soap, tag ? tag : "ns5:GetActionRules", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns5__GetActionRules ** SOAP_FMAC4 soap_get_PointerTo_ns5__GetActionRules(struct soap *soap, _ns5__GetActionRules **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns5__GetActionRules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns5__AddActionRule(struct soap *soap, _ns5__AddActionRule *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns5__AddActionRule))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns5__AddActionRule(struct soap *soap, const char *tag, int id, _ns5__AddActionRule *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns5__AddActionRule, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns5__AddActionRule ? type : NULL);
}

SOAP_FMAC3 _ns5__AddActionRule ** SOAP_FMAC4 soap_in_PointerTo_ns5__AddActionRule(struct soap *soap, const char *tag, _ns5__AddActionRule **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns5__AddActionRule **)soap_malloc(soap, sizeof(_ns5__AddActionRule *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns5__AddActionRule *)soap_instantiate__ns5__AddActionRule(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns5__AddActionRule **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__AddActionRule, sizeof(_ns5__AddActionRule), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns5__AddActionRule(struct soap *soap, _ns5__AddActionRule *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns5__AddActionRule(soap, tag ? tag : "ns5:AddActionRule", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns5__AddActionRule ** SOAP_FMAC4 soap_get_PointerTo_ns5__AddActionRule(struct soap *soap, _ns5__AddActionRule **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns5__AddActionRule(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns5__GetRecipientConfigurations(struct soap *soap, _ns5__GetRecipientConfigurations *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns5__GetRecipientConfigurations))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns5__GetRecipientConfigurations(struct soap *soap, const char *tag, int id, _ns5__GetRecipientConfigurations *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns5__GetRecipientConfigurations, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns5__GetRecipientConfigurations ? type : NULL);
}

SOAP_FMAC3 _ns5__GetRecipientConfigurations ** SOAP_FMAC4 soap_in_PointerTo_ns5__GetRecipientConfigurations(struct soap *soap, const char *tag, _ns5__GetRecipientConfigurations **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns5__GetRecipientConfigurations **)soap_malloc(soap, sizeof(_ns5__GetRecipientConfigurations *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns5__GetRecipientConfigurations *)soap_instantiate__ns5__GetRecipientConfigurations(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns5__GetRecipientConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__GetRecipientConfigurations, sizeof(_ns5__GetRecipientConfigurations), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns5__GetRecipientConfigurations(struct soap *soap, _ns5__GetRecipientConfigurations *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns5__GetRecipientConfigurations(soap, tag ? tag : "ns5:GetRecipientConfigurations", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns5__GetRecipientConfigurations ** SOAP_FMAC4 soap_get_PointerTo_ns5__GetRecipientConfigurations(struct soap *soap, _ns5__GetRecipientConfigurations **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns5__GetRecipientConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns5__RemoveRecipientConfiguration(struct soap *soap, _ns5__RemoveRecipientConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns5__RemoveRecipientConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns5__RemoveRecipientConfiguration(struct soap *soap, const char *tag, int id, _ns5__RemoveRecipientConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns5__RemoveRecipientConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns5__RemoveRecipientConfiguration ? type : NULL);
}

SOAP_FMAC3 _ns5__RemoveRecipientConfiguration ** SOAP_FMAC4 soap_in_PointerTo_ns5__RemoveRecipientConfiguration(struct soap *soap, const char *tag, _ns5__RemoveRecipientConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns5__RemoveRecipientConfiguration **)soap_malloc(soap, sizeof(_ns5__RemoveRecipientConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns5__RemoveRecipientConfiguration *)soap_instantiate__ns5__RemoveRecipientConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns5__RemoveRecipientConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__RemoveRecipientConfiguration, sizeof(_ns5__RemoveRecipientConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns5__RemoveRecipientConfiguration(struct soap *soap, _ns5__RemoveRecipientConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns5__RemoveRecipientConfiguration(soap, tag ? tag : "ns5:RemoveRecipientConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns5__RemoveRecipientConfiguration ** SOAP_FMAC4 soap_get_PointerTo_ns5__RemoveRecipientConfiguration(struct soap *soap, _ns5__RemoveRecipientConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns5__RemoveRecipientConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns5__AddRecipientConfiguration(struct soap *soap, _ns5__AddRecipientConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns5__AddRecipientConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns5__AddRecipientConfiguration(struct soap *soap, const char *tag, int id, _ns5__AddRecipientConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns5__AddRecipientConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns5__AddRecipientConfiguration ? type : NULL);
}

SOAP_FMAC3 _ns5__AddRecipientConfiguration ** SOAP_FMAC4 soap_in_PointerTo_ns5__AddRecipientConfiguration(struct soap *soap, const char *tag, _ns5__AddRecipientConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns5__AddRecipientConfiguration **)soap_malloc(soap, sizeof(_ns5__AddRecipientConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns5__AddRecipientConfiguration *)soap_instantiate__ns5__AddRecipientConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns5__AddRecipientConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__AddRecipientConfiguration, sizeof(_ns5__AddRecipientConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns5__AddRecipientConfiguration(struct soap *soap, _ns5__AddRecipientConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns5__AddRecipientConfiguration(soap, tag ? tag : "ns5:AddRecipientConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns5__AddRecipientConfiguration ** SOAP_FMAC4 soap_get_PointerTo_ns5__AddRecipientConfiguration(struct soap *soap, _ns5__AddRecipientConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns5__AddRecipientConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns5__GetRecipientTemplates(struct soap *soap, _ns5__GetRecipientTemplates *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns5__GetRecipientTemplates))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns5__GetRecipientTemplates(struct soap *soap, const char *tag, int id, _ns5__GetRecipientTemplates *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns5__GetRecipientTemplates, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns5__GetRecipientTemplates ? type : NULL);
}

SOAP_FMAC3 _ns5__GetRecipientTemplates ** SOAP_FMAC4 soap_in_PointerTo_ns5__GetRecipientTemplates(struct soap *soap, const char *tag, _ns5__GetRecipientTemplates **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns5__GetRecipientTemplates **)soap_malloc(soap, sizeof(_ns5__GetRecipientTemplates *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns5__GetRecipientTemplates *)soap_instantiate__ns5__GetRecipientTemplates(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns5__GetRecipientTemplates **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__GetRecipientTemplates, sizeof(_ns5__GetRecipientTemplates), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns5__GetRecipientTemplates(struct soap *soap, _ns5__GetRecipientTemplates *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns5__GetRecipientTemplates(soap, tag ? tag : "ns5:GetRecipientTemplates", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns5__GetRecipientTemplates ** SOAP_FMAC4 soap_get_PointerTo_ns5__GetRecipientTemplates(struct soap *soap, _ns5__GetRecipientTemplates **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns5__GetRecipientTemplates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns5__GetActionConfigurations(struct soap *soap, _ns5__GetActionConfigurations *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns5__GetActionConfigurations))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns5__GetActionConfigurations(struct soap *soap, const char *tag, int id, _ns5__GetActionConfigurations *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns5__GetActionConfigurations, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns5__GetActionConfigurations ? type : NULL);
}

SOAP_FMAC3 _ns5__GetActionConfigurations ** SOAP_FMAC4 soap_in_PointerTo_ns5__GetActionConfigurations(struct soap *soap, const char *tag, _ns5__GetActionConfigurations **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns5__GetActionConfigurations **)soap_malloc(soap, sizeof(_ns5__GetActionConfigurations *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns5__GetActionConfigurations *)soap_instantiate__ns5__GetActionConfigurations(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns5__GetActionConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__GetActionConfigurations, sizeof(_ns5__GetActionConfigurations), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns5__GetActionConfigurations(struct soap *soap, _ns5__GetActionConfigurations *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns5__GetActionConfigurations(soap, tag ? tag : "ns5:GetActionConfigurations", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns5__GetActionConfigurations ** SOAP_FMAC4 soap_get_PointerTo_ns5__GetActionConfigurations(struct soap *soap, _ns5__GetActionConfigurations **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns5__GetActionConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns5__RemoveActionConfiguration(struct soap *soap, _ns5__RemoveActionConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns5__RemoveActionConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns5__RemoveActionConfiguration(struct soap *soap, const char *tag, int id, _ns5__RemoveActionConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns5__RemoveActionConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns5__RemoveActionConfiguration ? type : NULL);
}

SOAP_FMAC3 _ns5__RemoveActionConfiguration ** SOAP_FMAC4 soap_in_PointerTo_ns5__RemoveActionConfiguration(struct soap *soap, const char *tag, _ns5__RemoveActionConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns5__RemoveActionConfiguration **)soap_malloc(soap, sizeof(_ns5__RemoveActionConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns5__RemoveActionConfiguration *)soap_instantiate__ns5__RemoveActionConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns5__RemoveActionConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__RemoveActionConfiguration, sizeof(_ns5__RemoveActionConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns5__RemoveActionConfiguration(struct soap *soap, _ns5__RemoveActionConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns5__RemoveActionConfiguration(soap, tag ? tag : "ns5:RemoveActionConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns5__RemoveActionConfiguration ** SOAP_FMAC4 soap_get_PointerTo_ns5__RemoveActionConfiguration(struct soap *soap, _ns5__RemoveActionConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns5__RemoveActionConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns5__AddActionConfiguration(struct soap *soap, _ns5__AddActionConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns5__AddActionConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns5__AddActionConfiguration(struct soap *soap, const char *tag, int id, _ns5__AddActionConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns5__AddActionConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns5__AddActionConfiguration ? type : NULL);
}

SOAP_FMAC3 _ns5__AddActionConfiguration ** SOAP_FMAC4 soap_in_PointerTo_ns5__AddActionConfiguration(struct soap *soap, const char *tag, _ns5__AddActionConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns5__AddActionConfiguration **)soap_malloc(soap, sizeof(_ns5__AddActionConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns5__AddActionConfiguration *)soap_instantiate__ns5__AddActionConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns5__AddActionConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__AddActionConfiguration, sizeof(_ns5__AddActionConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns5__AddActionConfiguration(struct soap *soap, _ns5__AddActionConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns5__AddActionConfiguration(soap, tag ? tag : "ns5:AddActionConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns5__AddActionConfiguration ** SOAP_FMAC4 soap_get_PointerTo_ns5__AddActionConfiguration(struct soap *soap, _ns5__AddActionConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns5__AddActionConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns5__GetActionTemplates(struct soap *soap, _ns5__GetActionTemplates *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns5__GetActionTemplates))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns5__GetActionTemplates(struct soap *soap, const char *tag, int id, _ns5__GetActionTemplates *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns5__GetActionTemplates, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns5__GetActionTemplates ? type : NULL);
}

SOAP_FMAC3 _ns5__GetActionTemplates ** SOAP_FMAC4 soap_in_PointerTo_ns5__GetActionTemplates(struct soap *soap, const char *tag, _ns5__GetActionTemplates **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns5__GetActionTemplates **)soap_malloc(soap, sizeof(_ns5__GetActionTemplates *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns5__GetActionTemplates *)soap_instantiate__ns5__GetActionTemplates(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns5__GetActionTemplates **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__GetActionTemplates, sizeof(_ns5__GetActionTemplates), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns5__GetActionTemplates(struct soap *soap, _ns5__GetActionTemplates *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns5__GetActionTemplates(soap, tag ? tag : "ns5:GetActionTemplates", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns5__GetActionTemplates ** SOAP_FMAC4 soap_get_PointerTo_ns5__GetActionTemplates(struct soap *soap, _ns5__GetActionTemplates **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns5__GetActionTemplates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__ChangeVirtualInputState(struct soap *soap, _ns1__ChangeVirtualInputState *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__ChangeVirtualInputState))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__ChangeVirtualInputState(struct soap *soap, const char *tag, int id, _ns1__ChangeVirtualInputState *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__ChangeVirtualInputState, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__ChangeVirtualInputState ? type : NULL);
}

SOAP_FMAC3 _ns1__ChangeVirtualInputState ** SOAP_FMAC4 soap_in_PointerTo_ns1__ChangeVirtualInputState(struct soap *soap, const char *tag, _ns1__ChangeVirtualInputState **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__ChangeVirtualInputState **)soap_malloc(soap, sizeof(_ns1__ChangeVirtualInputState *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__ChangeVirtualInputState *)soap_instantiate__ns1__ChangeVirtualInputState(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__ChangeVirtualInputState **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__ChangeVirtualInputState, sizeof(_ns1__ChangeVirtualInputState), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__ChangeVirtualInputState(struct soap *soap, _ns1__ChangeVirtualInputState *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__ChangeVirtualInputState(soap, tag ? tag : "ns1:ChangeVirtualInputState", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__ChangeVirtualInputState ** SOAP_FMAC4 soap_get_PointerTo_ns1__ChangeVirtualInputState(struct soap *soap, _ns1__ChangeVirtualInputState **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__ChangeVirtualInputState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetScheduledEvents(struct soap *soap, _ns1__GetScheduledEvents *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetScheduledEvents))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetScheduledEvents(struct soap *soap, const char *tag, int id, _ns1__GetScheduledEvents *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetScheduledEvents, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetScheduledEvents ? type : NULL);
}

SOAP_FMAC3 _ns1__GetScheduledEvents ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetScheduledEvents(struct soap *soap, const char *tag, _ns1__GetScheduledEvents **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetScheduledEvents **)soap_malloc(soap, sizeof(_ns1__GetScheduledEvents *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetScheduledEvents *)soap_instantiate__ns1__GetScheduledEvents(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetScheduledEvents **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetScheduledEvents, sizeof(_ns1__GetScheduledEvents), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetScheduledEvents(struct soap *soap, _ns1__GetScheduledEvents *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetScheduledEvents(soap, tag ? tag : "ns1:GetScheduledEvents", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetScheduledEvents ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetScheduledEvents(struct soap *soap, _ns1__GetScheduledEvents **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetScheduledEvents(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__RemoveScheduledEvent(struct soap *soap, _ns1__RemoveScheduledEvent *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__RemoveScheduledEvent))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__RemoveScheduledEvent(struct soap *soap, const char *tag, int id, _ns1__RemoveScheduledEvent *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__RemoveScheduledEvent, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__RemoveScheduledEvent ? type : NULL);
}

SOAP_FMAC3 _ns1__RemoveScheduledEvent ** SOAP_FMAC4 soap_in_PointerTo_ns1__RemoveScheduledEvent(struct soap *soap, const char *tag, _ns1__RemoveScheduledEvent **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__RemoveScheduledEvent **)soap_malloc(soap, sizeof(_ns1__RemoveScheduledEvent *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__RemoveScheduledEvent *)soap_instantiate__ns1__RemoveScheduledEvent(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__RemoveScheduledEvent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__RemoveScheduledEvent, sizeof(_ns1__RemoveScheduledEvent), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__RemoveScheduledEvent(struct soap *soap, _ns1__RemoveScheduledEvent *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__RemoveScheduledEvent(soap, tag ? tag : "ns1:RemoveScheduledEvent", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__RemoveScheduledEvent ** SOAP_FMAC4 soap_get_PointerTo_ns1__RemoveScheduledEvent(struct soap *soap, _ns1__RemoveScheduledEvent **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__RemoveScheduledEvent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__AddScheduledEvent(struct soap *soap, _ns1__AddScheduledEvent *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__AddScheduledEvent))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__AddScheduledEvent(struct soap *soap, const char *tag, int id, _ns1__AddScheduledEvent *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__AddScheduledEvent, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__AddScheduledEvent ? type : NULL);
}

SOAP_FMAC3 _ns1__AddScheduledEvent ** SOAP_FMAC4 soap_in_PointerTo_ns1__AddScheduledEvent(struct soap *soap, const char *tag, _ns1__AddScheduledEvent **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__AddScheduledEvent **)soap_malloc(soap, sizeof(_ns1__AddScheduledEvent *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__AddScheduledEvent *)soap_instantiate__ns1__AddScheduledEvent(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__AddScheduledEvent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__AddScheduledEvent, sizeof(_ns1__AddScheduledEvent), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__AddScheduledEvent(struct soap *soap, _ns1__AddScheduledEvent *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__AddScheduledEvent(soap, tag ? tag : "ns1:AddScheduledEvent", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__AddScheduledEvent ** SOAP_FMAC4 soap_get_PointerTo_ns1__AddScheduledEvent(struct soap *soap, _ns1__AddScheduledEvent **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__AddScheduledEvent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetEventInstances(struct soap *soap, _ns1__GetEventInstances *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetEventInstances))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetEventInstances(struct soap *soap, const char *tag, int id, _ns1__GetEventInstances *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetEventInstances, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetEventInstances ? type : NULL);
}

SOAP_FMAC3 _ns1__GetEventInstances ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetEventInstances(struct soap *soap, const char *tag, _ns1__GetEventInstances **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetEventInstances **)soap_malloc(soap, sizeof(_ns1__GetEventInstances *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetEventInstances *)soap_instantiate__ns1__GetEventInstances(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetEventInstances **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetEventInstances, sizeof(_ns1__GetEventInstances), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetEventInstances(struct soap *soap, _ns1__GetEventInstances *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetEventInstances(soap, tag ? tag : "ns1:GetEventInstances", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetEventInstances ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetEventInstances(struct soap *soap, _ns1__GetEventInstances **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetEventInstances(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__TopicExpressionDialectUnknownFaultType(struct soap *soap, ns3__TopicExpressionDialectUnknownFaultType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__TopicExpressionDialectUnknownFaultType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__TopicExpressionDialectUnknownFaultType(struct soap *soap, const char *tag, int id, ns3__TopicExpressionDialectUnknownFaultType *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__TopicExpressionDialectUnknownFaultType, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns3__TopicExpressionDialectUnknownFaultType ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 ns3__TopicExpressionDialectUnknownFaultType ** SOAP_FMAC4 soap_in_PointerTons3__TopicExpressionDialectUnknownFaultType(struct soap *soap, const char *tag, ns3__TopicExpressionDialectUnknownFaultType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__TopicExpressionDialectUnknownFaultType **)soap_malloc(soap, sizeof(ns3__TopicExpressionDialectUnknownFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__TopicExpressionDialectUnknownFaultType *)soap_instantiate_ns3__TopicExpressionDialectUnknownFaultType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__TopicExpressionDialectUnknownFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__TopicExpressionDialectUnknownFaultType, sizeof(ns3__TopicExpressionDialectUnknownFaultType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__TopicExpressionDialectUnknownFaultType(struct soap *soap, ns3__TopicExpressionDialectUnknownFaultType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__TopicExpressionDialectUnknownFaultType(soap, tag ? tag : "ns3:TopicExpressionDialectUnknownFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__TopicExpressionDialectUnknownFaultType ** SOAP_FMAC4 soap_get_PointerTons3__TopicExpressionDialectUnknownFaultType(struct soap *soap, ns3__TopicExpressionDialectUnknownFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__TopicExpressionDialectUnknownFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns5__RecipientTemplateNotFoundFault(struct soap *soap, _ns5__RecipientTemplateNotFoundFault *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns5__RecipientTemplateNotFoundFault))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns5__RecipientTemplateNotFoundFault(struct soap *soap, const char *tag, int id, _ns5__RecipientTemplateNotFoundFault *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns5__RecipientTemplateNotFoundFault, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns5__RecipientTemplateNotFoundFault ? type : NULL);
}

SOAP_FMAC3 _ns5__RecipientTemplateNotFoundFault ** SOAP_FMAC4 soap_in_PointerTo_ns5__RecipientTemplateNotFoundFault(struct soap *soap, const char *tag, _ns5__RecipientTemplateNotFoundFault **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns5__RecipientTemplateNotFoundFault **)soap_malloc(soap, sizeof(_ns5__RecipientTemplateNotFoundFault *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns5__RecipientTemplateNotFoundFault *)soap_instantiate__ns5__RecipientTemplateNotFoundFault(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns5__RecipientTemplateNotFoundFault **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__RecipientTemplateNotFoundFault, sizeof(_ns5__RecipientTemplateNotFoundFault), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns5__RecipientTemplateNotFoundFault(struct soap *soap, _ns5__RecipientTemplateNotFoundFault *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns5__RecipientTemplateNotFoundFault(soap, tag ? tag : "ns5:RecipientTemplateNotFoundFault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns5__RecipientTemplateNotFoundFault ** SOAP_FMAC4 soap_get_PointerTo_ns5__RecipientTemplateNotFoundFault(struct soap *soap, _ns5__RecipientTemplateNotFoundFault **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns5__RecipientTemplateNotFoundFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns5__RecipientConfigurationNotFoundFault(struct soap *soap, _ns5__RecipientConfigurationNotFoundFault *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns5__RecipientConfigurationNotFoundFault))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns5__RecipientConfigurationNotFoundFault(struct soap *soap, const char *tag, int id, _ns5__RecipientConfigurationNotFoundFault *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns5__RecipientConfigurationNotFoundFault, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns5__RecipientConfigurationNotFoundFault ? type : NULL);
}

SOAP_FMAC3 _ns5__RecipientConfigurationNotFoundFault ** SOAP_FMAC4 soap_in_PointerTo_ns5__RecipientConfigurationNotFoundFault(struct soap *soap, const char *tag, _ns5__RecipientConfigurationNotFoundFault **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns5__RecipientConfigurationNotFoundFault **)soap_malloc(soap, sizeof(_ns5__RecipientConfigurationNotFoundFault *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns5__RecipientConfigurationNotFoundFault *)soap_instantiate__ns5__RecipientConfigurationNotFoundFault(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns5__RecipientConfigurationNotFoundFault **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__RecipientConfigurationNotFoundFault, sizeof(_ns5__RecipientConfigurationNotFoundFault), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns5__RecipientConfigurationNotFoundFault(struct soap *soap, _ns5__RecipientConfigurationNotFoundFault *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns5__RecipientConfigurationNotFoundFault(soap, tag ? tag : "ns5:RecipientConfigurationNotFoundFault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns5__RecipientConfigurationNotFoundFault ** SOAP_FMAC4 soap_get_PointerTo_ns5__RecipientConfigurationNotFoundFault(struct soap *soap, _ns5__RecipientConfigurationNotFoundFault **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns5__RecipientConfigurationNotFoundFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns5__ParametersMissmatchFault(struct soap *soap, _ns5__ParametersMissmatchFault *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns5__ParametersMissmatchFault))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns5__ParametersMissmatchFault(struct soap *soap, const char *tag, int id, _ns5__ParametersMissmatchFault *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns5__ParametersMissmatchFault, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns5__ParametersMissmatchFault ? type : NULL);
}

SOAP_FMAC3 _ns5__ParametersMissmatchFault ** SOAP_FMAC4 soap_in_PointerTo_ns5__ParametersMissmatchFault(struct soap *soap, const char *tag, _ns5__ParametersMissmatchFault **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns5__ParametersMissmatchFault **)soap_malloc(soap, sizeof(_ns5__ParametersMissmatchFault *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns5__ParametersMissmatchFault *)soap_instantiate__ns5__ParametersMissmatchFault(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns5__ParametersMissmatchFault **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__ParametersMissmatchFault, sizeof(_ns5__ParametersMissmatchFault), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns5__ParametersMissmatchFault(struct soap *soap, _ns5__ParametersMissmatchFault *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns5__ParametersMissmatchFault(soap, tag ? tag : "ns5:ParametersMissmatchFault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns5__ParametersMissmatchFault ** SOAP_FMAC4 soap_get_PointerTo_ns5__ParametersMissmatchFault(struct soap *soap, _ns5__ParametersMissmatchFault **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns5__ParametersMissmatchFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__InvalidTopicExpressionFaultType(struct soap *soap, ns3__InvalidTopicExpressionFaultType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__InvalidTopicExpressionFaultType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__InvalidTopicExpressionFaultType(struct soap *soap, const char *tag, int id, ns3__InvalidTopicExpressionFaultType *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__InvalidTopicExpressionFaultType, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns3__InvalidTopicExpressionFaultType ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 ns3__InvalidTopicExpressionFaultType ** SOAP_FMAC4 soap_in_PointerTons3__InvalidTopicExpressionFaultType(struct soap *soap, const char *tag, ns3__InvalidTopicExpressionFaultType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__InvalidTopicExpressionFaultType **)soap_malloc(soap, sizeof(ns3__InvalidTopicExpressionFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__InvalidTopicExpressionFaultType *)soap_instantiate_ns3__InvalidTopicExpressionFaultType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__InvalidTopicExpressionFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__InvalidTopicExpressionFaultType, sizeof(ns3__InvalidTopicExpressionFaultType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__InvalidTopicExpressionFaultType(struct soap *soap, ns3__InvalidTopicExpressionFaultType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__InvalidTopicExpressionFaultType(soap, tag ? tag : "ns3:InvalidTopicExpressionFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__InvalidTopicExpressionFaultType ** SOAP_FMAC4 soap_get_PointerTons3__InvalidTopicExpressionFaultType(struct soap *soap, ns3__InvalidTopicExpressionFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__InvalidTopicExpressionFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__InvalidMessageContentExpressionFaultType(struct soap *soap, ns3__InvalidMessageContentExpressionFaultType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__InvalidMessageContentExpressionFaultType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__InvalidMessageContentExpressionFaultType(struct soap *soap, const char *tag, int id, ns3__InvalidMessageContentExpressionFaultType *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__InvalidMessageContentExpressionFaultType, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns3__InvalidMessageContentExpressionFaultType ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 ns3__InvalidMessageContentExpressionFaultType ** SOAP_FMAC4 soap_in_PointerTons3__InvalidMessageContentExpressionFaultType(struct soap *soap, const char *tag, ns3__InvalidMessageContentExpressionFaultType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__InvalidMessageContentExpressionFaultType **)soap_malloc(soap, sizeof(ns3__InvalidMessageContentExpressionFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__InvalidMessageContentExpressionFaultType *)soap_instantiate_ns3__InvalidMessageContentExpressionFaultType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__InvalidMessageContentExpressionFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__InvalidMessageContentExpressionFaultType, sizeof(ns3__InvalidMessageContentExpressionFaultType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__InvalidMessageContentExpressionFaultType(struct soap *soap, ns3__InvalidMessageContentExpressionFaultType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__InvalidMessageContentExpressionFaultType(soap, tag ? tag : "ns3:InvalidMessageContentExpressionFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__InvalidMessageContentExpressionFaultType ** SOAP_FMAC4 soap_get_PointerTons3__InvalidMessageContentExpressionFaultType(struct soap *soap, ns3__InvalidMessageContentExpressionFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__InvalidMessageContentExpressionFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__InvalidFilterFaultType(struct soap *soap, ns3__InvalidFilterFaultType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__InvalidFilterFaultType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__InvalidFilterFaultType(struct soap *soap, const char *tag, int id, ns3__InvalidFilterFaultType *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__InvalidFilterFaultType, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns3__InvalidFilterFaultType ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 ns3__InvalidFilterFaultType ** SOAP_FMAC4 soap_in_PointerTons3__InvalidFilterFaultType(struct soap *soap, const char *tag, ns3__InvalidFilterFaultType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__InvalidFilterFaultType **)soap_malloc(soap, sizeof(ns3__InvalidFilterFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__InvalidFilterFaultType *)soap_instantiate_ns3__InvalidFilterFaultType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__InvalidFilterFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__InvalidFilterFaultType, sizeof(ns3__InvalidFilterFaultType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__InvalidFilterFaultType(struct soap *soap, ns3__InvalidFilterFaultType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__InvalidFilterFaultType(soap, tag ? tag : "ns3:InvalidFilterFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__InvalidFilterFaultType ** SOAP_FMAC4 soap_get_PointerTons3__InvalidFilterFaultType(struct soap *soap, ns3__InvalidFilterFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__InvalidFilterFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns5__InvalidConditionFilterFault(struct soap *soap, _ns5__InvalidConditionFilterFault *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns5__InvalidConditionFilterFault))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns5__InvalidConditionFilterFault(struct soap *soap, const char *tag, int id, _ns5__InvalidConditionFilterFault *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns5__InvalidConditionFilterFault, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns5__InvalidConditionFilterFault ? type : NULL);
}

SOAP_FMAC3 _ns5__InvalidConditionFilterFault ** SOAP_FMAC4 soap_in_PointerTo_ns5__InvalidConditionFilterFault(struct soap *soap, const char *tag, _ns5__InvalidConditionFilterFault **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns5__InvalidConditionFilterFault **)soap_malloc(soap, sizeof(_ns5__InvalidConditionFilterFault *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns5__InvalidConditionFilterFault *)soap_instantiate__ns5__InvalidConditionFilterFault(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns5__InvalidConditionFilterFault **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__InvalidConditionFilterFault, sizeof(_ns5__InvalidConditionFilterFault), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns5__InvalidConditionFilterFault(struct soap *soap, _ns5__InvalidConditionFilterFault *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns5__InvalidConditionFilterFault(soap, tag ? tag : "ns5:InvalidConditionFilterFault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns5__InvalidConditionFilterFault ** SOAP_FMAC4 soap_get_PointerTo_ns5__InvalidConditionFilterFault(struct soap *soap, _ns5__InvalidConditionFilterFault **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns5__InvalidConditionFilterFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns5__InvalidActivationTimeoutFault(struct soap *soap, _ns5__InvalidActivationTimeoutFault *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns5__InvalidActivationTimeoutFault))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns5__InvalidActivationTimeoutFault(struct soap *soap, const char *tag, int id, _ns5__InvalidActivationTimeoutFault *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns5__InvalidActivationTimeoutFault, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns5__InvalidActivationTimeoutFault ? type : NULL);
}

SOAP_FMAC3 _ns5__InvalidActivationTimeoutFault ** SOAP_FMAC4 soap_in_PointerTo_ns5__InvalidActivationTimeoutFault(struct soap *soap, const char *tag, _ns5__InvalidActivationTimeoutFault **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns5__InvalidActivationTimeoutFault **)soap_malloc(soap, sizeof(_ns5__InvalidActivationTimeoutFault *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns5__InvalidActivationTimeoutFault *)soap_instantiate__ns5__InvalidActivationTimeoutFault(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns5__InvalidActivationTimeoutFault **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__InvalidActivationTimeoutFault, sizeof(_ns5__InvalidActivationTimeoutFault), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns5__InvalidActivationTimeoutFault(struct soap *soap, _ns5__InvalidActivationTimeoutFault *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns5__InvalidActivationTimeoutFault(soap, tag ? tag : "ns5:InvalidActivationTimeoutFault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns5__InvalidActivationTimeoutFault ** SOAP_FMAC4 soap_get_PointerTo_ns5__InvalidActivationTimeoutFault(struct soap *soap, _ns5__InvalidActivationTimeoutFault **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns5__InvalidActivationTimeoutFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns5__InvalidActionConfigurationFault(struct soap *soap, _ns5__InvalidActionConfigurationFault *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns5__InvalidActionConfigurationFault))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns5__InvalidActionConfigurationFault(struct soap *soap, const char *tag, int id, _ns5__InvalidActionConfigurationFault *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns5__InvalidActionConfigurationFault, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns5__InvalidActionConfigurationFault ? type : NULL);
}

SOAP_FMAC3 _ns5__InvalidActionConfigurationFault ** SOAP_FMAC4 soap_in_PointerTo_ns5__InvalidActionConfigurationFault(struct soap *soap, const char *tag, _ns5__InvalidActionConfigurationFault **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns5__InvalidActionConfigurationFault **)soap_malloc(soap, sizeof(_ns5__InvalidActionConfigurationFault *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns5__InvalidActionConfigurationFault *)soap_instantiate__ns5__InvalidActionConfigurationFault(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns5__InvalidActionConfigurationFault **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__InvalidActionConfigurationFault, sizeof(_ns5__InvalidActionConfigurationFault), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns5__InvalidActionConfigurationFault(struct soap *soap, _ns5__InvalidActionConfigurationFault *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns5__InvalidActionConfigurationFault(soap, tag ? tag : "ns5:InvalidActionConfigurationFault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns5__InvalidActionConfigurationFault ** SOAP_FMAC4 soap_get_PointerTo_ns5__InvalidActionConfigurationFault(struct soap *soap, _ns5__InvalidActionConfigurationFault **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns5__InvalidActionConfigurationFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns5__InsufficientActivationRuleFault(struct soap *soap, _ns5__InsufficientActivationRuleFault *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns5__InsufficientActivationRuleFault))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns5__InsufficientActivationRuleFault(struct soap *soap, const char *tag, int id, _ns5__InsufficientActivationRuleFault *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns5__InsufficientActivationRuleFault, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns5__InsufficientActivationRuleFault ? type : NULL);
}

SOAP_FMAC3 _ns5__InsufficientActivationRuleFault ** SOAP_FMAC4 soap_in_PointerTo_ns5__InsufficientActivationRuleFault(struct soap *soap, const char *tag, _ns5__InsufficientActivationRuleFault **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns5__InsufficientActivationRuleFault **)soap_malloc(soap, sizeof(_ns5__InsufficientActivationRuleFault *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns5__InsufficientActivationRuleFault *)soap_instantiate__ns5__InsufficientActivationRuleFault(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns5__InsufficientActivationRuleFault **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__InsufficientActivationRuleFault, sizeof(_ns5__InsufficientActivationRuleFault), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns5__InsufficientActivationRuleFault(struct soap *soap, _ns5__InsufficientActivationRuleFault *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns5__InsufficientActivationRuleFault(soap, tag ? tag : "ns5:InsufficientActivationRuleFault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns5__InsufficientActivationRuleFault ** SOAP_FMAC4 soap_get_PointerTo_ns5__InsufficientActivationRuleFault(struct soap *soap, _ns5__InsufficientActivationRuleFault **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns5__InsufficientActivationRuleFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns5__ActionTemplateNotFoundFault(struct soap *soap, _ns5__ActionTemplateNotFoundFault *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns5__ActionTemplateNotFoundFault))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns5__ActionTemplateNotFoundFault(struct soap *soap, const char *tag, int id, _ns5__ActionTemplateNotFoundFault *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns5__ActionTemplateNotFoundFault, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns5__ActionTemplateNotFoundFault ? type : NULL);
}

SOAP_FMAC3 _ns5__ActionTemplateNotFoundFault ** SOAP_FMAC4 soap_in_PointerTo_ns5__ActionTemplateNotFoundFault(struct soap *soap, const char *tag, _ns5__ActionTemplateNotFoundFault **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns5__ActionTemplateNotFoundFault **)soap_malloc(soap, sizeof(_ns5__ActionTemplateNotFoundFault *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns5__ActionTemplateNotFoundFault *)soap_instantiate__ns5__ActionTemplateNotFoundFault(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns5__ActionTemplateNotFoundFault **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__ActionTemplateNotFoundFault, sizeof(_ns5__ActionTemplateNotFoundFault), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns5__ActionTemplateNotFoundFault(struct soap *soap, _ns5__ActionTemplateNotFoundFault *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns5__ActionTemplateNotFoundFault(soap, tag ? tag : "ns5:ActionTemplateNotFoundFault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns5__ActionTemplateNotFoundFault ** SOAP_FMAC4 soap_get_PointerTo_ns5__ActionTemplateNotFoundFault(struct soap *soap, _ns5__ActionTemplateNotFoundFault **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns5__ActionTemplateNotFoundFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns5__ActionRuleNotFoundFault(struct soap *soap, _ns5__ActionRuleNotFoundFault *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns5__ActionRuleNotFoundFault))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns5__ActionRuleNotFoundFault(struct soap *soap, const char *tag, int id, _ns5__ActionRuleNotFoundFault *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns5__ActionRuleNotFoundFault, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns5__ActionRuleNotFoundFault ? type : NULL);
}

SOAP_FMAC3 _ns5__ActionRuleNotFoundFault ** SOAP_FMAC4 soap_in_PointerTo_ns5__ActionRuleNotFoundFault(struct soap *soap, const char *tag, _ns5__ActionRuleNotFoundFault **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns5__ActionRuleNotFoundFault **)soap_malloc(soap, sizeof(_ns5__ActionRuleNotFoundFault *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns5__ActionRuleNotFoundFault *)soap_instantiate__ns5__ActionRuleNotFoundFault(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns5__ActionRuleNotFoundFault **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__ActionRuleNotFoundFault, sizeof(_ns5__ActionRuleNotFoundFault), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns5__ActionRuleNotFoundFault(struct soap *soap, _ns5__ActionRuleNotFoundFault *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns5__ActionRuleNotFoundFault(soap, tag ? tag : "ns5:ActionRuleNotFoundFault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns5__ActionRuleNotFoundFault ** SOAP_FMAC4 soap_get_PointerTo_ns5__ActionRuleNotFoundFault(struct soap *soap, _ns5__ActionRuleNotFoundFault **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns5__ActionRuleNotFoundFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns5__ActionConfigurationNotFoundFault(struct soap *soap, _ns5__ActionConfigurationNotFoundFault *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns5__ActionConfigurationNotFoundFault))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns5__ActionConfigurationNotFoundFault(struct soap *soap, const char *tag, int id, _ns5__ActionConfigurationNotFoundFault *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns5__ActionConfigurationNotFoundFault, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns5__ActionConfigurationNotFoundFault ? type : NULL);
}

SOAP_FMAC3 _ns5__ActionConfigurationNotFoundFault ** SOAP_FMAC4 soap_in_PointerTo_ns5__ActionConfigurationNotFoundFault(struct soap *soap, const char *tag, _ns5__ActionConfigurationNotFoundFault **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns5__ActionConfigurationNotFoundFault **)soap_malloc(soap, sizeof(_ns5__ActionConfigurationNotFoundFault *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns5__ActionConfigurationNotFoundFault *)soap_instantiate__ns5__ActionConfigurationNotFoundFault(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns5__ActionConfigurationNotFoundFault **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__ActionConfigurationNotFoundFault, sizeof(_ns5__ActionConfigurationNotFoundFault), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns5__ActionConfigurationNotFoundFault(struct soap *soap, _ns5__ActionConfigurationNotFoundFault *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns5__ActionConfigurationNotFoundFault(soap, tag ? tag : "ns5:ActionConfigurationNotFoundFault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns5__ActionConfigurationNotFoundFault ** SOAP_FMAC4 soap_get_PointerTo_ns5__ActionConfigurationNotFoundFault(struct soap *soap, _ns5__ActionConfigurationNotFoundFault **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns5__ActionConfigurationNotFoundFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns5__ActionConfigurationIsInUseFault(struct soap *soap, _ns5__ActionConfigurationIsInUseFault *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns5__ActionConfigurationIsInUseFault))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns5__ActionConfigurationIsInUseFault(struct soap *soap, const char *tag, int id, _ns5__ActionConfigurationIsInUseFault *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns5__ActionConfigurationIsInUseFault, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns5__ActionConfigurationIsInUseFault ? type : NULL);
}

SOAP_FMAC3 _ns5__ActionConfigurationIsInUseFault ** SOAP_FMAC4 soap_in_PointerTo_ns5__ActionConfigurationIsInUseFault(struct soap *soap, const char *tag, _ns5__ActionConfigurationIsInUseFault **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns5__ActionConfigurationIsInUseFault **)soap_malloc(soap, sizeof(_ns5__ActionConfigurationIsInUseFault *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns5__ActionConfigurationIsInUseFault *)soap_instantiate__ns5__ActionConfigurationIsInUseFault(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns5__ActionConfigurationIsInUseFault **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__ActionConfigurationIsInUseFault, sizeof(_ns5__ActionConfigurationIsInUseFault), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns5__ActionConfigurationIsInUseFault(struct soap *soap, _ns5__ActionConfigurationIsInUseFault *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns5__ActionConfigurationIsInUseFault(soap, tag ? tag : "ns5:ActionConfigurationIsInUseFault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns5__ActionConfigurationIsInUseFault ** SOAP_FMAC4 soap_get_PointerTo_ns5__ActionConfigurationIsInUseFault(struct soap *soap, _ns5__ActionConfigurationIsInUseFault **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns5__ActionConfigurationIsInUseFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__ScheduledEventNotFoundFault(struct soap *soap, _ns1__ScheduledEventNotFoundFault *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__ScheduledEventNotFoundFault))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__ScheduledEventNotFoundFault(struct soap *soap, const char *tag, int id, _ns1__ScheduledEventNotFoundFault *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__ScheduledEventNotFoundFault, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__ScheduledEventNotFoundFault ? type : NULL);
}

SOAP_FMAC3 _ns1__ScheduledEventNotFoundFault ** SOAP_FMAC4 soap_in_PointerTo_ns1__ScheduledEventNotFoundFault(struct soap *soap, const char *tag, _ns1__ScheduledEventNotFoundFault **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__ScheduledEventNotFoundFault **)soap_malloc(soap, sizeof(_ns1__ScheduledEventNotFoundFault *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__ScheduledEventNotFoundFault *)soap_instantiate__ns1__ScheduledEventNotFoundFault(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__ScheduledEventNotFoundFault **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__ScheduledEventNotFoundFault, sizeof(_ns1__ScheduledEventNotFoundFault), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__ScheduledEventNotFoundFault(struct soap *soap, _ns1__ScheduledEventNotFoundFault *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__ScheduledEventNotFoundFault(soap, tag ? tag : "ns1:ScheduledEventNotFoundFault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__ScheduledEventNotFoundFault ** SOAP_FMAC4 soap_get_PointerTo_ns1__ScheduledEventNotFoundFault(struct soap *soap, _ns1__ScheduledEventNotFoundFault **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__ScheduledEventNotFoundFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__ScheduledEventAlreadyExistsFault(struct soap *soap, _ns1__ScheduledEventAlreadyExistsFault *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__ScheduledEventAlreadyExistsFault))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__ScheduledEventAlreadyExistsFault(struct soap *soap, const char *tag, int id, _ns1__ScheduledEventAlreadyExistsFault *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__ScheduledEventAlreadyExistsFault, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__ScheduledEventAlreadyExistsFault ? type : NULL);
}

SOAP_FMAC3 _ns1__ScheduledEventAlreadyExistsFault ** SOAP_FMAC4 soap_in_PointerTo_ns1__ScheduledEventAlreadyExistsFault(struct soap *soap, const char *tag, _ns1__ScheduledEventAlreadyExistsFault **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__ScheduledEventAlreadyExistsFault **)soap_malloc(soap, sizeof(_ns1__ScheduledEventAlreadyExistsFault *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__ScheduledEventAlreadyExistsFault *)soap_instantiate__ns1__ScheduledEventAlreadyExistsFault(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__ScheduledEventAlreadyExistsFault **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__ScheduledEventAlreadyExistsFault, sizeof(_ns1__ScheduledEventAlreadyExistsFault), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__ScheduledEventAlreadyExistsFault(struct soap *soap, _ns1__ScheduledEventAlreadyExistsFault *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__ScheduledEventAlreadyExistsFault(soap, tag ? tag : "ns1:ScheduledEventAlreadyExistsFault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__ScheduledEventAlreadyExistsFault ** SOAP_FMAC4 soap_get_PointerTo_ns1__ScheduledEventAlreadyExistsFault(struct soap *soap, _ns1__ScheduledEventAlreadyExistsFault **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__ScheduledEventAlreadyExistsFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__InvalidScheduledEventIDFault(struct soap *soap, _ns1__InvalidScheduledEventIDFault *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__InvalidScheduledEventIDFault))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__InvalidScheduledEventIDFault(struct soap *soap, const char *tag, int id, _ns1__InvalidScheduledEventIDFault *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__InvalidScheduledEventIDFault, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__InvalidScheduledEventIDFault ? type : NULL);
}

SOAP_FMAC3 _ns1__InvalidScheduledEventIDFault ** SOAP_FMAC4 soap_in_PointerTo_ns1__InvalidScheduledEventIDFault(struct soap *soap, const char *tag, _ns1__InvalidScheduledEventIDFault **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__InvalidScheduledEventIDFault **)soap_malloc(soap, sizeof(_ns1__InvalidScheduledEventIDFault *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__InvalidScheduledEventIDFault *)soap_instantiate__ns1__InvalidScheduledEventIDFault(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__InvalidScheduledEventIDFault **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__InvalidScheduledEventIDFault, sizeof(_ns1__InvalidScheduledEventIDFault), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__InvalidScheduledEventIDFault(struct soap *soap, _ns1__InvalidScheduledEventIDFault *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__InvalidScheduledEventIDFault(soap, tag ? tag : "ns1:InvalidScheduledEventIDFault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__InvalidScheduledEventIDFault ** SOAP_FMAC4 soap_get_PointerTo_ns1__InvalidScheduledEventIDFault(struct soap *soap, _ns1__InvalidScheduledEventIDFault **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__InvalidScheduledEventIDFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__InvalidScheduleFault(struct soap *soap, _ns1__InvalidScheduleFault *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__InvalidScheduleFault))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__InvalidScheduleFault(struct soap *soap, const char *tag, int id, _ns1__InvalidScheduleFault *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__InvalidScheduleFault, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__InvalidScheduleFault ? type : NULL);
}

SOAP_FMAC3 _ns1__InvalidScheduleFault ** SOAP_FMAC4 soap_in_PointerTo_ns1__InvalidScheduleFault(struct soap *soap, const char *tag, _ns1__InvalidScheduleFault **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__InvalidScheduleFault **)soap_malloc(soap, sizeof(_ns1__InvalidScheduleFault *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__InvalidScheduleFault *)soap_instantiate__ns1__InvalidScheduleFault(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__InvalidScheduleFault **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__InvalidScheduleFault, sizeof(_ns1__InvalidScheduleFault), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__InvalidScheduleFault(struct soap *soap, _ns1__InvalidScheduleFault *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__InvalidScheduleFault(soap, tag ? tag : "ns1:InvalidScheduleFault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__InvalidScheduleFault ** SOAP_FMAC4 soap_get_PointerTo_ns1__InvalidScheduleFault(struct soap *soap, _ns1__InvalidScheduleFault **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__InvalidScheduleFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__NCName(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__NCName))
		soap_serialize_xsd__NCName(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__NCName(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__NCName, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__NCName(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__NCName(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__NCName(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__NCName, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__NCName(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxsd__NCName(soap, tag ? tag : "xsd:NCName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__NCName(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__NCName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ConcreteTopicExpression(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ConcreteTopicExpression))
		soap_serialize_ns2__ConcreteTopicExpression(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ConcreteTopicExpression(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ConcreteTopicExpression, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__ConcreteTopicExpression(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTons2__ConcreteTopicExpression(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__ConcreteTopicExpression(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ConcreteTopicExpression, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ConcreteTopicExpression(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__ConcreteTopicExpression(soap, tag ? tag : "ns2:ConcreteTopicExpression", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTons2__ConcreteTopicExpression(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ConcreteTopicExpression(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__QName(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__QName))
		soap_serialize_xsd__QName(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__QName(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__QName, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__QName(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__QName(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__QName(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__QName, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__QName(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxsd__QName(soap, tag ? tag : "xsd:QName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__QName(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__TopicType(struct soap *soap, ns2__TopicType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__TopicType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__TopicType(struct soap *soap, const char *tag, int id, ns2__TopicType *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__TopicType, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__TopicType ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 ns2__TopicType ** SOAP_FMAC4 soap_in_PointerTons2__TopicType(struct soap *soap, const char *tag, ns2__TopicType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__TopicType **)soap_malloc(soap, sizeof(ns2__TopicType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__TopicType *)soap_instantiate_ns2__TopicType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__TopicType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__TopicType, sizeof(ns2__TopicType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__TopicType(struct soap *soap, ns2__TopicType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__TopicType(soap, tag ? tag : "ns2:TopicType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__TopicType ** SOAP_FMAC4 soap_get_PointerTons2__TopicType(struct soap *soap, ns2__TopicType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__TopicType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__QueryExpressionType(struct soap *soap, ns2__QueryExpressionType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__QueryExpressionType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__QueryExpressionType(struct soap *soap, const char *tag, int id, ns2__QueryExpressionType *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__QueryExpressionType, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__QueryExpressionType ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 ns2__QueryExpressionType ** SOAP_FMAC4 soap_in_PointerTons2__QueryExpressionType(struct soap *soap, const char *tag, ns2__QueryExpressionType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__QueryExpressionType **)soap_malloc(soap, sizeof(ns2__QueryExpressionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__QueryExpressionType *)soap_instantiate_ns2__QueryExpressionType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__QueryExpressionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__QueryExpressionType, sizeof(ns2__QueryExpressionType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__QueryExpressionType(struct soap *soap, ns2__QueryExpressionType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__QueryExpressionType(soap, tag ? tag : "ns2:QueryExpressionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__QueryExpressionType ** SOAP_FMAC4 soap_get_PointerTons2__QueryExpressionType(struct soap *soap, ns2__QueryExpressionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__QueryExpressionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__anyURI(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__anyURI))
		soap_serialize_xsd__anyURI(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__anyURI(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__anyURI, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__anyURI(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__anyURI(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__anyURI(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__anyURI, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__anyURI(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxsd__anyURI(soap, tag ? tag : "xsd:anyURI", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__anyURI(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__anyURI(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__MetadataType(struct soap *soap, ns6__MetadataType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__MetadataType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__MetadataType(struct soap *soap, const char *tag, int id, ns6__MetadataType *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__MetadataType, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns6__MetadataType ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 ns6__MetadataType ** SOAP_FMAC4 soap_in_PointerTons6__MetadataType(struct soap *soap, const char *tag, ns6__MetadataType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns6__MetadataType **)soap_malloc(soap, sizeof(ns6__MetadataType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns6__MetadataType *)soap_instantiate_ns6__MetadataType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns6__MetadataType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__MetadataType, sizeof(ns6__MetadataType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__MetadataType(struct soap *soap, ns6__MetadataType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons6__MetadataType(soap, tag ? tag : "ns6:MetadataType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns6__MetadataType ** SOAP_FMAC4 soap_get_PointerTons6__MetadataType(struct soap *soap, ns6__MetadataType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__MetadataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__ReferenceParametersType(struct soap *soap, ns6__ReferenceParametersType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__ReferenceParametersType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__ReferenceParametersType(struct soap *soap, const char *tag, int id, ns6__ReferenceParametersType *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__ReferenceParametersType, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns6__ReferenceParametersType ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 ns6__ReferenceParametersType ** SOAP_FMAC4 soap_in_PointerTons6__ReferenceParametersType(struct soap *soap, const char *tag, ns6__ReferenceParametersType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns6__ReferenceParametersType **)soap_malloc(soap, sizeof(ns6__ReferenceParametersType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns6__ReferenceParametersType *)soap_instantiate_ns6__ReferenceParametersType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns6__ReferenceParametersType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__ReferenceParametersType, sizeof(ns6__ReferenceParametersType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__ReferenceParametersType(struct soap *soap, ns6__ReferenceParametersType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons6__ReferenceParametersType(soap, tag ? tag : "ns6:ReferenceParametersType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns6__ReferenceParametersType ** SOAP_FMAC4 soap_get_PointerTons6__ReferenceParametersType(struct soap *soap, ns6__ReferenceParametersType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__ReferenceParametersType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__AttributedURIType(struct soap *soap, ns6__AttributedURIType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__AttributedURIType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__AttributedURIType(struct soap *soap, const char *tag, int id, ns6__AttributedURIType *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__AttributedURIType, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns6__AttributedURIType ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 ns6__AttributedURIType ** SOAP_FMAC4 soap_in_PointerTons6__AttributedURIType(struct soap *soap, const char *tag, ns6__AttributedURIType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns6__AttributedURIType **)soap_malloc(soap, sizeof(ns6__AttributedURIType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns6__AttributedURIType *)soap_instantiate_ns6__AttributedURIType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns6__AttributedURIType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__AttributedURIType, sizeof(ns6__AttributedURIType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__AttributedURIType(struct soap *soap, ns6__AttributedURIType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons6__AttributedURIType(soap, tag ? tag : "ns6:AttributedURIType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns6__AttributedURIType ** SOAP_FMAC4 soap_get_PointerTons6__AttributedURIType(struct soap *soap, ns6__AttributedURIType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__AttributedURIType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__UsedByActionRules(struct soap *soap, ns5__UsedByActionRules *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns5__UsedByActionRules))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__UsedByActionRules(struct soap *soap, const char *tag, int id, ns5__UsedByActionRules *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__UsedByActionRules, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns5__UsedByActionRules ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 ns5__UsedByActionRules ** SOAP_FMAC4 soap_in_PointerTons5__UsedByActionRules(struct soap *soap, const char *tag, ns5__UsedByActionRules **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__UsedByActionRules **)soap_malloc(soap, sizeof(ns5__UsedByActionRules *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__UsedByActionRules *)soap_instantiate_ns5__UsedByActionRules(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns5__UsedByActionRules **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__UsedByActionRules, sizeof(ns5__UsedByActionRules), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__UsedByActionRules(struct soap *soap, ns5__UsedByActionRules *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons5__UsedByActionRules(soap, tag ? tag : "ns5:UsedByActionRules", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns5__UsedByActionRules ** SOAP_FMAC4 soap_get_PointerTons5__UsedByActionRules(struct soap *soap, ns5__UsedByActionRules **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__UsedByActionRules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__ActionRules(struct soap *soap, ns5__ActionRules *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns5__ActionRules))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__ActionRules(struct soap *soap, const char *tag, int id, ns5__ActionRules *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__ActionRules, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns5__ActionRules ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 ns5__ActionRules ** SOAP_FMAC4 soap_in_PointerTons5__ActionRules(struct soap *soap, const char *tag, ns5__ActionRules **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__ActionRules **)soap_malloc(soap, sizeof(ns5__ActionRules *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__ActionRules *)soap_instantiate_ns5__ActionRules(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns5__ActionRules **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__ActionRules, sizeof(ns5__ActionRules), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__ActionRules(struct soap *soap, ns5__ActionRules *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons5__ActionRules(soap, tag ? tag : "ns5:ActionRules", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns5__ActionRules ** SOAP_FMAC4 soap_get_PointerTons5__ActionRules(struct soap *soap, ns5__ActionRules **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__ActionRules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__NewActionRule(struct soap *soap, ns5__NewActionRule *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns5__NewActionRule))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__NewActionRule(struct soap *soap, const char *tag, int id, ns5__NewActionRule *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__NewActionRule, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns5__NewActionRule ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 ns5__NewActionRule ** SOAP_FMAC4 soap_in_PointerTons5__NewActionRule(struct soap *soap, const char *tag, ns5__NewActionRule **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__NewActionRule **)soap_malloc(soap, sizeof(ns5__NewActionRule *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__NewActionRule *)soap_instantiate_ns5__NewActionRule(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns5__NewActionRule **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__NewActionRule, sizeof(ns5__NewActionRule), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__NewActionRule(struct soap *soap, ns5__NewActionRule *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons5__NewActionRule(soap, tag ? tag : "ns5:NewActionRule", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns5__NewActionRule ** SOAP_FMAC4 soap_get_PointerTons5__NewActionRule(struct soap *soap, ns5__NewActionRule **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__NewActionRule(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__RecipientConfigurations(struct soap *soap, ns5__RecipientConfigurations *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns5__RecipientConfigurations))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__RecipientConfigurations(struct soap *soap, const char *tag, int id, ns5__RecipientConfigurations *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__RecipientConfigurations, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns5__RecipientConfigurations ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 ns5__RecipientConfigurations ** SOAP_FMAC4 soap_in_PointerTons5__RecipientConfigurations(struct soap *soap, const char *tag, ns5__RecipientConfigurations **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__RecipientConfigurations **)soap_malloc(soap, sizeof(ns5__RecipientConfigurations *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__RecipientConfigurations *)soap_instantiate_ns5__RecipientConfigurations(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns5__RecipientConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__RecipientConfigurations, sizeof(ns5__RecipientConfigurations), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__RecipientConfigurations(struct soap *soap, ns5__RecipientConfigurations *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons5__RecipientConfigurations(soap, tag ? tag : "ns5:RecipientConfigurations", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns5__RecipientConfigurations ** SOAP_FMAC4 soap_get_PointerTons5__RecipientConfigurations(struct soap *soap, ns5__RecipientConfigurations **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__RecipientConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__NewRecipientConfiguration(struct soap *soap, ns5__NewRecipientConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns5__NewRecipientConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__NewRecipientConfiguration(struct soap *soap, const char *tag, int id, ns5__NewRecipientConfiguration *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__NewRecipientConfiguration, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns5__NewRecipientConfiguration ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 ns5__NewRecipientConfiguration ** SOAP_FMAC4 soap_in_PointerTons5__NewRecipientConfiguration(struct soap *soap, const char *tag, ns5__NewRecipientConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__NewRecipientConfiguration **)soap_malloc(soap, sizeof(ns5__NewRecipientConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__NewRecipientConfiguration *)soap_instantiate_ns5__NewRecipientConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns5__NewRecipientConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__NewRecipientConfiguration, sizeof(ns5__NewRecipientConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__NewRecipientConfiguration(struct soap *soap, ns5__NewRecipientConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons5__NewRecipientConfiguration(soap, tag ? tag : "ns5:NewRecipientConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns5__NewRecipientConfiguration ** SOAP_FMAC4 soap_get_PointerTons5__NewRecipientConfiguration(struct soap *soap, ns5__NewRecipientConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__NewRecipientConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__RecipientTemplates(struct soap *soap, ns5__RecipientTemplates *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns5__RecipientTemplates))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__RecipientTemplates(struct soap *soap, const char *tag, int id, ns5__RecipientTemplates *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__RecipientTemplates, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns5__RecipientTemplates ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 ns5__RecipientTemplates ** SOAP_FMAC4 soap_in_PointerTons5__RecipientTemplates(struct soap *soap, const char *tag, ns5__RecipientTemplates **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__RecipientTemplates **)soap_malloc(soap, sizeof(ns5__RecipientTemplates *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__RecipientTemplates *)soap_instantiate_ns5__RecipientTemplates(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns5__RecipientTemplates **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__RecipientTemplates, sizeof(ns5__RecipientTemplates), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__RecipientTemplates(struct soap *soap, ns5__RecipientTemplates *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons5__RecipientTemplates(soap, tag ? tag : "ns5:RecipientTemplates", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns5__RecipientTemplates ** SOAP_FMAC4 soap_get_PointerTons5__RecipientTemplates(struct soap *soap, ns5__RecipientTemplates **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__RecipientTemplates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__ActionConfigurations(struct soap *soap, ns5__ActionConfigurations *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns5__ActionConfigurations))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__ActionConfigurations(struct soap *soap, const char *tag, int id, ns5__ActionConfigurations *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__ActionConfigurations, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns5__ActionConfigurations ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 ns5__ActionConfigurations ** SOAP_FMAC4 soap_in_PointerTons5__ActionConfigurations(struct soap *soap, const char *tag, ns5__ActionConfigurations **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__ActionConfigurations **)soap_malloc(soap, sizeof(ns5__ActionConfigurations *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__ActionConfigurations *)soap_instantiate_ns5__ActionConfigurations(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns5__ActionConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__ActionConfigurations, sizeof(ns5__ActionConfigurations), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__ActionConfigurations(struct soap *soap, ns5__ActionConfigurations *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons5__ActionConfigurations(soap, tag ? tag : "ns5:ActionConfigurations", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns5__ActionConfigurations ** SOAP_FMAC4 soap_get_PointerTons5__ActionConfigurations(struct soap *soap, ns5__ActionConfigurations **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__ActionConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__NewActionConfiguration(struct soap *soap, ns5__NewActionConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns5__NewActionConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__NewActionConfiguration(struct soap *soap, const char *tag, int id, ns5__NewActionConfiguration *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__NewActionConfiguration, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns5__NewActionConfiguration ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 ns5__NewActionConfiguration ** SOAP_FMAC4 soap_in_PointerTons5__NewActionConfiguration(struct soap *soap, const char *tag, ns5__NewActionConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__NewActionConfiguration **)soap_malloc(soap, sizeof(ns5__NewActionConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__NewActionConfiguration *)soap_instantiate_ns5__NewActionConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns5__NewActionConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__NewActionConfiguration, sizeof(ns5__NewActionConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__NewActionConfiguration(struct soap *soap, ns5__NewActionConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons5__NewActionConfiguration(soap, tag ? tag : "ns5:NewActionConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns5__NewActionConfiguration ** SOAP_FMAC4 soap_get_PointerTons5__NewActionConfiguration(struct soap *soap, ns5__NewActionConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__NewActionConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__ActionTemplates(struct soap *soap, ns5__ActionTemplates *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns5__ActionTemplates))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__ActionTemplates(struct soap *soap, const char *tag, int id, ns5__ActionTemplates *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__ActionTemplates, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns5__ActionTemplates ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 ns5__ActionTemplates ** SOAP_FMAC4 soap_in_PointerTons5__ActionTemplates(struct soap *soap, const char *tag, ns5__ActionTemplates **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__ActionTemplates **)soap_malloc(soap, sizeof(ns5__ActionTemplates *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__ActionTemplates *)soap_instantiate_ns5__ActionTemplates(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns5__ActionTemplates **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__ActionTemplates, sizeof(ns5__ActionTemplates), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__ActionTemplates(struct soap *soap, ns5__ActionTemplates *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons5__ActionTemplates(soap, tag ? tag : "ns5:ActionTemplates", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns5__ActionTemplates ** SOAP_FMAC4 soap_get_PointerTons5__ActionTemplates(struct soap *soap, ns5__ActionTemplates **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__ActionTemplates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__UsedActionRule(struct soap *soap, ns5__UsedActionRule *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns5__UsedActionRule))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__UsedActionRule(struct soap *soap, const char *tag, int id, ns5__UsedActionRule *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__UsedActionRule, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns5__UsedActionRule ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 ns5__UsedActionRule ** SOAP_FMAC4 soap_in_PointerTons5__UsedActionRule(struct soap *soap, const char *tag, ns5__UsedActionRule **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__UsedActionRule **)soap_malloc(soap, sizeof(ns5__UsedActionRule *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__UsedActionRule *)soap_instantiate_ns5__UsedActionRule(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns5__UsedActionRule **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__UsedActionRule, sizeof(ns5__UsedActionRule), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__UsedActionRule(struct soap *soap, ns5__UsedActionRule *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons5__UsedActionRule(soap, tag ? tag : "ns5:UsedActionRule", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns5__UsedActionRule ** SOAP_FMAC4 soap_get_PointerTons5__UsedActionRule(struct soap *soap, ns5__UsedActionRule **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__UsedActionRule(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__UsedActionConfiguration(struct soap *soap, ns5__UsedActionConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns5__UsedActionConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__UsedActionConfiguration(struct soap *soap, const char *tag, int id, ns5__UsedActionConfiguration *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__UsedActionConfiguration, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns5__UsedActionConfiguration ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 ns5__UsedActionConfiguration ** SOAP_FMAC4 soap_in_PointerTons5__UsedActionConfiguration(struct soap *soap, const char *tag, ns5__UsedActionConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__UsedActionConfiguration **)soap_malloc(soap, sizeof(ns5__UsedActionConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__UsedActionConfiguration *)soap_instantiate_ns5__UsedActionConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns5__UsedActionConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__UsedActionConfiguration, sizeof(ns5__UsedActionConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__UsedActionConfiguration(struct soap *soap, ns5__UsedActionConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons5__UsedActionConfiguration(soap, tag ? tag : "ns5:UsedActionConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns5__UsedActionConfiguration ** SOAP_FMAC4 soap_get_PointerTons5__UsedActionConfiguration(struct soap *soap, ns5__UsedActionConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__UsedActionConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__ActionTemplateParameter(struct soap *soap, ns5__ActionTemplateParameter *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns5__ActionTemplateParameter))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__ActionTemplateParameter(struct soap *soap, const char *tag, int id, ns5__ActionTemplateParameter *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__ActionTemplateParameter, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns5__ActionTemplateParameter ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 ns5__ActionTemplateParameter ** SOAP_FMAC4 soap_in_PointerTons5__ActionTemplateParameter(struct soap *soap, const char *tag, ns5__ActionTemplateParameter **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__ActionTemplateParameter **)soap_malloc(soap, sizeof(ns5__ActionTemplateParameter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__ActionTemplateParameter *)soap_instantiate_ns5__ActionTemplateParameter(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns5__ActionTemplateParameter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__ActionTemplateParameter, sizeof(ns5__ActionTemplateParameter), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__ActionTemplateParameter(struct soap *soap, ns5__ActionTemplateParameter *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons5__ActionTemplateParameter(soap, tag ? tag : "ns5:ActionTemplateParameter", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns5__ActionTemplateParameter ** SOAP_FMAC4 soap_get_PointerTons5__ActionTemplateParameter(struct soap *soap, ns5__ActionTemplateParameter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__ActionTemplateParameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__ActionTemplate(struct soap *soap, ns5__ActionTemplate *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns5__ActionTemplate))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__ActionTemplate(struct soap *soap, const char *tag, int id, ns5__ActionTemplate *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__ActionTemplate, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns5__ActionTemplate ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 ns5__ActionTemplate ** SOAP_FMAC4 soap_in_PointerTons5__ActionTemplate(struct soap *soap, const char *tag, ns5__ActionTemplate **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__ActionTemplate **)soap_malloc(soap, sizeof(ns5__ActionTemplate *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__ActionTemplate *)soap_instantiate_ns5__ActionTemplate(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns5__ActionTemplate **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__ActionTemplate, sizeof(ns5__ActionTemplate), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__ActionTemplate(struct soap *soap, ns5__ActionTemplate *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons5__ActionTemplate(soap, tag ? tag : "ns5:ActionTemplate", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns5__ActionTemplate ** SOAP_FMAC4 soap_get_PointerTons5__ActionTemplate(struct soap *soap, ns5__ActionTemplate **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__ActionTemplate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__ActionParameter(struct soap *soap, ns5__ActionParameter *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns5__ActionParameter))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__ActionParameter(struct soap *soap, const char *tag, int id, ns5__ActionParameter *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__ActionParameter, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns5__ActionParameter ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 ns5__ActionParameter ** SOAP_FMAC4 soap_in_PointerTons5__ActionParameter(struct soap *soap, const char *tag, ns5__ActionParameter **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__ActionParameter **)soap_malloc(soap, sizeof(ns5__ActionParameter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__ActionParameter *)soap_instantiate_ns5__ActionParameter(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns5__ActionParameter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__ActionParameter, sizeof(ns5__ActionParameter), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__ActionParameter(struct soap *soap, ns5__ActionParameter *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons5__ActionParameter(soap, tag ? tag : "ns5:ActionParameter", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns5__ActionParameter ** SOAP_FMAC4 soap_get_PointerTons5__ActionParameter(struct soap *soap, ns5__ActionParameter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__ActionParameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__ActionConfiguration(struct soap *soap, ns5__ActionConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns5__ActionConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__ActionConfiguration(struct soap *soap, const char *tag, int id, ns5__ActionConfiguration *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__ActionConfiguration, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns5__ActionConfiguration ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 ns5__ActionConfiguration ** SOAP_FMAC4 soap_in_PointerTons5__ActionConfiguration(struct soap *soap, const char *tag, ns5__ActionConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__ActionConfiguration **)soap_malloc(soap, sizeof(ns5__ActionConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__ActionConfiguration *)soap_instantiate_ns5__ActionConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns5__ActionConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__ActionConfiguration, sizeof(ns5__ActionConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__ActionConfiguration(struct soap *soap, ns5__ActionConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons5__ActionConfiguration(soap, tag ? tag : "ns5:ActionConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns5__ActionConfiguration ** SOAP_FMAC4 soap_get_PointerTons5__ActionConfiguration(struct soap *soap, ns5__ActionConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__ActionConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__ActionTemplateParameters(struct soap *soap, ns5__ActionTemplateParameters *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns5__ActionTemplateParameters))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__ActionTemplateParameters(struct soap *soap, const char *tag, int id, ns5__ActionTemplateParameters *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__ActionTemplateParameters, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns5__ActionTemplateParameters ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 ns5__ActionTemplateParameters ** SOAP_FMAC4 soap_in_PointerTons5__ActionTemplateParameters(struct soap *soap, const char *tag, ns5__ActionTemplateParameters **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__ActionTemplateParameters **)soap_malloc(soap, sizeof(ns5__ActionTemplateParameters *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__ActionTemplateParameters *)soap_instantiate_ns5__ActionTemplateParameters(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns5__ActionTemplateParameters **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__ActionTemplateParameters, sizeof(ns5__ActionTemplateParameters), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__ActionTemplateParameters(struct soap *soap, ns5__ActionTemplateParameters *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons5__ActionTemplateParameters(soap, tag ? tag : "ns5:ActionTemplateParameters", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns5__ActionTemplateParameters ** SOAP_FMAC4 soap_get_PointerTons5__ActionTemplateParameters(struct soap *soap, ns5__ActionTemplateParameters **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__ActionTemplateParameters(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__RecipientTemplate(struct soap *soap, ns5__RecipientTemplate *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns5__RecipientTemplate))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__RecipientTemplate(struct soap *soap, const char *tag, int id, ns5__RecipientTemplate *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__RecipientTemplate, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns5__RecipientTemplate ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 ns5__RecipientTemplate ** SOAP_FMAC4 soap_in_PointerTons5__RecipientTemplate(struct soap *soap, const char *tag, ns5__RecipientTemplate **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__RecipientTemplate **)soap_malloc(soap, sizeof(ns5__RecipientTemplate *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__RecipientTemplate *)soap_instantiate_ns5__RecipientTemplate(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns5__RecipientTemplate **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__RecipientTemplate, sizeof(ns5__RecipientTemplate), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__RecipientTemplate(struct soap *soap, ns5__RecipientTemplate *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons5__RecipientTemplate(soap, tag ? tag : "ns5:RecipientTemplate", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns5__RecipientTemplate ** SOAP_FMAC4 soap_get_PointerTons5__RecipientTemplate(struct soap *soap, ns5__RecipientTemplate **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__RecipientTemplate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__RecipientConfiguration(struct soap *soap, ns5__RecipientConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns5__RecipientConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__RecipientConfiguration(struct soap *soap, const char *tag, int id, ns5__RecipientConfiguration *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__RecipientConfiguration, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns5__RecipientConfiguration ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 ns5__RecipientConfiguration ** SOAP_FMAC4 soap_in_PointerTons5__RecipientConfiguration(struct soap *soap, const char *tag, ns5__RecipientConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__RecipientConfiguration **)soap_malloc(soap, sizeof(ns5__RecipientConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__RecipientConfiguration *)soap_instantiate_ns5__RecipientConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns5__RecipientConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__RecipientConfiguration, sizeof(ns5__RecipientConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__RecipientConfiguration(struct soap *soap, ns5__RecipientConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons5__RecipientConfiguration(soap, tag ? tag : "ns5:RecipientConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns5__RecipientConfiguration ** SOAP_FMAC4 soap_get_PointerTons5__RecipientConfiguration(struct soap *soap, ns5__RecipientConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__RecipientConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__ActionParameters(struct soap *soap, ns5__ActionParameters *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns5__ActionParameters))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__ActionParameters(struct soap *soap, const char *tag, int id, ns5__ActionParameters *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__ActionParameters, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns5__ActionParameters ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 ns5__ActionParameters ** SOAP_FMAC4 soap_in_PointerTons5__ActionParameters(struct soap *soap, const char *tag, ns5__ActionParameters **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__ActionParameters **)soap_malloc(soap, sizeof(ns5__ActionParameters *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__ActionParameters *)soap_instantiate_ns5__ActionParameters(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns5__ActionParameters **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__ActionParameters, sizeof(ns5__ActionParameters), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__ActionParameters(struct soap *soap, ns5__ActionParameters *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons5__ActionParameters(soap, tag ? tag : "ns5:ActionParameters", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns5__ActionParameters ** SOAP_FMAC4 soap_get_PointerTons5__ActionParameters(struct soap *soap, ns5__ActionParameters **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__ActionParameters(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__ActionRule(struct soap *soap, ns5__ActionRule *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns5__ActionRule))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__ActionRule(struct soap *soap, const char *tag, int id, ns5__ActionRule *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__ActionRule, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns5__ActionRule ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 ns5__ActionRule ** SOAP_FMAC4 soap_in_PointerTons5__ActionRule(struct soap *soap, const char *tag, ns5__ActionRule **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__ActionRule **)soap_malloc(soap, sizeof(ns5__ActionRule *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__ActionRule *)soap_instantiate_ns5__ActionRule(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns5__ActionRule **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__ActionRule, sizeof(ns5__ActionRule), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__ActionRule(struct soap *soap, ns5__ActionRule *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons5__ActionRule(soap, tag ? tag : "ns5:ActionRule", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns5__ActionRule ** SOAP_FMAC4 soap_get_PointerTons5__ActionRule(struct soap *soap, ns5__ActionRule **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__ActionRule(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__integer(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__integer))
		soap_serialize_xsd__integer(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__integer(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__integer, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__integer(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__integer(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__integer(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__integer, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__integer(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxsd__integer(soap, tag ? tag : "xsd:integer", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__integer(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__integer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__duration(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__duration))
		soap_serialize_xsd__duration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__duration(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__duration, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__duration(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__duration(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__duration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__duration, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__duration(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxsd__duration(soap, tag ? tag : "xsd:duration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__duration(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__duration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__Conditions(struct soap *soap, ns5__Conditions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns5__Conditions))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__Conditions(struct soap *soap, const char *tag, int id, ns5__Conditions *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__Conditions, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns5__Conditions ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 ns5__Conditions ** SOAP_FMAC4 soap_in_PointerTons5__Conditions(struct soap *soap, const char *tag, ns5__Conditions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__Conditions **)soap_malloc(soap, sizeof(ns5__Conditions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__Conditions *)soap_instantiate_ns5__Conditions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns5__Conditions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__Conditions, sizeof(ns5__Conditions), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__Conditions(struct soap *soap, ns5__Conditions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons5__Conditions(soap, tag ? tag : "ns5:Conditions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns5__Conditions ** SOAP_FMAC4 soap_get_PointerTons5__Conditions(struct soap *soap, ns5__Conditions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__Conditions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns4__BaseFaultType_FaultCause(struct soap *soap, _ns4__BaseFaultType_FaultCause *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns4__BaseFaultType_FaultCause))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns4__BaseFaultType_FaultCause(struct soap *soap, const char *tag, int id, _ns4__BaseFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns4__BaseFaultType_FaultCause, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns4__BaseFaultType_FaultCause ? type : NULL);
}

SOAP_FMAC3 _ns4__BaseFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_ns4__BaseFaultType_FaultCause(struct soap *soap, const char *tag, _ns4__BaseFaultType_FaultCause **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns4__BaseFaultType_FaultCause **)soap_malloc(soap, sizeof(_ns4__BaseFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns4__BaseFaultType_FaultCause *)soap_instantiate__ns4__BaseFaultType_FaultCause(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns4__BaseFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns4__BaseFaultType_FaultCause, sizeof(_ns4__BaseFaultType_FaultCause), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns4__BaseFaultType_FaultCause(struct soap *soap, _ns4__BaseFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns4__BaseFaultType_FaultCause(soap, tag ? tag : "ns4:BaseFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns4__BaseFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_ns4__BaseFaultType_FaultCause(struct soap *soap, _ns4__BaseFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns4__BaseFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_xml__lang(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__xml__lang))
		soap_serialize__xml__lang(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_xml__lang(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__xml__lang, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__xml__lang(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTo_xml__lang(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__xml__lang(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__xml__lang, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_xml__lang(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_xml__lang(soap, tag ? tag : "xml:lang", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTo_xml__lang(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_xml__lang(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns4__BaseFaultType_ErrorCode(struct soap *soap, _ns4__BaseFaultType_ErrorCode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns4__BaseFaultType_ErrorCode))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns4__BaseFaultType_ErrorCode(struct soap *soap, const char *tag, int id, _ns4__BaseFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns4__BaseFaultType_ErrorCode, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns4__BaseFaultType_ErrorCode ? type : NULL);
}

SOAP_FMAC3 _ns4__BaseFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_ns4__BaseFaultType_ErrorCode(struct soap *soap, const char *tag, _ns4__BaseFaultType_ErrorCode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns4__BaseFaultType_ErrorCode **)soap_malloc(soap, sizeof(_ns4__BaseFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns4__BaseFaultType_ErrorCode *)soap_instantiate__ns4__BaseFaultType_ErrorCode(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns4__BaseFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns4__BaseFaultType_ErrorCode, sizeof(_ns4__BaseFaultType_ErrorCode), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns4__BaseFaultType_ErrorCode(struct soap *soap, _ns4__BaseFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns4__BaseFaultType_ErrorCode(soap, tag ? tag : "ns4:BaseFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns4__BaseFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_ns4__BaseFaultType_ErrorCode(struct soap *soap, _ns4__BaseFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns4__BaseFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__nonNegativeInteger(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__nonNegativeInteger))
		soap_serialize_xsd__nonNegativeInteger(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__nonNegativeInteger(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__nonNegativeInteger, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__nonNegativeInteger(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__nonNegativeInteger(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__nonNegativeInteger(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__nonNegativeInteger, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__nonNegativeInteger(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxsd__nonNegativeInteger(soap, tag ? tag : "xsd:nonNegativeInteger", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__nonNegativeInteger(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__nonNegativeInteger(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__Subscribe_SubscriptionPolicy(struct soap *soap, _ns3__Subscribe_SubscriptionPolicy *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__Subscribe_SubscriptionPolicy))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__Subscribe_SubscriptionPolicy(struct soap *soap, const char *tag, int id, _ns3__Subscribe_SubscriptionPolicy *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__Subscribe_SubscriptionPolicy, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns3__Subscribe_SubscriptionPolicy ? type : NULL);
}

SOAP_FMAC3 _ns3__Subscribe_SubscriptionPolicy ** SOAP_FMAC4 soap_in_PointerTo_ns3__Subscribe_SubscriptionPolicy(struct soap *soap, const char *tag, _ns3__Subscribe_SubscriptionPolicy **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__Subscribe_SubscriptionPolicy **)soap_malloc(soap, sizeof(_ns3__Subscribe_SubscriptionPolicy *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__Subscribe_SubscriptionPolicy *)soap_instantiate__ns3__Subscribe_SubscriptionPolicy(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns3__Subscribe_SubscriptionPolicy **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__Subscribe_SubscriptionPolicy, sizeof(_ns3__Subscribe_SubscriptionPolicy), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__Subscribe_SubscriptionPolicy(struct soap *soap, _ns3__Subscribe_SubscriptionPolicy *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns3__Subscribe_SubscriptionPolicy(soap, tag ? tag : "ns3:Subscribe-SubscriptionPolicy", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__Subscribe_SubscriptionPolicy ** SOAP_FMAC4 soap_get_PointerTo_ns3__Subscribe_SubscriptionPolicy(struct soap *soap, _ns3__Subscribe_SubscriptionPolicy **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__Subscribe_SubscriptionPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__AbsoluteOrRelativeTimeType(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__AbsoluteOrRelativeTimeType))
		soap_serialize_ns3__AbsoluteOrRelativeTimeType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__AbsoluteOrRelativeTimeType(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__AbsoluteOrRelativeTimeType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns3__AbsoluteOrRelativeTimeType(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTons3__AbsoluteOrRelativeTimeType(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns3__AbsoluteOrRelativeTimeType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__AbsoluteOrRelativeTimeType, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__AbsoluteOrRelativeTimeType(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__AbsoluteOrRelativeTimeType(soap, tag ? tag : "ns3:AbsoluteOrRelativeTimeType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTons3__AbsoluteOrRelativeTimeType(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__AbsoluteOrRelativeTimeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__NotificationMessageHolderType(struct soap *soap, ns3__NotificationMessageHolderType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__NotificationMessageHolderType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__NotificationMessageHolderType(struct soap *soap, const char *tag, int id, ns3__NotificationMessageHolderType *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__NotificationMessageHolderType, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns3__NotificationMessageHolderType ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 ns3__NotificationMessageHolderType ** SOAP_FMAC4 soap_in_PointerTons3__NotificationMessageHolderType(struct soap *soap, const char *tag, ns3__NotificationMessageHolderType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__NotificationMessageHolderType **)soap_malloc(soap, sizeof(ns3__NotificationMessageHolderType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__NotificationMessageHolderType *)soap_instantiate_ns3__NotificationMessageHolderType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__NotificationMessageHolderType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__NotificationMessageHolderType, sizeof(ns3__NotificationMessageHolderType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__NotificationMessageHolderType(struct soap *soap, ns3__NotificationMessageHolderType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__NotificationMessageHolderType(soap, tag ? tag : "ns3:NotificationMessageHolderType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__NotificationMessageHolderType ** SOAP_FMAC4 soap_get_PointerTons3__NotificationMessageHolderType(struct soap *soap, ns3__NotificationMessageHolderType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__NotificationMessageHolderType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodateTime(struct soap *soap, time_t *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_dateTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTodateTime(struct soap *soap, const char *tag, int id, time_t *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_dateTime, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_dateTime(soap, tag, id, *a, type);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_in_PointerTodateTime(struct soap *soap, const char *tag, time_t **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (time_t **)soap_malloc(soap, sizeof(time_t *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_dateTime(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (time_t **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_dateTime, sizeof(time_t), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodateTime(struct soap *soap, time_t *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTodateTime(soap, tag ? tag : "dateTime", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_get_PointerTodateTime(struct soap *soap, time_t **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTodateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__SubscriptionPolicyType(struct soap *soap, ns3__SubscriptionPolicyType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__SubscriptionPolicyType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__SubscriptionPolicyType(struct soap *soap, const char *tag, int id, ns3__SubscriptionPolicyType *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__SubscriptionPolicyType, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns3__SubscriptionPolicyType ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 ns3__SubscriptionPolicyType ** SOAP_FMAC4 soap_in_PointerTons3__SubscriptionPolicyType(struct soap *soap, const char *tag, ns3__SubscriptionPolicyType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__SubscriptionPolicyType **)soap_malloc(soap, sizeof(ns3__SubscriptionPolicyType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__SubscriptionPolicyType *)soap_instantiate_ns3__SubscriptionPolicyType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__SubscriptionPolicyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__SubscriptionPolicyType, sizeof(ns3__SubscriptionPolicyType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__SubscriptionPolicyType(struct soap *soap, ns3__SubscriptionPolicyType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__SubscriptionPolicyType(soap, tag ? tag : "ns3:SubscriptionPolicyType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__SubscriptionPolicyType ** SOAP_FMAC4 soap_get_PointerTons3__SubscriptionPolicyType(struct soap *soap, ns3__SubscriptionPolicyType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__SubscriptionPolicyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__FilterType(struct soap *soap, ns3__FilterType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__FilterType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__FilterType(struct soap *soap, const char *tag, int id, ns3__FilterType *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__FilterType, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns3__FilterType ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 ns3__FilterType ** SOAP_FMAC4 soap_in_PointerTons3__FilterType(struct soap *soap, const char *tag, ns3__FilterType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__FilterType **)soap_malloc(soap, sizeof(ns3__FilterType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__FilterType *)soap_instantiate_ns3__FilterType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__FilterType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__FilterType, sizeof(ns3__FilterType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__FilterType(struct soap *soap, ns3__FilterType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__FilterType(soap, tag ? tag : "ns3:FilterType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__FilterType ** SOAP_FMAC4 soap_get_PointerTons3__FilterType(struct soap *soap, ns3__FilterType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__FilterType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobool(struct soap *soap, bool *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_bool);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobool(struct soap *soap, const char *tag, int id, bool *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bool, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_bool(soap, tag, id, *a, type);
}

SOAP_FMAC3 bool ** SOAP_FMAC4 soap_in_PointerTobool(struct soap *soap, const char *tag, bool **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (bool **)soap_malloc(soap, sizeof(bool *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bool(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (bool **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bool, sizeof(bool), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobool(struct soap *soap, bool *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTobool(soap, tag ? tag : "boolean", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool ** SOAP_FMAC4 soap_get_PointerTobool(struct soap *soap, bool **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__TopicExpressionType(struct soap *soap, ns3__TopicExpressionType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__TopicExpressionType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__TopicExpressionType(struct soap *soap, const char *tag, int id, ns3__TopicExpressionType *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__TopicExpressionType, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns3__TopicExpressionType ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 ns3__TopicExpressionType ** SOAP_FMAC4 soap_in_PointerTons3__TopicExpressionType(struct soap *soap, const char *tag, ns3__TopicExpressionType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__TopicExpressionType **)soap_malloc(soap, sizeof(ns3__TopicExpressionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__TopicExpressionType *)soap_instantiate_ns3__TopicExpressionType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__TopicExpressionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__TopicExpressionType, sizeof(ns3__TopicExpressionType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__TopicExpressionType(struct soap *soap, ns3__TopicExpressionType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__TopicExpressionType(soap, tag ? tag : "ns3:TopicExpressionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__TopicExpressionType ** SOAP_FMAC4 soap_get_PointerTons3__TopicExpressionType(struct soap *soap, ns3__TopicExpressionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__TopicExpressionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__EndpointReferenceType(struct soap *soap, ns6__EndpointReferenceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__EndpointReferenceType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__EndpointReferenceType(struct soap *soap, const char *tag, int id, ns6__EndpointReferenceType *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__EndpointReferenceType, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns6__EndpointReferenceType ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 ns6__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTons6__EndpointReferenceType(struct soap *soap, const char *tag, ns6__EndpointReferenceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns6__EndpointReferenceType **)soap_malloc(soap, sizeof(ns6__EndpointReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns6__EndpointReferenceType *)soap_instantiate_ns6__EndpointReferenceType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns6__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__EndpointReferenceType, sizeof(ns6__EndpointReferenceType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__EndpointReferenceType(struct soap *soap, ns6__EndpointReferenceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons6__EndpointReferenceType(soap, tag ? tag : "ns6:EndpointReferenceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns6__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTons6__EndpointReferenceType(struct soap *soap, ns6__EndpointReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__EndpointReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__Documentation(struct soap *soap, ns2__Documentation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__Documentation))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__Documentation(struct soap *soap, const char *tag, int id, ns2__Documentation *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__Documentation, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__Documentation ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 ns2__Documentation ** SOAP_FMAC4 soap_in_PointerTons2__Documentation(struct soap *soap, const char *tag, ns2__Documentation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__Documentation **)soap_malloc(soap, sizeof(ns2__Documentation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__Documentation *)soap_instantiate_ns2__Documentation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__Documentation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__Documentation, sizeof(ns2__Documentation), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__Documentation(struct soap *soap, ns2__Documentation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__Documentation(soap, tag ? tag : "ns2:Documentation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__Documentation ** SOAP_FMAC4 soap_get_PointerTons2__Documentation(struct soap *soap, ns2__Documentation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__Documentation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ScheduledEvents(struct soap *soap, ns1__ScheduledEvents *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ScheduledEvents))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ScheduledEvents(struct soap *soap, const char *tag, int id, ns1__ScheduledEvents *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ScheduledEvents, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__ScheduledEvents ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 ns1__ScheduledEvents ** SOAP_FMAC4 soap_in_PointerTons1__ScheduledEvents(struct soap *soap, const char *tag, ns1__ScheduledEvents **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ScheduledEvents **)soap_malloc(soap, sizeof(ns1__ScheduledEvents *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ScheduledEvents *)soap_instantiate_ns1__ScheduledEvents(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__ScheduledEvents **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ScheduledEvents, sizeof(ns1__ScheduledEvents), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ScheduledEvents(struct soap *soap, ns1__ScheduledEvents *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ScheduledEvents(soap, tag ? tag : "ns1:ScheduledEvents", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ScheduledEvents ** SOAP_FMAC4 soap_get_PointerTons1__ScheduledEvents(struct soap *soap, ns1__ScheduledEvents **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ScheduledEvents(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ScheduleFilter(struct soap *soap, ns1__ScheduleFilter *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ScheduleFilter))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ScheduleFilter(struct soap *soap, const char *tag, int id, ns1__ScheduleFilter *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ScheduleFilter, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__ScheduleFilter ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 ns1__ScheduleFilter ** SOAP_FMAC4 soap_in_PointerTons1__ScheduleFilter(struct soap *soap, const char *tag, ns1__ScheduleFilter **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ScheduleFilter **)soap_malloc(soap, sizeof(ns1__ScheduleFilter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ScheduleFilter *)soap_instantiate_ns1__ScheduleFilter(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__ScheduleFilter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ScheduleFilter, sizeof(ns1__ScheduleFilter), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ScheduleFilter(struct soap *soap, ns1__ScheduleFilter *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ScheduleFilter(soap, tag ? tag : "ns1:ScheduleFilter", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ScheduleFilter ** SOAP_FMAC4 soap_get_PointerTons1__ScheduleFilter(struct soap *soap, ns1__ScheduleFilter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ScheduleFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__NewScheduledEvent(struct soap *soap, ns1__NewScheduledEvent *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__NewScheduledEvent))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__NewScheduledEvent(struct soap *soap, const char *tag, int id, ns1__NewScheduledEvent *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__NewScheduledEvent, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__NewScheduledEvent ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 ns1__NewScheduledEvent ** SOAP_FMAC4 soap_in_PointerTons1__NewScheduledEvent(struct soap *soap, const char *tag, ns1__NewScheduledEvent **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__NewScheduledEvent **)soap_malloc(soap, sizeof(ns1__NewScheduledEvent *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__NewScheduledEvent *)soap_instantiate_ns1__NewScheduledEvent(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__NewScheduledEvent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__NewScheduledEvent, sizeof(ns1__NewScheduledEvent), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__NewScheduledEvent(struct soap *soap, ns1__NewScheduledEvent *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__NewScheduledEvent(soap, tag ? tag : "ns1:NewScheduledEvent", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__NewScheduledEvent ** SOAP_FMAC4 soap_get_PointerTons1__NewScheduledEvent(struct soap *soap, ns1__NewScheduledEvent **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__NewScheduledEvent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__TopicSetType(struct soap *soap, ns2__TopicSetType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__TopicSetType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__TopicSetType(struct soap *soap, const char *tag, int id, ns2__TopicSetType *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__TopicSetType, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__TopicSetType ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 ns2__TopicSetType ** SOAP_FMAC4 soap_in_PointerTons2__TopicSetType(struct soap *soap, const char *tag, ns2__TopicSetType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__TopicSetType **)soap_malloc(soap, sizeof(ns2__TopicSetType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__TopicSetType *)soap_instantiate_ns2__TopicSetType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__TopicSetType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__TopicSetType, sizeof(ns2__TopicSetType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__TopicSetType(struct soap *soap, ns2__TopicSetType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__TopicSetType(soap, tag ? tag : "ns2:TopicSetType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__TopicSetType ** SOAP_FMAC4 soap_get_PointerTons2__TopicSetType(struct soap *soap, ns2__TopicSetType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__TopicSetType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ScheduledType(struct soap *soap, ns1__ScheduledType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_ns1__ScheduledType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ScheduledType(struct soap *soap, const char *tag, int id, ns1__ScheduledType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ScheduledType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__ScheduledType(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__ScheduledType ** SOAP_FMAC4 soap_in_PointerTons1__ScheduledType(struct soap *soap, const char *tag, ns1__ScheduledType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ScheduledType **)soap_malloc(soap, sizeof(ns1__ScheduledType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__ScheduledType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__ScheduledType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ScheduledType, sizeof(ns1__ScheduledType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ScheduledType(struct soap *soap, ns1__ScheduledType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ScheduledType(soap, tag ? tag : "ns1:ScheduledType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ScheduledType ** SOAP_FMAC4 soap_get_PointerTons1__ScheduledType(struct soap *soap, ns1__ScheduledType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ScheduledType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ICalendar(struct soap *soap, ns1__ICalendar *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ICalendar))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ICalendar(struct soap *soap, const char *tag, int id, ns1__ICalendar *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ICalendar, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__ICalendar ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 ns1__ICalendar ** SOAP_FMAC4 soap_in_PointerTons1__ICalendar(struct soap *soap, const char *tag, ns1__ICalendar **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ICalendar **)soap_malloc(soap, sizeof(ns1__ICalendar *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ICalendar *)soap_instantiate_ns1__ICalendar(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__ICalendar **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ICalendar, sizeof(ns1__ICalendar), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ICalendar(struct soap *soap, ns1__ICalendar *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ICalendar(soap, tag ? tag : "ns1:ICalendar", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ICalendar ** SOAP_FMAC4 soap_get_PointerTons1__ICalendar(struct soap *soap, ns1__ICalendar **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ICalendar(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ScheduledEvent(struct soap *soap, ns1__ScheduledEvent *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ScheduledEvent))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ScheduledEvent(struct soap *soap, const char *tag, int id, ns1__ScheduledEvent *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ScheduledEvent, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__ScheduledEvent ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 ns1__ScheduledEvent ** SOAP_FMAC4 soap_in_PointerTons1__ScheduledEvent(struct soap *soap, const char *tag, ns1__ScheduledEvent **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ScheduledEvent **)soap_malloc(soap, sizeof(ns1__ScheduledEvent *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ScheduledEvent *)soap_instantiate_ns1__ScheduledEvent(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__ScheduledEvent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ScheduledEvent, sizeof(ns1__ScheduledEvent), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ScheduledEvent(struct soap *soap, ns1__ScheduledEvent *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ScheduledEvent(soap, tag ? tag : "ns1:ScheduledEvent", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ScheduledEvent ** SOAP_FMAC4 soap_get_PointerTons1__ScheduledEvent(struct soap *soap, ns1__ScheduledEvent **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ScheduledEvent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Schedule(struct soap *soap, ns1__Schedule *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Schedule))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Schedule(struct soap *soap, const char *tag, int id, ns1__Schedule *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Schedule, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__Schedule ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 ns1__Schedule ** SOAP_FMAC4 soap_in_PointerTons1__Schedule(struct soap *soap, const char *tag, ns1__Schedule **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__Schedule **)soap_malloc(soap, sizeof(ns1__Schedule *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__Schedule *)soap_instantiate_ns1__Schedule(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__Schedule **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Schedule, sizeof(ns1__Schedule), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Schedule(struct soap *soap, ns1__Schedule *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__Schedule(soap, tag ? tag : "ns1:Schedule", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__Schedule ** SOAP_FMAC4 soap_get_PointerTons1__Schedule(struct soap *soap, ns1__Schedule **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Schedule(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__string(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_std__string))
		soap_serialize_std__string(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__string(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_std__string, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_std__string(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTostd__string(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_std__string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_std__string, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__string(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTostd__string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTostd__string(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE__QName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__QName(soap, tag ? tag : "QName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_new_string(struct soap *soap, int n)
{
	char * *a = static_cast<char * *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(char *)));
	for (char * *p = a; p && n--; ++p)
		soap_default_string(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfxsd__QName(struct soap *soap, std::vector<std::string> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfxsd__QName(struct soap *soap, const std::vector<std::string> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_xsd__QName(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfxsd__QName(struct soap *soap, const char *tag, int id, const std::vector<std::string> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		std::string soap_tmp(soap_QName2s(soap, (*i).c_str()));
		if (soap_out_xsd__QName(soap, tag, id, &soap_tmp, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string> * SOAP_FMAC4 soap_in_std__vectorTemplateOfxsd__QName(struct soap *soap, const char *tag, std::vector<std::string> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfxsd__QName(soap)))
			return NULL;
		if (!a->empty() && a->size() == a->capacity())
		{	const void *p = &a->front();
			a->emplace_back();
			DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Vector capacity increased to %lu to fit %lu items: updating pointers\n", a->capacity(), a->size()));
			soap_update_pointers(soap, (const char*)&a->front(), (const char*)p, (a->size() - 1) * sizeof(std::string));
		}
		else
		{	a->emplace_back();
		}
		std::string *n = &a->back();
		soap_default_xsd__QName(soap, n);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_xsd__QName, SOAP_TYPE_std__vectorTemplateOfxsd__QName, sizeof(std::string), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_xsd__QName(soap, tag, NULL, "xsd:QName"))
				break;
		}
		else
		{	if (!soap_in_xsd__QName(soap, tag, n, "xsd:QName"))
			{	a->pop_back();
				break;
			}
		}
		soap_end_shaky(soap, soap_shaky);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::string>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfxsd__QName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfxsd__QName(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<std::string> *p;
	size_t k = sizeof(std::vector<std::string> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<std::string> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<std::string> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<std::string>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfxsd__QName, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf_ns2__TopicNamespaceType_Topic(struct soap *soap, std::vector<_ns2__TopicNamespaceType_Topic> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf_ns2__TopicNamespaceType_Topic(struct soap *soap, const std::vector<_ns2__TopicNamespaceType_Topic> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<_ns2__TopicNamespaceType_Topic> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf_ns2__TopicNamespaceType_Topic(struct soap *soap, const char *tag, int id, const std::vector<_ns2__TopicNamespaceType_Topic> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<_ns2__TopicNamespaceType_Topic> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<_ns2__TopicNamespaceType_Topic> * SOAP_FMAC4 soap_in_std__vectorTemplateOf_ns2__TopicNamespaceType_Topic(struct soap *soap, const char *tag, std::vector<_ns2__TopicNamespaceType_Topic> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOf_ns2__TopicNamespaceType_Topic(soap)))
			return NULL;
		if (!a->empty() && a->size() == a->capacity())
		{	const void *p = &a->front();
			a->emplace_back();
			DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Vector capacity increased to %lu to fit %lu items: updating pointers\n", a->capacity(), a->size()));
			soap_update_pointers(soap, (const char*)&a->front(), (const char*)p, (a->size() - 1) * sizeof(_ns2__TopicNamespaceType_Topic));
		}
		else
		{	a->emplace_back();
		}
		_ns2__TopicNamespaceType_Topic *n = &a->back();
		n->soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE__ns2__TopicNamespaceType_Topic, SOAP_TYPE_std__vectorTemplateOf_ns2__TopicNamespaceType_Topic, sizeof(_ns2__TopicNamespaceType_Topic), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in__ns2__TopicNamespaceType_Topic(soap, tag, NULL, ""))
				break;
		}
		else
		{	if (!soap_in__ns2__TopicNamespaceType_Topic(soap, tag, n, ""))
			{	a->pop_back();
				break;
			}
		}
		soap_end_shaky(soap, soap_shaky);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<_ns2__TopicNamespaceType_Topic>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOf_ns2__TopicNamespaceType_Topic(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOf_ns2__TopicNamespaceType_Topic(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<_ns2__TopicNamespaceType_Topic> *p;
	size_t k = sizeof(std::vector<_ns2__TopicNamespaceType_Topic> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<_ns2__TopicNamespaceType_Topic> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<_ns2__TopicNamespaceType_Topic> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<_ns2__TopicNamespaceType_Topic>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOf_ns2__TopicNamespaceType_Topic, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__TopicType(struct soap *soap, std::vector<ns2__TopicType *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__TopicType(struct soap *soap, const std::vector<ns2__TopicType *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns2__TopicType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__TopicType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__TopicType(struct soap *soap, const char *tag, int id, const std::vector<ns2__TopicType *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns2__TopicType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__TopicType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__TopicType *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__TopicType(struct soap *soap, const char *tag, std::vector<ns2__TopicType *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__TopicType(soap)))
			return NULL;
		a->emplace_back();
		ns2__TopicType * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_ns2__TopicType, SOAP_TYPE_std__vectorTemplateOfPointerTons2__TopicType, sizeof(ns2__TopicType), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons2__TopicType(soap, tag, NULL, "ns2:TopicType"))
				break;
		}
		else
		{	if (!soap_in_PointerTons2__TopicType(soap, tag, n, "ns2:TopicType"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__TopicType *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__TopicType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__TopicType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns2__TopicType *> *p;
	size_t k = sizeof(std::vector<ns2__TopicType *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns2__TopicType *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns2__TopicType *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns2__TopicType *>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfPointerTons2__TopicType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons5__UsedActionRule(struct soap *soap, std::vector<ns5__UsedActionRule *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons5__UsedActionRule(struct soap *soap, const std::vector<ns5__UsedActionRule *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns5__UsedActionRule *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons5__UsedActionRule(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons5__UsedActionRule(struct soap *soap, const char *tag, int id, const std::vector<ns5__UsedActionRule *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns5__UsedActionRule *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons5__UsedActionRule(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns5__UsedActionRule *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons5__UsedActionRule(struct soap *soap, const char *tag, std::vector<ns5__UsedActionRule *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons5__UsedActionRule(soap)))
			return NULL;
		a->emplace_back();
		ns5__UsedActionRule * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_ns5__UsedActionRule, SOAP_TYPE_std__vectorTemplateOfPointerTons5__UsedActionRule, sizeof(ns5__UsedActionRule), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons5__UsedActionRule(soap, tag, NULL, "ns5:UsedActionRule"))
				break;
		}
		else
		{	if (!soap_in_PointerTons5__UsedActionRule(soap, tag, n, "ns5:UsedActionRule"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns5__UsedActionRule *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons5__UsedActionRule(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons5__UsedActionRule(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns5__UsedActionRule *> *p;
	size_t k = sizeof(std::vector<ns5__UsedActionRule *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns5__UsedActionRule *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns5__UsedActionRule *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns5__UsedActionRule *>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfPointerTons5__UsedActionRule, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons5__UsedActionConfiguration(struct soap *soap, std::vector<ns5__UsedActionConfiguration *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons5__UsedActionConfiguration(struct soap *soap, const std::vector<ns5__UsedActionConfiguration *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns5__UsedActionConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons5__UsedActionConfiguration(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons5__UsedActionConfiguration(struct soap *soap, const char *tag, int id, const std::vector<ns5__UsedActionConfiguration *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns5__UsedActionConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons5__UsedActionConfiguration(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns5__UsedActionConfiguration *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons5__UsedActionConfiguration(struct soap *soap, const char *tag, std::vector<ns5__UsedActionConfiguration *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons5__UsedActionConfiguration(soap)))
			return NULL;
		a->emplace_back();
		ns5__UsedActionConfiguration * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_ns5__UsedActionConfiguration, SOAP_TYPE_std__vectorTemplateOfPointerTons5__UsedActionConfiguration, sizeof(ns5__UsedActionConfiguration), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons5__UsedActionConfiguration(soap, tag, NULL, "ns5:UsedActionConfiguration"))
				break;
		}
		else
		{	if (!soap_in_PointerTons5__UsedActionConfiguration(soap, tag, n, "ns5:UsedActionConfiguration"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns5__UsedActionConfiguration *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons5__UsedActionConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons5__UsedActionConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns5__UsedActionConfiguration *> *p;
	size_t k = sizeof(std::vector<ns5__UsedActionConfiguration *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns5__UsedActionConfiguration *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns5__UsedActionConfiguration *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns5__UsedActionConfiguration *>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfPointerTons5__UsedActionConfiguration, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons5__ActionTemplateParameter(struct soap *soap, std::vector<ns5__ActionTemplateParameter *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons5__ActionTemplateParameter(struct soap *soap, const std::vector<ns5__ActionTemplateParameter *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns5__ActionTemplateParameter *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons5__ActionTemplateParameter(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons5__ActionTemplateParameter(struct soap *soap, const char *tag, int id, const std::vector<ns5__ActionTemplateParameter *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns5__ActionTemplateParameter *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons5__ActionTemplateParameter(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns5__ActionTemplateParameter *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons5__ActionTemplateParameter(struct soap *soap, const char *tag, std::vector<ns5__ActionTemplateParameter *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons5__ActionTemplateParameter(soap)))
			return NULL;
		a->emplace_back();
		ns5__ActionTemplateParameter * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_ns5__ActionTemplateParameter, SOAP_TYPE_std__vectorTemplateOfPointerTons5__ActionTemplateParameter, sizeof(ns5__ActionTemplateParameter), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons5__ActionTemplateParameter(soap, tag, NULL, "ns5:ActionTemplateParameter"))
				break;
		}
		else
		{	if (!soap_in_PointerTons5__ActionTemplateParameter(soap, tag, n, "ns5:ActionTemplateParameter"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns5__ActionTemplateParameter *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons5__ActionTemplateParameter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons5__ActionTemplateParameter(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns5__ActionTemplateParameter *> *p;
	size_t k = sizeof(std::vector<ns5__ActionTemplateParameter *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns5__ActionTemplateParameter *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns5__ActionTemplateParameter *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns5__ActionTemplateParameter *>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfPointerTons5__ActionTemplateParameter, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons5__ActionTemplate(struct soap *soap, std::vector<ns5__ActionTemplate *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons5__ActionTemplate(struct soap *soap, const std::vector<ns5__ActionTemplate *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns5__ActionTemplate *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons5__ActionTemplate(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons5__ActionTemplate(struct soap *soap, const char *tag, int id, const std::vector<ns5__ActionTemplate *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns5__ActionTemplate *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons5__ActionTemplate(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns5__ActionTemplate *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons5__ActionTemplate(struct soap *soap, const char *tag, std::vector<ns5__ActionTemplate *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons5__ActionTemplate(soap)))
			return NULL;
		a->emplace_back();
		ns5__ActionTemplate * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_ns5__ActionTemplate, SOAP_TYPE_std__vectorTemplateOfPointerTons5__ActionTemplate, sizeof(ns5__ActionTemplate), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons5__ActionTemplate(soap, tag, NULL, "ns5:ActionTemplate"))
				break;
		}
		else
		{	if (!soap_in_PointerTons5__ActionTemplate(soap, tag, n, "ns5:ActionTemplate"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns5__ActionTemplate *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons5__ActionTemplate(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons5__ActionTemplate(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns5__ActionTemplate *> *p;
	size_t k = sizeof(std::vector<ns5__ActionTemplate *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns5__ActionTemplate *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns5__ActionTemplate *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns5__ActionTemplate *>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfPointerTons5__ActionTemplate, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons5__ActionParameter(struct soap *soap, std::vector<ns5__ActionParameter *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons5__ActionParameter(struct soap *soap, const std::vector<ns5__ActionParameter *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns5__ActionParameter *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons5__ActionParameter(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons5__ActionParameter(struct soap *soap, const char *tag, int id, const std::vector<ns5__ActionParameter *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns5__ActionParameter *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons5__ActionParameter(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns5__ActionParameter *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons5__ActionParameter(struct soap *soap, const char *tag, std::vector<ns5__ActionParameter *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons5__ActionParameter(soap)))
			return NULL;
		a->emplace_back();
		ns5__ActionParameter * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_ns5__ActionParameter, SOAP_TYPE_std__vectorTemplateOfPointerTons5__ActionParameter, sizeof(ns5__ActionParameter), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons5__ActionParameter(soap, tag, NULL, "ns5:ActionParameter"))
				break;
		}
		else
		{	if (!soap_in_PointerTons5__ActionParameter(soap, tag, n, "ns5:ActionParameter"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns5__ActionParameter *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons5__ActionParameter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons5__ActionParameter(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns5__ActionParameter *> *p;
	size_t k = sizeof(std::vector<ns5__ActionParameter *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns5__ActionParameter *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns5__ActionParameter *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns5__ActionParameter *>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfPointerTons5__ActionParameter, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons5__ActionConfiguration(struct soap *soap, std::vector<ns5__ActionConfiguration *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons5__ActionConfiguration(struct soap *soap, const std::vector<ns5__ActionConfiguration *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns5__ActionConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons5__ActionConfiguration(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons5__ActionConfiguration(struct soap *soap, const char *tag, int id, const std::vector<ns5__ActionConfiguration *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns5__ActionConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons5__ActionConfiguration(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns5__ActionConfiguration *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons5__ActionConfiguration(struct soap *soap, const char *tag, std::vector<ns5__ActionConfiguration *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons5__ActionConfiguration(soap)))
			return NULL;
		a->emplace_back();
		ns5__ActionConfiguration * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_ns5__ActionConfiguration, SOAP_TYPE_std__vectorTemplateOfPointerTons5__ActionConfiguration, sizeof(ns5__ActionConfiguration), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons5__ActionConfiguration(soap, tag, NULL, "ns5:ActionConfiguration"))
				break;
		}
		else
		{	if (!soap_in_PointerTons5__ActionConfiguration(soap, tag, n, "ns5:ActionConfiguration"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns5__ActionConfiguration *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons5__ActionConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons5__ActionConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns5__ActionConfiguration *> *p;
	size_t k = sizeof(std::vector<ns5__ActionConfiguration *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns5__ActionConfiguration *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns5__ActionConfiguration *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns5__ActionConfiguration *>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfPointerTons5__ActionConfiguration, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons5__RecipientTemplate(struct soap *soap, std::vector<ns5__RecipientTemplate *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons5__RecipientTemplate(struct soap *soap, const std::vector<ns5__RecipientTemplate *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns5__RecipientTemplate *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons5__RecipientTemplate(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons5__RecipientTemplate(struct soap *soap, const char *tag, int id, const std::vector<ns5__RecipientTemplate *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns5__RecipientTemplate *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons5__RecipientTemplate(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns5__RecipientTemplate *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons5__RecipientTemplate(struct soap *soap, const char *tag, std::vector<ns5__RecipientTemplate *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons5__RecipientTemplate(soap)))
			return NULL;
		a->emplace_back();
		ns5__RecipientTemplate * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_ns5__RecipientTemplate, SOAP_TYPE_std__vectorTemplateOfPointerTons5__RecipientTemplate, sizeof(ns5__RecipientTemplate), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons5__RecipientTemplate(soap, tag, NULL, "ns5:RecipientTemplate"))
				break;
		}
		else
		{	if (!soap_in_PointerTons5__RecipientTemplate(soap, tag, n, "ns5:RecipientTemplate"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns5__RecipientTemplate *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons5__RecipientTemplate(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons5__RecipientTemplate(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns5__RecipientTemplate *> *p;
	size_t k = sizeof(std::vector<ns5__RecipientTemplate *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns5__RecipientTemplate *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns5__RecipientTemplate *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns5__RecipientTemplate *>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfPointerTons5__RecipientTemplate, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons5__RecipientConfiguration(struct soap *soap, std::vector<ns5__RecipientConfiguration *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons5__RecipientConfiguration(struct soap *soap, const std::vector<ns5__RecipientConfiguration *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns5__RecipientConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons5__RecipientConfiguration(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons5__RecipientConfiguration(struct soap *soap, const char *tag, int id, const std::vector<ns5__RecipientConfiguration *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns5__RecipientConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons5__RecipientConfiguration(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns5__RecipientConfiguration *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons5__RecipientConfiguration(struct soap *soap, const char *tag, std::vector<ns5__RecipientConfiguration *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons5__RecipientConfiguration(soap)))
			return NULL;
		a->emplace_back();
		ns5__RecipientConfiguration * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_ns5__RecipientConfiguration, SOAP_TYPE_std__vectorTemplateOfPointerTons5__RecipientConfiguration, sizeof(ns5__RecipientConfiguration), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons5__RecipientConfiguration(soap, tag, NULL, "ns5:RecipientConfiguration"))
				break;
		}
		else
		{	if (!soap_in_PointerTons5__RecipientConfiguration(soap, tag, n, "ns5:RecipientConfiguration"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns5__RecipientConfiguration *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons5__RecipientConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons5__RecipientConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns5__RecipientConfiguration *> *p;
	size_t k = sizeof(std::vector<ns5__RecipientConfiguration *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns5__RecipientConfiguration *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns5__RecipientConfiguration *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns5__RecipientConfiguration *>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfPointerTons5__RecipientConfiguration, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons5__ActionRule(struct soap *soap, std::vector<ns5__ActionRule *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons5__ActionRule(struct soap *soap, const std::vector<ns5__ActionRule *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns5__ActionRule *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons5__ActionRule(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons5__ActionRule(struct soap *soap, const char *tag, int id, const std::vector<ns5__ActionRule *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns5__ActionRule *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons5__ActionRule(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns5__ActionRule *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons5__ActionRule(struct soap *soap, const char *tag, std::vector<ns5__ActionRule *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons5__ActionRule(soap)))
			return NULL;
		a->emplace_back();
		ns5__ActionRule * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_ns5__ActionRule, SOAP_TYPE_std__vectorTemplateOfPointerTons5__ActionRule, sizeof(ns5__ActionRule), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons5__ActionRule(soap, tag, NULL, "ns5:ActionRule"))
				break;
		}
		else
		{	if (!soap_in_PointerTons5__ActionRule(soap, tag, n, "ns5:ActionRule"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns5__ActionRule *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons5__ActionRule(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons5__ActionRule(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns5__ActionRule *> *p;
	size_t k = sizeof(std::vector<ns5__ActionRule *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns5__ActionRule *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns5__ActionRule *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns5__ActionRule *>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfPointerTons5__ActionRule, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons3__FilterType(struct soap *soap, std::vector<ns3__FilterType *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons3__FilterType(struct soap *soap, const std::vector<ns3__FilterType *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns3__FilterType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons3__FilterType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons3__FilterType(struct soap *soap, const char *tag, int id, const std::vector<ns3__FilterType *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns3__FilterType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons3__FilterType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns3__FilterType *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons3__FilterType(struct soap *soap, const char *tag, std::vector<ns3__FilterType *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons3__FilterType(soap)))
			return NULL;
		a->emplace_back();
		ns3__FilterType * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_ns3__FilterType, SOAP_TYPE_std__vectorTemplateOfPointerTons3__FilterType, sizeof(ns3__FilterType), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons3__FilterType(soap, tag, NULL, "ns3:FilterType"))
				break;
		}
		else
		{	if (!soap_in_PointerTons3__FilterType(soap, tag, n, "ns3:FilterType"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns3__FilterType *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons3__FilterType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons3__FilterType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns3__FilterType *> *p;
	size_t k = sizeof(std::vector<ns3__FilterType *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns3__FilterType *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns3__FilterType *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns3__FilterType *>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfPointerTons3__FilterType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf_ns4__BaseFaultType_Description(struct soap *soap, std::vector<_ns4__BaseFaultType_Description> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf_ns4__BaseFaultType_Description(struct soap *soap, const std::vector<_ns4__BaseFaultType_Description> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<_ns4__BaseFaultType_Description> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf_ns4__BaseFaultType_Description(struct soap *soap, const char *tag, int id, const std::vector<_ns4__BaseFaultType_Description> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<_ns4__BaseFaultType_Description> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<_ns4__BaseFaultType_Description> * SOAP_FMAC4 soap_in_std__vectorTemplateOf_ns4__BaseFaultType_Description(struct soap *soap, const char *tag, std::vector<_ns4__BaseFaultType_Description> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOf_ns4__BaseFaultType_Description(soap)))
			return NULL;
		if (!a->empty() && a->size() == a->capacity())
		{	const void *p = &a->front();
			a->emplace_back();
			DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Vector capacity increased to %lu to fit %lu items: updating pointers\n", a->capacity(), a->size()));
			soap_update_pointers(soap, (const char*)&a->front(), (const char*)p, (a->size() - 1) * sizeof(_ns4__BaseFaultType_Description));
		}
		else
		{	a->emplace_back();
		}
		_ns4__BaseFaultType_Description *n = &a->back();
		n->soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE__ns4__BaseFaultType_Description, SOAP_TYPE_std__vectorTemplateOf_ns4__BaseFaultType_Description, sizeof(_ns4__BaseFaultType_Description), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in__ns4__BaseFaultType_Description(soap, tag, NULL, ""))
				break;
		}
		else
		{	if (!soap_in__ns4__BaseFaultType_Description(soap, tag, n, ""))
			{	a->pop_back();
				break;
			}
		}
		soap_end_shaky(soap, soap_shaky);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<_ns4__BaseFaultType_Description>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOf_ns4__BaseFaultType_Description(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOf_ns4__BaseFaultType_Description(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<_ns4__BaseFaultType_Description> *p;
	size_t k = sizeof(std::vector<_ns4__BaseFaultType_Description> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<_ns4__BaseFaultType_Description> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<_ns4__BaseFaultType_Description> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<_ns4__BaseFaultType_Description>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOf_ns4__BaseFaultType_Description, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons3__NotificationMessageHolderType(struct soap *soap, std::vector<ns3__NotificationMessageHolderType *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons3__NotificationMessageHolderType(struct soap *soap, const std::vector<ns3__NotificationMessageHolderType *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns3__NotificationMessageHolderType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons3__NotificationMessageHolderType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons3__NotificationMessageHolderType(struct soap *soap, const char *tag, int id, const std::vector<ns3__NotificationMessageHolderType *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns3__NotificationMessageHolderType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons3__NotificationMessageHolderType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns3__NotificationMessageHolderType *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons3__NotificationMessageHolderType(struct soap *soap, const char *tag, std::vector<ns3__NotificationMessageHolderType *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons3__NotificationMessageHolderType(soap)))
			return NULL;
		a->emplace_back();
		ns3__NotificationMessageHolderType * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_ns3__NotificationMessageHolderType, SOAP_TYPE_std__vectorTemplateOfPointerTons3__NotificationMessageHolderType, sizeof(ns3__NotificationMessageHolderType), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons3__NotificationMessageHolderType(soap, tag, NULL, "ns3:NotificationMessageHolderType"))
				break;
		}
		else
		{	if (!soap_in_PointerTons3__NotificationMessageHolderType(soap, tag, n, "ns3:NotificationMessageHolderType"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns3__NotificationMessageHolderType *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons3__NotificationMessageHolderType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons3__NotificationMessageHolderType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns3__NotificationMessageHolderType *> *p;
	size_t k = sizeof(std::vector<ns3__NotificationMessageHolderType *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns3__NotificationMessageHolderType *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns3__NotificationMessageHolderType *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns3__NotificationMessageHolderType *>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfPointerTons3__NotificationMessageHolderType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfxsd__anyURI(struct soap *soap, std::vector<std::string> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfxsd__anyURI(struct soap *soap, const std::vector<std::string> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_xsd__anyURI(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfxsd__anyURI(struct soap *soap, const char *tag, int id, const std::vector<std::string> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_xsd__anyURI(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string> * SOAP_FMAC4 soap_in_std__vectorTemplateOfxsd__anyURI(struct soap *soap, const char *tag, std::vector<std::string> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfxsd__anyURI(soap)))
			return NULL;
		if (!a->empty() && a->size() == a->capacity())
		{	const void *p = &a->front();
			a->emplace_back();
			DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Vector capacity increased to %lu to fit %lu items: updating pointers\n", a->capacity(), a->size()));
			soap_update_pointers(soap, (const char*)&a->front(), (const char*)p, (a->size() - 1) * sizeof(std::string));
		}
		else
		{	a->emplace_back();
		}
		std::string *n = &a->back();
		soap_default_xsd__anyURI(soap, n);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_xsd__anyURI, SOAP_TYPE_std__vectorTemplateOfxsd__anyURI, sizeof(std::string), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_xsd__anyURI(soap, tag, NULL, "xsd:anyURI"))
				break;
		}
		else
		{	if (!soap_in_xsd__anyURI(soap, tag, n, "xsd:anyURI"))
			{	a->pop_back();
				break;
			}
		}
		soap_end_shaky(soap, soap_shaky);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::string>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfxsd__anyURI(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfxsd__anyURI(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<std::string> *p;
	size_t k = sizeof(std::vector<std::string> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<std::string> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<std::string> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<std::string>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfxsd__anyURI, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons3__TopicExpressionType(struct soap *soap, std::vector<ns3__TopicExpressionType *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons3__TopicExpressionType(struct soap *soap, const std::vector<ns3__TopicExpressionType *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns3__TopicExpressionType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons3__TopicExpressionType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons3__TopicExpressionType(struct soap *soap, const char *tag, int id, const std::vector<ns3__TopicExpressionType *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns3__TopicExpressionType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons3__TopicExpressionType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns3__TopicExpressionType *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons3__TopicExpressionType(struct soap *soap, const char *tag, std::vector<ns3__TopicExpressionType *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons3__TopicExpressionType(soap)))
			return NULL;
		a->emplace_back();
		ns3__TopicExpressionType * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_ns3__TopicExpressionType, SOAP_TYPE_std__vectorTemplateOfPointerTons3__TopicExpressionType, sizeof(ns3__TopicExpressionType), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons3__TopicExpressionType(soap, tag, NULL, "ns3:TopicExpressionType"))
				break;
		}
		else
		{	if (!soap_in_PointerTons3__TopicExpressionType(soap, tag, n, "ns3:TopicExpressionType"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns3__TopicExpressionType *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons3__TopicExpressionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons3__TopicExpressionType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns3__TopicExpressionType *> *p;
	size_t k = sizeof(std::vector<ns3__TopicExpressionType *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns3__TopicExpressionType *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns3__TopicExpressionType *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns3__TopicExpressionType *>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfPointerTons3__TopicExpressionType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfxsd__anyType(struct soap *soap, std::vector<struct soap_dom_element> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfxsd__anyType(struct soap *soap, const std::vector<struct soap_dom_element> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<struct soap_dom_element> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_xsd__anyType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfxsd__anyType(struct soap *soap, const char *tag, int id, const std::vector<struct soap_dom_element> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<struct soap_dom_element> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_xsd__anyType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<struct soap_dom_element> * SOAP_FMAC4 soap_in_std__vectorTemplateOfxsd__anyType(struct soap *soap, const char *tag, std::vector<struct soap_dom_element> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfxsd__anyType(soap)))
			return NULL;
		if (!a->empty() && a->size() == a->capacity())
		{	const void *p = &a->front();
			a->emplace_back();
			DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Vector capacity increased to %lu to fit %lu items: updating pointers\n", a->capacity(), a->size()));
			soap_update_pointers(soap, (const char*)&a->front(), (const char*)p, (a->size() - 1) * sizeof(struct soap_dom_element));
		}
		else
		{	a->emplace_back();
		}
		struct soap_dom_element *n = &a->back();
		soap_default_xsd__anyType(soap, n);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_xsd__anyType, SOAP_TYPE_std__vectorTemplateOfxsd__anyType, sizeof(struct soap_dom_element), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_xsd__anyType(soap, tag, NULL, "xsd:anyType"))
				break;
		}
		else
		{	if (!soap_in_xsd__anyType(soap, tag, n, "xsd:anyType"))
			{	a->pop_back();
				break;
			}
		}
		soap_end_shaky(soap, soap_shaky);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<struct soap_dom_element>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfxsd__anyType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfxsd__anyType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<struct soap_dom_element> *p;
	size_t k = sizeof(std::vector<struct soap_dom_element> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<struct soap_dom_element> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<struct soap_dom_element> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<struct soap_dom_element>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfxsd__anyType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__ScheduledEvent(struct soap *soap, std::vector<ns1__ScheduledEvent *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__ScheduledEvent(struct soap *soap, const std::vector<ns1__ScheduledEvent *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__ScheduledEvent *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__ScheduledEvent(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__ScheduledEvent(struct soap *soap, const char *tag, int id, const std::vector<ns1__ScheduledEvent *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__ScheduledEvent *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__ScheduledEvent(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__ScheduledEvent *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__ScheduledEvent(struct soap *soap, const char *tag, std::vector<ns1__ScheduledEvent *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__ScheduledEvent(soap)))
			return NULL;
		a->emplace_back();
		ns1__ScheduledEvent * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_ns1__ScheduledEvent, SOAP_TYPE_std__vectorTemplateOfPointerTons1__ScheduledEvent, sizeof(ns1__ScheduledEvent), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons1__ScheduledEvent(soap, tag, NULL, "ns1:ScheduledEvent"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__ScheduledEvent(soap, tag, n, "ns1:ScheduledEvent"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__ScheduledEvent *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__ScheduledEvent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__ScheduledEvent(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__ScheduledEvent *> *p;
	size_t k = sizeof(std::vector<ns1__ScheduledEvent *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns1__ScheduledEvent *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns1__ScheduledEvent *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__ScheduledEvent *>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfPointerTons1__ScheduledEvent, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.cpp */
