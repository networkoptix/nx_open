#!/usr/bin/env python

"""A tool for patching ninja rules/build files generated by CMake."""

import os
import sys
import argparse
import re
import traceback
from pathlib import Path

from ninja_file_processor.ninja_file_processor import NinjaFileProcessorError
from ninja_file_processor.build_ninja_processor import BuildNinjaFileProcessor
from ninja_file_processor.rules_ninja_processor import RulesNinjaFileProcessor

NINJA_BUILD_FILE_NAME = 'build.ninja'
NINJA_PREBUILD_FILE_NAME = 'pre_build.ninja'

def clean_build_directory(build_dir: str,
        build_file_processor: BuildNinjaFileProcessor = None,
        remove_unknown_files: bool = True) -> None:

    if build_file_processor is None:
        build_filename = os.path.join(build_dir, NINJA_BUILD_FILE_NAME)
        build_file_processor = BuildNinjaFileProcessor(build_filename)

    if not build_file_processor.is_loaded():
        build_file_processor.load_data()

    build_files = build_file_processor.get_known_files()
    known_files = get_files_from_list_file(os.path.join(build_dir, "known_files.txt"))
    conan_files = get_files_from_conan_manifest(
        os.path.join(build_dir, "conan_imports_manifest.txt"))

    all_known_files = set()
    for file_name in build_files | known_files | conan_files:
        file_path = Path(file_name)
        if file_path.is_absolute():
            try:
                file_path_relative = file_path.relative_to(build_dir)
                all_known_files.add(file_path_relative.as_posix())
            except ValueError:
                pass
        else:
            all_known_files.add(file_path.as_posix())

    extra_files = find_extra_files(build_dir, all_known_files)

    if remove_unknown_files:
        print("Cleaning build directory...")

    for file in extra_files:
        if not os.path.isfile(file):
            continue
        if remove_unknown_files:
            os.remove(file)
        else:
            print(file)

    if remove_unknown_files:
        print("Done")


def get_files_from_list_file(list_file_name: str) -> set:
    result = set()
    with open(list_file_name) as list_file:
        for line in list_file:
            file_name = line.strip()
            result.add(file_name)

    return result


def get_files_from_conan_manifest(conan_manifest_file_name: str) -> set:
    result = set()
    try:
        with open(conan_manifest_file_name) as manifest:
            for line in manifest:
                sep = line.find(':')
                if sep > 0:
                    file_name = line[:sep]
                    result.add(str(Path(file_name).as_posix()))
    except OSError:
        pass

    return result


def find_extra_files(build_dir: Path, known_files: set) -> list:
    """Find files not needed to the build."""

    exclusion_dirs = {
        'CMakeFiles',
        '_autogen'
    }

    exclusion_extensions = {
        '.pdb',
        '.cpp_parameters',
        '.cab',
        '.CABinet',
    }

    exclusions = {
        NINJA_BUILD_FILE_NAME,
        NINJA_PREBUILD_FILE_NAME,
        "CTestTestfile.cmake",
        "cmake_install.cmake",
        "CMakeCache.txt",
        "rules.ninja",
        ".ninja_deps",
        ".ninja_log",
        "conanbuildinfo.cmake",
        "conanbuildinfo.txt",
        "conaninfo.txt",
        "conan.lock",
        "conan_imports_manifest.txt",
        "graph_info.json",
        "pre_build.log",
    }

    result = []

    build_dir_path = Path(build_dir).resolve()
    for file in build_dir_path.rglob('*'):
        if any(d in file.parent.parts for d in exclusion_dirs):
            continue
        if file.name in exclusions or file.suffix in exclusion_extensions:
            continue
        if str(file.relative_to(build_dir_path).as_posix()) in known_files:
            continue

        result.append(build_dir_path.joinpath(file))

    return result


def run_script(build_dir: str, script_file_name: str, force_patch: bool) -> None:
    strengthened_targets = set()
    commands_to_run = list()
    do_clean = False

    print(f"Reading script {script_file_name}...")
    with open(script_file_name) as script_file:
        for line in script_file:
            line = line.rstrip()
            if not line:
                continue

            command, *args = re.split(r'\s+', line, 1)
            if command == "strengthen":
                if not args:
                    print("Missing argument for \"strengthen\" command")
                    continue
                strengthened_targets.add(args[0])
            elif command == "run":
                if not args:
                    print("Missing argument for \"run\" command")
                    continue
                commands_to_run.append(args[0])
            elif command == "clean":
                do_clean = True
            else:
                print(f"Unknown command: {command}")

    print("Done")

    build_file_name = os.path.join(build_dir, NINJA_BUILD_FILE_NAME)
    build_file_processor = BuildNinjaFileProcessor(build_file_name)

    if do_clean:
        clean_build_directory(build_dir=build_dir, build_file_processor=build_file_processor)

    patch_ninja_build(file_name=build_file_name,
        strengthened_targets=strengthened_targets,
        script_timestamp=os.path.getmtime(script_file_name),
        build_file_processor=build_file_processor,
        force_patch=force_patch)

    for command in commands_to_run:
        print(f"Running {command}...")
        os.system(command)

    print("All done")


def patch_ninja_build(
        file_name: str,
        strengthened_targets: set,
        script_timestamp: float,
        build_file_processor: BuildNinjaFileProcessor,
        force_patch: bool = False) -> None:
    """Do patching of build.ninja. Also searches for the "include" directive for rules.ninja, and
    patches rules.ninja too.

    :param file_name: "build.ninja" file name, including the full path to it.
    :type file_name: str
    :param strengthened_targets: Set of targets to make transitively dependent on their
        dependencies.
    :type strengthened_targets: set
    :param script_timestamp: Modification time of the script file.
    :type script_timestamp: float
    :param build_file_processor: The instance of BuildNinjaFileProcessor class.
    :type build_file_processor: BuildNinjaFileProcessor
    :param force_patch: Whether force-patch file, regardless of the script modification time,
        defaults to False
    :type force_patch: bool, optional
    """

    # Patch the file only if it needs patching (it was not patched yet or its modification time is
    # older than the modification time of the patch script) or the patching is enforced by the
    # command-line parameter.
    if not force_patch:
        if not build_file_processor.needs_patching(script_version_timestamp=script_timestamp):
            print(f"{file_name} is already patched, do nothing")
            return

    if not build_file_processor.is_loaded():
        build_file_processor.load_data()

    print("Patching build.ninja...")
    patch_rules_file(
        build_file_processor, script_timestamp=script_timestamp, force_patch=force_patch)
    if strengthened_targets:
        build_file_processor.strengthen_dependencies(strengthened_targets)
    build_file_processor.save_data()
    print("Done")


def patch_rules_file(
        build_file_processor: BuildNinjaFileProcessor,
        script_timestamp: float,
        force_patch: bool = False) -> None:

    rules_file_name = build_file_processor.get_rules_file_name()
    rules_file_processor = RulesNinjaFileProcessor(rules_file_name)

    if not force_patch:
        if not rules_file_processor.needs_patching(script_version_timestamp=script_timestamp):
            print(f"{rules_file_name} is already patched, do nothing")
            return

    rules_file_processor.load_data()

    print("Patching rules.ninja...")
    rules_file_processor.patch_cmake_rerun()
    rules_file_processor.save_data()
    print("Done")


def redirect_output(file_name):
    """Redirects stderr and stdout to the file."""

    log_dir = os.path.dirname(file_name)
    Path(log_dir).mkdir(parents=True, exist_ok=True)

    log_fd = open(file_name, 'w')
    sys.stdout = log_fd
    sys.stderr = log_fd


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "-d", "--build-dir",
        type=str,
        help="Ninja build directory.",
        default=os.getcwd())
    parser.add_argument(
        "-f", "--force",
        action='store_true',
        help="Force ninja file patching.")
    parser.add_argument(
        "-c", "--clean",
        action='store_true',
        help="Do the cleaning and exit.")
    parser.add_argument(
        "-l", "--list-unknown",
        action='store_true',
        help="List files unknown to the build system, and exit.")
    parser.add_argument(
        "-o", "--log-output",
        type=str,
        help="Log file name.",
        dest="output",
        action='store',
        nargs='?',
        const=os.path.join(os.getcwd(), "build_logs", "pre_build.log"),
        default=None)
    parser.add_argument(
        "-t", "--stack-trace",
        action='store_true',
        help="Print stack trace if an error occured.")

    args = parser.parse_args()

    if args.output is not None:
        redirect_output(args.output)

    build_dir = os.path.abspath(args.build_dir)

    try:
        if args.clean:
            clean_build_directory(build_dir=build_dir)
        elif args.list_unknown:
            clean_build_directory(build_dir=build_dir, remove_unknown_files=False)
        else:
            script_filename = os.path.join(build_dir, NINJA_PREBUILD_FILE_NAME)
            run_script(
                build_dir=build_dir, script_file_name=script_filename, force_patch=args.force)

    except NinjaFileProcessorError as ex:
        if args.stack_trace:
            message = ''.join(traceback.TracebackException.from_exception(ex).format())
        else:
            message = str(ex)
        sys.exit(f"{message}\nAn error occured while processing ninja files, exiting")

    except OSError as ex:
        if args.stack_trace:
            message = ''.join(traceback.TracebackException.from_exception(ex).format())
        else:
            message = str(ex)
        sys.exit(f"{message}\nAn error occured while performing file operation, exiting")

if __name__ == "__main__":
    main()
